概述
-------
本文修摘自《javascript权威指南》第6版
javascript是一门弱类型、非传统面向对象的编程语言。
javascript和java是完全不同的两种编程语言。
ECMAScript是javascript的语言标准版本，现在最新版本为ES6。

以下先对javascript做一个快速概览
```javascript
javascript语言核心快速概览
//这是注释
var x; //声明变量
x=0    //通过等号赋值给变量
//javascript支持多种数据类型
x=1;               //数字
x=0.01;            //整数和实数共用一种数据类型
x="hello world";   //双引号内的文本构成的字符串
x='javascript';    //单引号内的文本构成的字符串
x=true;            //布尔值
x=false;           //布尔值
x=null;            //null是一个特殊的值，意思是”空“
x=undefined        //undefined和null非常类似
//javascript中的最重要的类型就是对象
//对象是名/值对的集合，或字符串到值映射的集合
var book = {            //对象是由花括号括起来的
    topic: "javascript",  //属性topic的值是javascript
    fat: true             //属性fat的值是true
}                       //右花括号标记了对象的结束
//通过“.”和“[]”来访问对象属性
book.topic                 //=> "javascript"
book["fat"]               //=> true 另外一种获取属性的方式
book.author = "Flanagan";  //通过赋值创建一个新属性
book.contents = {};        //{}是一个空对象，它没有属性
//javascript数组（以数字为索引的列表）
var primes = [2, 3, 5, 7]; //拥有4个值的数组，由“[”和“]”划定边界
primes[0]                  //=> 2 数组中的第一个元素（索引为0）
primes.length              //=> 4 数组中元素个数
primes[primes.length -1]   //=> 7 数组的最后一个元素
primes[4] = 9;             //通过赋值来添加新元素
primes[4] = 11;            //或通过赋值来改变已有的元素
var empty = [];            //[]是空数组，它具有0个元素
empty.length               //=>0 空数组的长度为0
//数组和对象都可以包含另一个数组或对象
var points = [             //具有两个元素的数组
    {x: 0, y: 0},          //每个元素都是一个对象
    {x: 1, y: 1}
];
var data = {               //一个包含两个属性的对象
    trial1: [[1,2],[3,4]], //每一个属性都是数组
    trial2: [[2,3],[4,5]]  //数组的元素也是数组
};
//运算符作用于操作数，生成一个新的值
//最常见的是算术运算符
3 + 2                      //=> 5 加法                     
3 - 2                      //=> 1 减法
3 * 2                      //=> 6 乘法
3 / 2                      //=> 1.5 除法
points[1].x - points[0].x  //=> 1 更复杂的操作数也能照常工作
"3" + "2"                  //=> "32" 符号+可以完成加法运算也可以作字符串连接
//javascript定义了一些算术运算符的简写形式
var count = 0;             //定义一个变量
count++;                   //自增1
count--;                   //自减1
count += 2;                //自增2 和“count = count + 2;”写法一样
count *= 3;                //自乘3 和“count = count * 3;”写法一样
count                      //=> 6 变量名本身也是一个表达式
//相等关系运算符用来判断两值是否相等
//不等、大于、小于运算符的运算结果是true或false
var x = 2, y = 3;          //这里的=等号是赋值的意思，不是比较相等
x == y                     //=> false 相等
x != y                     //=> true 不等
x < y                      //=> true 小于
x <= y                     //=> true 小于等于
x > y                      //=> false 大于
x >= y                     //=> false 大于等于
"two" == "three"           //=> false 两个字符串不相等
"two" > "three"            //=> true “tw”在字母表中的索引大于“th”
false == (x > y)           //=> true false和false相等
//逻辑运算符是对布尔值的合并或求反
(x == 2) && (y ==3 )       //=> true 两个比较都是true，&&表示“与”
(x > 3) || (y < 3)         //=> false 两个比较都不是true，||表示“或”
!(x == y)                  //=> true !求反
//函数是带有名称和参数的javascript代码段，可以一次定义多次调用
function plus1(x) {        //定义了名为plus1的一个函数，带有参数x
    return x + 1;          //返回一个比传入的参数大的值
}                          //函数的代码块是由花括号包裹起来的部分
plus1(y)                   //=>4 y为3，调用函数的结果为 3 + 1
var square = function(x) { //函数是一种值，可以赋值给变量
    return x * x;          //计算函数的值
};                         //分号标识了赋值语句的结束
square(plus1(y))           //=> 16 在一个表达式中调用两个函数
//当将函数和对象合写在一起时，函数就变成了“方法”（method）
//当函数赋值给对象的属性，我们称为“方法”，所有的javascript对象都含有方法
var a = [];                           //创建一个空数组
a.push(1, 2, 3);                      //push()方法向数组中添加元素
a.reverse();                          //另一个方法：将数组元素的次序反转
//我们也可以定义自己的方法，“this”关键字是对定义方法的对象的引用，这里的例子是上文中提到的包含两个点位置信息的数组
points.dist = function() {            //定义一个方法用来计算两点之间的距离
    var p1 = this[0];                 //通过this获得对当前数组的引用
    var p2 = this[1];                 //并获得调用的数组前两个元素
    var a = p2.x - p1.x;              //x坐标轴上的距离
    var b = p2.y - p1.y;              //y坐标轴上的距离
    return Math.sqrt(a * a + b * b);  //勾股定理，用Math.sqrt()来计算平方根
}
points.dist();                        //=> 1.414 求得两个点之间的距离
//控制语句
function abs(x) {                     //求绝对值的函数
    if (x > =0) {                     //if语句
        return x;                     //如果比较结果为true则执行这里的代码
    }                                 //子句的结束
    else {                            //当if条件不满足时执行else子句
        return - x;                   //返回负x
    }                                 //如果分支中只有一条语句，花括号是可以省略的
}                                     //注意if/else中嵌套的return语句
function factorial(n) {               //计算阶乘的函数
    var product = 1;                  //给product赋值为1
    while (n > 1) {                   //当()内的表达式为true时循环执行{}内的代码
        product *= n;                 //product = product *n的简写形式
        n--;                          //n = n -1的简写形式
    }                                 //循环结束
    return product;                   //返回product
}
factorial(4)                          //=> 24 1*4*3*2
function factorial2(n) {              //实现循环的另一种写法
    var i, product = 1;               //给product赋值为1
    for (i = 2; i<=n; i++)            //将i从2自增至n
        product *= i;                 //循环体，当循环体中只有一句代码，可以省略{}
    return product;                   //返回计算好的阶乘
}
factorial2(5)                         //=> 120 1*2*3*4*5
//类，在javascript中定义一个类来表示2D平面几何中的点，这个类实例化的对象拥有一个名为r()的方法，用来计算该点到原点的距离
//定义一个构造函数以初始化一个新的point对象
function Point(x,y) {                 //按照惯例，构造函数均以大写字母开始
    this.x = x;                       //关键字this指代初始化的实例
    this.y = y;                       //将函数参数存储为对象的属性
}                                     //不需要return
//使用new关键字和构造函数来创建一个实例
var p =new Point(1, 1);               //平面几何中的点(1,1)
//通过给构造函数的prototype对象赋值
//来给Point对象定义方法
Point.prototype.r = function() {
    return Math.sqrt(                 //返回 x*x + y*y的平方根
    this.x * this.x +                 //this指代调用这个方法的对象
    this.y * this.y);
}
//Point的实例对象p（以及所有的Point实例对象）继承了方法r()
p.r()                                 //=> 1.414...
```

```
客户端javascript快速概览
javascript代码可以通过<script>标签来嵌入到HTML文件中：
<html>
<head>
引入一个javascript库
<script src="library.js"></script>
</head>
<body>
<p>this is a paragraph of HTML</p>
<script>
在这里编写嵌入到HTML文件中的javascript代码
</script>
<p>here is more HTML.</p>
</body>
</html>
```

```javascript
web浏览器端的脚本技术，涵盖客户端javascript中的一些重要全局函数
```



词法结构
----------
编程语言的词法结构是一套基础性规则，用来描述如何使用这门语言来编写程序。作为语法基础，它规定了诸如变量名是什么样的、怎么写注释，以及程序语句之间如何分隔等规则。本章用很短的篇幅来介绍javascript的词法结构。

**2.1字符集**
javascript程序是用Unicode字符集编写的。Unicode是ASCII和Latin-1的超集，并支持地球上几乎所有在用的语言。ECMAScript3要求javascript的实现必须支持Unicode2.1及后续版本，ECMAScript5则要求支持Unicode3及后续版本。可以参考3.2节的“边栏”来了解更多关于Unicode和javascript的信息。

**2.1.1区分大小写**
javascript是区分大小写的语言。也就是说，关键字、变量、函数名和所有的标识符（identifier）都必须采取一致的大小写形式。比如，关键字“while”必须写成“while”，而不能写成“While”或者“WHILE”。同样，“online”、“Online”、“OnLine”和“ONLINE”是4个不同的变量名。

但需要注意的是，HTML并不区分大小写（尽管XHTML区分大小写）。由于它和客户端javascript联系紧密，因此这点区分很容易混淆。许多客户端javascript对象和属性与它们所表示的HTML标签和属性同名。在HTML中，这些标签和属性名可以使用大写也可以是小写，而在javascript中则必须是小写。例如，在HTML中设置事件处理程序时，onclick属性可以写成onClick，但在javascript中必须写成小写onclick。

**2.1.2空格、换行符和格式控制符**

javascript会忽略程序中标识（token）之间的空格。多数情况下，javascript同样会忽略换行符（2.5节提到一种意外情形）。由于可以在代码中随意使用空格和换行，因此可以采用整齐、一致的缩进来形成统一的编码风格，从而提高代码的可读性。

除了可以识别普通的空格符（\u0020），javascript还可以识别如下这些表示空格的字符：水平制表符（\u0009）、垂直制表符（\u0008）、换页符（\u000C）、不中断空白（\u00A0）、字节序标记（\uFEFF），以及在Unicode中所有Zs类别的字符。javascript将如下字符识别为行结束符：换行符（\u000A），回车符（\u000D），行分隔符（\u2028），段分隔符（\u2029）。回车符加换行符在一起被解析为一个单行结束符。

Unicode格式控制字符（Cf类），比如“从右至左书写标记”（\u200F）和“从左至右书写标记”（\u200E），控制着文本的视觉显示，这对于一些非英语文本的正确显示来说是至关重要的，这些字符可以用在javascript的注释、字符串直接量和正则表达式直接量中，但不能用在标识符（比如，变量名）中。但有个例外，零宽连接符（\u200D）和零宽非连接符（\uFEFF）是可以出现在标识符中的，但不能作为标识符的首字符。上文也提到了，字节序标记格式控制符（\uFEFF）被当成了空格来对待。

**2.1.3Unicode 转义序列**

在有些计算机硬件和软件里，无法显示或输入Unicode字符全集。为了支持那些使用老旧技术的程序员、javascript定义了一种特殊序列，使用6个ASCII字符来代表任意16位Unicode内码。这些Unicode转义序列均以\u前缀，其后跟随4个十六进制数（使用数字以及大写或小写字母A~F表示）。这种Unicode转义写法可以用在javascript字符串直接量、正则表达式直接量和标识符中（关键字除外）。例如，字符é的Unicode转义写法为\u00E9，如下两个javascript字符串是完全一样的：
```javascript
"café" === "caf\u00e9" //=>true
```
Unicode转义写法也可以出现在注释中，但由于javascript会将注释忽略，它们只是被当成上下文中的ASCII字符处理，而且并不会被解析为其对应的Unicode字符。

**2.1.4标准化**

Unicode允许使用多种方法对同一个字符进行编码。比如，字符“é”可以使用Unicode字符\u00E9表示，也可以使用普通的ASCII字符é跟随一个语调符\u0301。在文本编辑器中，这两种编码的显示结果一模一样，但它们的二进制编码表示是不一样的，在计算机里也不相等。Unicode标准为所有字符定义了一个首选的编码格式，并给出了一个标准化的处理方式将文本转换为一种适合比较的标准格式，Javascript会认为它正在解析的程序代码已经是这种标准格式，不会再对其标识符、字符串或正则表达式作标准化处理。

**2.2注释**

javascript支持两种格式的注释。在行尾“//”之后的文本都会被javascript当做注释忽略掉。此外，“/*”和“*/”之间的文本也会当做注释，这种注释可以跨行书写，但不能有嵌套的注释。下面都是合法的Javascript注释：
```javascript
//这里是单行注释
/*这里是一段注释*/ //这里是另一段注释
/*
*这又是一段注释
*这里的注释可以连写多行
*/
```

**2.3直接量**

所谓直接量（literal），就是程序中直接使用的数据值。下面列出的都是直接量：
```javascript
12 //数字
1.2//小数
"hello world"//字符串文本
'Hi'//另一个字符串
true//布尔值
false//另一个布尔值
/javascript/gi //正则表达式直接量（用做模式匹配）
null //空
```
第三章会详细讲解数字和字符串直接量。正则表达式直接量会在第10章讲解。更多复杂的表达方式（参见4.2节）可以写成数组或对象直接量，例如：
```javascript
{x:1,y:2}//对象
[1,2,3,4,5]//数组
```

**2.4标识符和保留字**

标识符就是一个名字。在javascript中，标识符用来对变量和函数进行命名，或者用做javascript代码中某些循环语句中的跳转位置的标记。在javascript标识符必须以字母、下划线（_）或美元符（$）开始。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便javascript可以轻易区分开标识符和数字）。下面是合法的标识符：
```javascript
i
my_variable_name
v13
_dummy
$str
```
由于可移植性和易于书写的考虑，通常我们只使用ASCII字母和数字来书写标识符。然而需要注意的是，javascript允许标识符中出现Unicode字符全集中的字母和数字。（从技术上讲，ECMAScript标准也允许在标识符的首字符后面出现Unicode字符集中的Mn类、Mc类和Pc类）。由此，程序员也可以使用非英语语言或数学符号来书写标识符：
```javascript
var si = true;
var π = 3.14;
```
和其他任何编程语言一样，javascript保留了一些标识符为自己所用。这些“保留字”不能用做普通的标识符，下面会讲到。

保留字：
javascript把一些标识符拿出来用做自己的关键字。因此，就不能再在程序中把这些关键字用做标识符了：

break delete function return typeof case do if switch var catch else in this void continue false instanceof throw while debugger finally new true with default for null try

javascript同样保留了一些关键字，这些关键字在当前的语言版本中并没有使用，但在未来版本中可能会用到。ECMAScript5保留了这些关键字：
```javascript
class const enum export extends import super
```
此外，下面这些关键字在普通的javascript代码中是合法的，但是在严格模式下是保留字：
```javascript
implements let private public yield
interface package protected static
```
严格模式同样对下面的标识符的使用做了严格限制，它们并不完全是保留字，但不能用做变量名、函数名或参数名：
```javascript
arguments eval
```
ECMAScript3将java的所有关键字都列为自己的保留字，尽管这些保留字在ECMAScript5中放宽了限制，但如果你希望代码能在基于ECMAScript3实现的解释器上运行的话，应当避免使用这些关键字作为标识符：

abstract double goto native static boolean enum implements package super byte export import private synchronized char extends int protected throws class final interface public transient const float long short volatile

javascript预定义了很多全局变量和函数，应当避免把它们的名字用做变量名和函数名：

arguments encodeURI Infinity Number RegExp Array encodeURIComponent isFinite Object String Boolean Error isNaN parseFloat SyntaxError
Date eval JSON parseInt TypeError decodeURI EvalError Math RangeError undefined decodeURIComponent Function NaN ReferenceError URIError

javascript的具体实现可能定义独有的全局变量和函数，每一种特定的javascript运行环境（客户端、服务器端等）都有自己的一个全局属性列表，这一点是需要牢记的。参照第四部分的Window对象来了解客户端javascript中定义的全局变量和函数列表。

**2.5可选的分号**
和其他编程语言一样，javascript使用分号（;）将语句（参见第5章）分隔开。这对增强代码的可读性和整洁性是非常重要的：缺少分隔符，一条语句的结束就成了下一条语句的开始，反之亦然。在javascript中，如果语句各自独占一行，通常可以省略语句之间的分号（程序结尾或右花括号“}”之前的分号也可以省略）。许多javascript程序员（包括本书中的示例代码）使用分号来明确标记语句的结束，即使在并不完全需要分号的时候也是如此。另一种风格就是，在任何可以省略分号的地方都将其省略，只有在不得不用的时候才使用分号。不管采用哪种编程风格，关于javascript中可选分号的问题有几个细节需要注意。
考虑如下代码，因为两条语句用两行书写，第一个分号是可以省略掉的：
```javascript
a = 3;
b = 4;
```
如果按照如下格式书写，第一个分号则不能省略：
```javascript
a = 3; b = 4;
```
需要注意的是，javascript并不是在所有行处都填补分号：只有在缺少了分号就无法正确解析代码的时候，javascript才会填补分号。换句话讲（类似下面代码中的两处异常），如果当前语句和随后的非空格字符不能当成一个整体来解析的话，javascript就在当前语句行结束处填补分号。看一下如下代码：
```javascript
var a
a
=
3
console.log(a)
```
javascript将其解析为：
```javascript
var a; a = 3; console.log(a);
```
javascript给第一行换行处添加了分号，因为如果没有分号，javascript就无法解析代码 var a a。
第二个a可以单独当做一条语句“a;”，但javascript并没有给第二行结尾填补分号，因为它可以和第三行内容一起解析成“a=3;”。

这些语句的分隔规则会导致一些意想不到的情形，这段代码写成了两行，看起来是两条独立的语句：
```javascript
var y = x + f
(a+b).toString()
```
但第二行的圆括号却和第一行的f组成了一个函数调用，javascript会把这段代码看作做：
```javascript
var y = x + f(a+b).toString();
```
而这段代码的本意并不是这样。为了能让上述代码解析为两条不同的语句，必须手动填写行尾的显式分号。

通常来讲，如果一条语句以“(”、“[”、“/”、“+”或“-”开始，那么它极有可能和前一条语句合在一起解析。以“/”、“+”和“-”开始的语句并不常见，而以“(”和“[”开始的语句则非常常见，至少在一些javascript编码风格中是很普遍的。有些程序员喜欢保守地在语句前加一个分号，这样哪怕之前的语句被修改了，分号被误删了，但前语句还是会正确地被解析：
```javascript
var x = 0 //这里省略了分号
;[x,x+1,x+2].forEach(console.log); //前面的分号保证了正确地语句解析
```
如果当前语句和下一行语句无法合并解析，javascript则在第一行后填补分号，这是通用规则，但有两个例外。第一个例外是在涉及return、break和continue语句的场景中。如果这三个关键字后紧跟着换行，javascript则会在换行处填补分号。例如，这段代码：
```javascript
return
true;
```
javascript会被解析成：
```javascript
return; true;
```
而代码的本意是这样：
```javascript
return true;
```
也就是说，在return、break和continue和随后的表达式之间不能有换行。如果添加了换行，程序则只有在极特殊的情况的下才会报错，而且程序的调试非常不方便。

第二个例外是在涉及“++”和“--”运算符（见4.8节）的时候。这些运算符可以作为表达式的前缀，也可以当做表达式的后缀。如果将其用做后缀表达式，它和表达式应当在同一行。否则，行尾将填补分号，同时“++”或“--”将会作为下一行代码的前缀操作符并与之一起解析，例如，这段代码：
```javascript
x
++
y
```
这段代码将被解析为“x;++y”，而不是“x++;y”。

第3章 类型、值和变量
--------------------

计算机程序的运行需要对值（value）（比如数字3.14或文本“hello world”）进行操作。
在编程语言中，能够表示并操作的值的类型称做数据类型（type），编程语言最基本的特性就是能够支持多种数据类型。当程序需要将值保存起来以备将来使用时，便将其赋值给（将值“保存”到）一个变量（variable）。变量是一个值的符号名称，可以通过名称来获得对值得引用。变量的工作机制是编程语言的另一个基本特性。本章将详细讲解javascript中的类型、值和变量。这里的引言只做概述，你可以通过参照1.1节来帮助理解本章内容。后续章节会更深入地讲解。

javascript的数据类型分为两类：原始类型（primitive type）和对象类型（object type）。
javascript中的原始类型包括数字、字符串和布尔值，本章会有单独的章节专门讲述javascript中的数字（见3.1节）和字符串（见3.2节），布尔值将会在3.3节讲解。

javascript中有两个特殊的原始值，null（空）和undefined（未定义），它们不是数字、字符串和布尔值。它们通常分别代表了各自特殊类型的唯一的成员。3.4节将会详细讲解null和undefined。

javascript中除了数字、字符串、布尔值、null和undefined之外的就是对象了。对象（object）是属性（property）的集合，每个属性都由“名/值对”（值可以是原始值，比如数字、字符串，也可以是对象）构成。其中一个比较特殊的对象——全局对象（global object）——会在3.5节介绍，第6章会有更完整详细的描述。

普通的javascript对象是“命名值”的无序集合。javascript同样定义了一种特殊对象——数组（array），表示带编号的值的有序集合。javascript为数组定义了专用的语法，使数组拥有一些和普通对象不同的特有行为特性。第7章将专门讲述数组。

javascript还定义了另一种特殊对象——函数。函数是具有与它相关联的可执行代码的对象，通过调用函数来运行可执行代码，并返回运算结果。和数组一样，函数的行为特征和其他对象都不一样。javascript为使用函数定义了专用语法。对于javascript函数来讲，最重要的是，它们都是真值，并且javascript可以将它们当做普通对象来对待。第8章会专门讲述函数。

如果函数用来初始化（使用new运算符）一个新建的对象，我们称之为构造函数（constructor）。每个构造函数定义了一类（class）对象——由构造函数初始化的对象组成的集合。类可以看做是对象类型的子类型。除了数组（Array）类和函数（Function）类之外，javascript语言核心定义了其他三种有用的类。日期（Date）类定义了了代表日期的对象。正则（RegExp）类定义了表示正则表达式（一种强大的模式匹配工具，在第10章会讲到）的对象。错误（Error）类定义了那些表示javascript程序中运行时错误和语法错误的对象。可以通过定义自己的构造函数来定义需要的类。这会在第9章讲述。

javascript解释器有自己的内存管理机制，可以自动对内存进行垃圾回收（garbage collection）。这意味着程序可以按需创建对象，程序员则不必担心这些对象的销毁和内存回收。当不再有任何引用指向一个对象，解释器就会知道这个对象没用了，然后自动回收它所占用的内存资源。

javascript是一种面向对象的语言。不严格地讲，这意味着我们不用全局的定义函数去操作不同类型的值，数据类型本身可以定义方法（method）来使用值。例如，要对数组a中的元素进行排序，不必要将a传入sort()函数，而是调用a的一个方法sort():

    a.sort();// sort(a)的面向对象的版本
    
第9章将会讲述方法的定义。从技术上讲，只有javascript对象才能拥有方法。然而，数字、字符串和布尔值也可以拥有自己的方法（3.6节解释其工作机制）。在javascript中，只有null和undefined是无法拥有方法的值。

javascript的类型可以分为原始类型和对象类型，也可分为可以拥有方法的类型和不能拥有方法的类型，同样可分为可变（mutable）类型和不可变（imuutable）类型。可变类型的值是可修改的。对象和数组属于可变类型：javascript程序可以更改对象属性值和数组元素的值。数字、布尔值、null和undefined属于不可变类型——比如，修改一个数值的内容本身就说不通。字符串可以看成由字符组成的数组，你可能会认为它是可变的。然而在javascript中，字符串是不可变的：可以访问字符串任意位置的文本，但javascript并未提供修改已知字符串的文本内容的方法。3.7节会详细讲解可变类型和不可变类型的不同支持。

javascript可以自由地进行数据类型转换。比如，如果在程序期望使用字符串的地方使用了数字，javascript会自动将数字转换为字符串。如果在期望使用布尔值的地方使用了非布尔值，javascript也会进行相应的转换。类型转换规则将在3.8节讲述。javascript中灵活的类型转换规则对“判断相等”（equality）的定义亦有影响。等号运算符“==”所进行的类型转换细节将在3.8.1节详细讲述。

javasript变量是无类型的（untyped），变量可以被赋予任何类型的值，同样一个变量也可以重新赋予不同类型的值。使用var关键字来声明（declare）变量。javascript采用词法作用域（lexical scoping）。不在任何函数内声明的变量称做全局变量（global variable），它在javascript程序中的任何地方都是可见的。在函数内声明的变量具有函数作用域（function scope），并且只在函数内可见。变量声明和作用域将会在3.9节和3.10节详细讲解。

**3.1数字**

和其他编程语言不同，javascript不区分整数值和浮点数值。javascript中的所有数字均用浮点数值表示。javascript采用IEEE 754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是（正负1.7976931348623157乘以10的308次方），最小值是（正负5乘以10负324次方）。

按照javascript中的数字格式，能够表示的整数范围是从-9007199254740992~9007199254740992（即-2的53次方~2的53次方），包含边界值。如果使用了超过此范围的整数，则无法保证低位数字的精度。然而需要注意的是，javascript中实际的操作（比如数组索引，以及第4章讲到的位操作符）则是基于32位整数。

当一个数字直接出现在javascript程序中，我们称之为数字直接量（numeric literal）。javascript支持多种格式的数字直接量，在接下来的小节中会有讨论。注意，在任何数字直接量前添加负号（-）可以得到它们的负值。但负号是一元求反运算符（参见第4章），并不是数字直接量语法的组成部分。

**3.1.1整型直接量**

在javascript程序中，用一个数字序列表示一个十进制整数。例如：
```javascript
0
3 
10000000
```
除了十进制的整型直接量，javascript同样能识别十六进制（以16为基数）值。所谓十六进制的直接量是指以“0x”或“0X”为前缀，其后跟随十六进制数串的直接量。十六进制值是0~9之间的数字和a（A）~f（F）之间的字母构成，a-f的字母对应的表示数字10~15。下面是十六进制整型直接量的例子：
```javascript
0xff //15*16 + 15 = 255（十进制）
0xCAFE911
```
尽管ECMAScript标准不支持八进制直接量，但javascript的某些实现可以允许采用八进制（基数为8）形式表示整数。八进制直接量以数字0开始，其后跟随一个由0~7（包括0和7）之间的数字组成的序列，例如：

    0377 //3*64 + 7*8 + 7 = 255（十进制）
    
由于某些javascript的实现支持八进制直接量，而有些不支持，因此最好不要使用以0为前缀的整型直接量，毕竟我们也无法得知当前javascript的实现是否支持八进制的解析。在ECMAScript6（见5.7.3节）的严格模式下，八进制直接量是明令禁止的。

**3.1.2浮点型直接量**

浮点型直接量可以含有小数点，它们采用的是传统的实数写法。一个实数由整数部分、小数点和小数部分组成。

此外，还可以使用指数记数法表示浮点型直接量，即在实数后跟字母e或E，后面再跟正负号，其后再加一个整型的指数。这种记数方法表示的数值，是由前面的实数乘以10的指数次幂。

可以使用更简洁的语法表示：

    [digits][.digits][(E|e)[(+|-)]digits]

例如：
```javascript
3.14
2345.789
.333333333333333333
6.02e23 //6.02乘以10的23次方
1.4738223E-32 //1.4738223乘以10的负32次方
```

**3.1.3javascript中的算术运算**

javascript程序是使用语言本身提供的算术运算符来进行数字运算的。这些运算符包括加法运算符（+）、减法运算符（-）、乘法运算符（*）、除法运算符（/）和求余（求整除后的的余数）运算符（%）。第4章将详细介绍这些以及更多的运算符。

除了基本的运算符外，javascript还支持更加复杂的算术运算，这些复杂的运算通过作为Math对象的属性定义的函数和常量来实现：
```javascript
Math.pow(2,53)//=> 9007199254740992 2的53次幂
Math.round(.6)//=> 1.0 四舍五入
Math.ceil(.6)//=> 1.0 向上取整
Math.floor(.6)//=> 0.0 向下取整
Math.abs(-5)//=> 5 取绝对值
Math.max(x,y,z)//=> 返回最大值
Math.min(x,y,z)//=> 返回最小值
Math.random()//=> 生成一个大于等于0小于1.0的伪随机数
Math.PI //=> π 圆周率
Math.E //=> e 自然对数的底数
Math.sqrt(3) //=> 3的平方根
Math.pow(3，1/3) //=> 3的立方根
Math.sin(0) //=> 三角函数 还有Math.cos，Math.atan等
Math.log(10) //=> 10的自然对数
Math.log(100)/Math.LN10 //=> 以10为底100的对数
Math.log(512)/Math.LN2 //=> 以2为底512的对数
Math.exp(3) //e的三次幂
```
参阅第三部分中关于Math对象的介绍，那里列出了javascript所支持的所有数学函数。

javascript中的算术运算在溢出（overflow）、下溢（underflow）或被清零整除时不会报错。当数字运算结果超过了javascript所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，在javascript中以infinity表示。同样地，当负数的值超过了javascript所能表示的负数范围，结果为负无穷大，在javascript中以-infinity表示。无穷大值的行为特性和我们所期望的是一致的：基于它们的加、减、乘和除运算结果还是无穷大值（当然还保留它们的正负号）。

下溢（underflow）是当运算符结果无限接近于零并比javascript能表示的最小值还小的时候发生的一种情形。这种情况下，javascript将会返回0。当一个负数发生小溢时，javascript返回一个特殊的值“负零”。这个值（负零）几乎和正常的零完全一样，javascript程序员很少用到负零。

被零整除在javascript并不报错，它只是简单的返回无穷大（infinity）或负无穷大（-infinity）。但有一个例外，零除以零是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值，用NaN表示。无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作数一起使用时都将返回NaN。

javascript预定义了全局变量infinity和NaN，用来表示正无穷大和非数字值。在ECMAScript3中，这两个值是可读/写的，并可修改。ECMAScript5修正了这个错误，将它们定义为只读的。在ECMAScript3中Number对象定义的属性值也是只读的。这里有：
```javascript

Infinity //将一个可读/写的变量初始化为infinity
Number.POSITIVE_INFINITY //同样的值，只读
1/0 //这也是同样的值
Number.MAX_VALUE + 1 //就算结果还是Infinity
Number.NEGATIVE_INFINITY //该表达式表示了负无穷大
-Infinity
-1/0
-Number.MAX_VALUE - 1;
NaN //将一个可读/写的变量初始化为NaN
Number.NaN//同样的值，但是只读
0/0 计算结果是NaN
Number.MIN_VALUE/2 //发生下溢，计算结果为0
-Number.MIN_VALUE/2 //负零
-1/Infinity //同样是负零
-0
```
javascript中的非数字值有一点特殊：它和任何值都不相等，包括自身。也就是说，没办法通过x==NaN来判断变量x是否是NaN。相反，应当使用x!=x来判断，当且仅当x为NaN的时候，表达式的结果才为true。函数isNaN()的作用与此类似，如果参数是NaN或者是一个非数字值（比如字符串和对象），则返回true。javascript中有一个类似的函数isFinite()，在参数不是NaN、Infinity或-Infinity的时候返回true。

负零值同样有些特殊，它和正零值是相等的（甚至使用javascript的严格相等测试来判断）。这意味着这两个值几乎一模一样，除了作为除数之外：
```javascript
var zero = 0;//正常的零值
var negz = -0;//负零值
zero === negz;//=>true 正零值和负零值相等
1/zero === 1/negz;//=>false 正无穷大和负无穷大不等
```

**3.14二进制浮点数和四舍五入错误**

实数有无数个，但javascript通过浮点数的形式只能表示其中有限的个数（确切地说是18437736874454810627个）。也就是说，当在javascript中使用实数的时候，常常只是真实值的一个近似表示。

javascript采用了IEEE-754浮点数表示法（几乎所有现代编程语言所采用），这是一种二进制表示法，可以精确地表示分数，比如1/2、1/8和1/1024。遗憾的是，我们常用的分数（特别是在金融计算方面）都是十进制分数1/10、1/100等。二进制浮点数表示法并不能精确表示类似0.1这样简单的数字。

javascript中的数字具有足够的精度，并可以极其近似于0.1。但事实是，数字不能精确表述的确带来了一些问题。看下面这段代码：
```javascript
var x = .3 -.2;//30美分减去20美分
var y = .2 -.1;//20美分减去10美分
x == y //=>false 两值不相等
x == .1 //=>false .3 - .2 不等于.1
y == .1 //=>true .2 - .1 等于.1
```
由于舍入误差，0.3和0.2之间的近似差值实际上并不等于0.2和0.1之间近似的差值（在javascript的真实运行环境中，0.3-0.2=0.099 999 999 999 999 98。）。这个问题并不只在javascript中才会出现，理解这一点非常重要：在任何使用二进制浮点数的编程语言中都会出现这个问题。同样需要注意的是，上述代码中x和y的值非常接近彼此和最终的正确值。这种计算结果可以胜任大多数的计算任务：这个问题也只有在比较两个值是否相等的时候才出现。

javascript的未来版本或许会支持十进制数字类型以避免这些舍入问题。在这之前你可能更愿意使用大整数进行重要的金融计算。例如：要使用整数“分”而不要使用小数“元”进行基于货币单位的运算。

**3.1.5日期和时间**

javascript语言核心包括Date()构造函数，用来创建表示日期和时间的对象。这些日期对象的方法为日期计算提供了简单的API。日期对象不像数字那样是基本数据类型。本节给出了使用日期对象的一个简单教程。在第三部分可以查阅更多细节：
```javascript
var then = new Date(2011, 0, 1);//2011年1月1日
var later = new Date(2011, 0, 1, 17, 10, 30);//同一天，当地时间5:10:30pm
var now = new Date();//当前日期和时间
var elapsed = now - then;//日期减法 计算时间间隔的毫秒数
later.getFullYear() //=>2011
later.getMonth() //=>0 从0开始计数的月份
later.getDate() //=>1 从1开始计数的天数
later.getHours() //=>当地时间17：5pm
later.getUTCHours() //使用UTC表示小时的时间，基于时区
```

**3.2文本**

字符串（string）是一组由16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集。javascript通过字符串类型来表示文本。字符串的长度（length）是其所含16位值的个数。javascript字符串（和其数组）的索引从零开始：第一个字符的位置是0，第二个字符的位置是1，以此类推。空字符串（empty string）长度为0，javascript中并没有表示单个字符的“字符型”。要表示一个16位值，只需将其赋值给字符串变量即可，这个字符串长度为1。

字符集，内码和javascript字符串：
javascript采用UTF-16编码的Unicode字符集，javascript字符串是由一组无符号的16位值组成的序列。最常用的Unicode字符（这些字符属于“基于多语种平面”）都是通过16位的内码表示，并代表字符串中的单个字符，那些不能表示为16位的Unicode字符则遵循UTF-16编码规则——用两个16位值组成的一个序列（亦称做“代理项对”）表示。这意味着一个长度为2的javascript字符串（两个16位值）有可能表示一个Unicode字符：
```javascript
var p = "π";//π由16位内码表示0x03c0
var e = "e";//e由17位内码表示0x1d452
p.length //=>1 p包含一个16位值
e.length //=>2 e通过UTF-16编码后包含两个16位值："\ud835\udc52"
```
javascript定义的各式字符串操作方法均作用于16位值，而非字符，且不会对代理项对做单独处理，同样javascript不会对字符串做标准化的加工，甚至不能保证字符串是合法的UTF-16格式。


**3.2.1字符串直接量**

在javascript程序中的字符串直接量，是由单引号或双引号括起来的字符序列。由单引号定界的字符串中可以包含双引号，由双引号定界的字符串中也可以包含单引号。这里有几个字符串直接量的例子：
```javascript
""//空字符串，它包含0个字符
'testing'
"3.14"
'name="myform"'
"wouldn't you prefer O'Reilly's book?"
"this string\nhas two lines"
"π is the ratio of a circle's circumference to its diameter"
```
在ECMAScript3中，字符串直接量必须写在一行中，而在ECMAScript5中，字符串直接量可以拆分成数行，每行必须以反斜线（\）结束，反斜线和行结束符都不算是字符串直接量的内容。如果希望在字符串直接量中另起一行，可以使用转义字符\n（后续会有介绍）：
```javascript

"two\nlines"//这里定义了一个显示为两行的字符串
 //下面用三行代码定义了显示为单行的字符串，只在ECMAScript5中可用
"one\      
long\
line"
```
需要注意的是，当使用单引号来定界字符串时，需要格外小心英文中的缩写和所有格写法，比如can't和O'Reilly's。因为撇号和单引号是同一个字符，所以必须使用反斜杠（\）来转义（转义符将在下一章讲解）所有的撇号。

在客户端javascript程序设计中，javascript代码会夹杂HTML代码的字符串，HTML代码也会夹杂javascript代码。和javascript一样，HTML也使用单引号或者双引号来定界字符串，因此，当javascript代码和html代码混杂在一起的时候，最好在javascript和html代码中各自使用独立的引号风格。例如，在javascript表达式中使用单引号表示字符串“Thank you”，而在html事件处理程序属性中则使用双引号表示字符串：

    <button onclick="alert('Thank you')">Click Me</button>

**3.2.2转义字符**

在javascript字符串中，反斜杠(\)有着特殊的用途，反斜杠符号后面加一个字符，就不再表示它们的字面含义了，比如，\n就是一个转义字符（escape sequence），它表示的是一个换行符。escape sequence译为“转义序列”，有时也译成“转义字符”和“逃逸符”，本节中统一译为“转义字符”。

另一个例子是上节中提到的转义字符\'，表示单引号（或撇号）。当需要在一个单引号定界的字符串内使用撇号的时候，它就显得非常有用。现在你就会明白我们为什么把它们叫做转义字符了，因为反斜线可以使我们避免使用常规方式解释单引号，当单引号不是用来标记字符串结尾时，它只是一个撇号：
```javascript
'You\'re right, it can\'t be a quote'
```
表格3-1列出了javascript中的转义字符以及它们所代表的含义。其中有两个是通用的，通过十六进制数表示Latin-1或Unicode中的任意字码。例如，
\xA9表示版权符号，版权符号的Latin-1编码是十六进制数A9。同样，\u表示由4个十六进制数指定的任意Unicode字符，比如，\u03c0表示字符π。

表3-1 javascript转义字符

|转义字符|含义|
| -------- | ---- |
|\o|NUL字符（\u0000）|
|\b|退格符（\u0008）|
|\t|水平制表符（\u0009）|
|\n|换行符（\u000A）|
|\v|垂直制表符（\u000B）|
|\f|换页符（\u000C）|
|\r|回车符（\u000D）|
|\"|双引号（\u0022）|
|\'|撇号或单引号（\u0027）|
|\\|反斜线（\u005C）|
|\xXX|由两位十六进制数XX指定的Latin-1字符|
|\uXXXX|由4位十六进制数XXXX指定的Unicode字符|

如果”\“字符位于没有在表3-1中列出的字符前，则忽略”\“（当然，javascript语言将来的版本可能定义新的转义符）。比如”\#“和”#“等价。最后，上文提到过，在ECMAScript5中，允许在一个多行字符串直接量里的每行结束处使用反斜线。

**3.2.3字符串的使用**

javascript的内置功能之一就是字符串连接。如果将加号（+）运算符用于数字，表示两数相加。但将它作用于字符串，则表示字符串连接，将第二个字符串拼接在第一个之后，例如：
```javascript
msg = "Hello, " + "world";//生成字符串"Hello, world"
greeting = "Welcome to my blog," + " " + name;
```
要确定一个字符串长度——其所包含的16位值得个数——可以使用字符串的length属性。比如，要得到字符串s的长度：

    s.length
    
除了length属性，字符串还提供许多可以调用的方法（可以在第三部分查到详细信息）：
```javascript
var s = "hello, world" //定义一个字符串
s.charAt(0)//=>"h" 第一个字符
s.charAt(s.length - 1)//=>"d" 最后一个字符
s.substring(1,4)//=>"ell" 第2~4个字符
s.slice(1,4)//=>"ell" 同上
s.slice(-3)//=>"rld" 最后三个字符
s.indexOf("l")//=>2 字符l首次出现的位置
s.lastIndexOf("l")//=>10 字符l最后一次出现的位置
s.indexOf("l",3)//=>3 在位置3及之后首次出现字符l的位置
s.split(", ")//["hello", "world"]分割成子串
s.replace("h","H")//"Hello, world" 全文字符替换
s.toUpperCase()//"HELLO, WORLD" 
```
记住，在javascript中字符串是固定不变的，类似replace()和toUpperCase()的方法都返回新字符串，原字符串本身并没有发生改变。
在ECMAScript5中，字符串可以当做只读数组，除了使用charAt()方法，也可以使用方括号来访问字符串中的单个字符（16位值）：
```javascript
s = "hello, world";
s[0]//=>"h"
s[s.length -1] //=>"d"
```
基于Mozilla的web浏览器（比如Firefox）很久之前就支持这种方式的字符串索引，多数现代浏览器（IE除外）也紧跟Mozilla脚步，在ECMAScript5成型之前就支持了这一特性。

**3.2.4模式匹配**

javascript定义了RegExp()构造函数，用来创建表示文本匹配模式的对象。这些模式称为”正则表达式“（regular expression），javascript采用Perl中的正则表达式语法。String和RegExp对象均定义了利用正则表达式进行模式匹配和查找与替换的函数。、

RegExp并不是javascript的基本类型。和Date一样，它只是一种具有实用API的特殊对象。正则表达式的语法很复杂，API也很丰富。在第10章有详尽的文档介绍。RegExp是一种强大和常用的文本处理工具，本节只是一个概述。

尽管RegExp并不是语言中的基本数据类型，但是它们依然具有直接量写法，可以直接在javascript程序中使用。在两条斜线之间的文本构成了一个正则表达式直接量。第二条斜线之后也可以跟随一个或多个字母，用来修饰匹配模式的含义，例如：
```javascript
/^HTML/  //匹配以HTML开始的字符串
/[1-9][0-9]*/ //匹配一个非零数字，后面是任意个数字
/\bjavascript\b/  //匹配单词”javascript“，忽略大小写
```
RegExp对象定义了很多有用的方法，字符串同样具有可以接收RegExp参数的方法，例如：
```javascript
var text = "testing: 1, 2, 3";//文本示例
var pattern = /\d+g/  //匹配所有包含一个或多个数字的实例
pattern.test(text) //=>true 匹配成功
text.search(pattern) //=>9 首次匹配成功的位置
text.match(pattern) //=>["1", "2", "3"] 所有匹配组成的数组
text.replace(pattern, "#");//=> "testing: #, #, #"
text.split(/\D+/);//["","1","2","3"] 用非数字字符截取字符串
```

**3.3布尔值**

布尔值指代真或假、开或关、是或否。这个类型只有两个值，保留字true和false。
javascript程序中的比较语句的结果通常都是布尔值，例如：

    a==4
    
这段代码用来检测变量a的值是否等于4。如果等于，比较结果的布尔值就是true；如果不等，比较结果则为false。
布尔值通常用于javascript中的控制结构中。例如，javascript中的if／else语句，如果布尔值为true执行第一段逻辑，如果为false执行另一段逻辑。通常将一个创建布尔值的比较直接与使用这个比较的语句结合在一起，结果如下所示：

    if (a==4)
    b = b + 1;
    else
    a = a + 1;
    
这段代码检测变量a是否等于4，如果等于，则b加1，否则，a加1。我们同样会在3.8节讨论到，任意javascript的值都可以转换为布尔值。下面这些值会被转换成false：

    undefined
    null
    0
    -0
    NaN
    ""//空字符串
    
所有其他值，包括所有对象（数组）都会转换成true。false和上面6个可以转换成false的值有时称做“假值”（falsy value），其他值称做“真值”（truthy value）。
javascript期望使用一个布尔值的时候，假值会被当成false，真值会被当成true。

来看一个例子，假设变量o是一个对象或是null，可以通过一条if语句来显式地检测o是否是非null值：

    if (o !== null)

不等操作符“!==”将o和null比较，并得出结果为true或false。可以先忽略这里的比较语句，null是一个假值，对象是一个真值：

    if (o)
    
对于第一种情况，只有o不是null时才会执行if后的代码，第二种情况的限制没那么严格，只有o不是false或任何假值（比如null或undefined）时它才会执行这个if。到底选用哪条语句取决于期望赋给o的值是什么。如果需要将null与o或""区分开来，则需要使用一个显式的比较。

布尔值包含toString()方法，因此可以使用这个方法将字符串转换为“true”或“false”，但它并不包含其他有用的方法。除了这个不重要的API，还有三个重要的布尔运算符。

“&&”运算符执行了逻辑与（AND）操作。当且仅当两个操作数都是真值时它才返回true；否则返回false。“||”运算符是布尔或（OR）操作，如果两个操作数其中一个为真值它就返回true，如果两个操作数都是假值则返回false，最后，一元操作符“!”执行了布尔非（NOT）操作，如果操作数是真值则返回false，如果是假值，则返回true。
比如：

    if((x==0&&y==0)||!(z==0)){
        //x和y都是零或z是非零
    }

关于操作数的完整细节可以参照4.10节。
    
**3.4null和undefined**

null是javascript语言的关键字，它表示一个特殊值，常用来描述"空值"。对null执行typeof预算，结果返回字符串"object"，也就是说，可以将null认为是一个特殊的对象值，含义是”非对象“。但实际上，通常认为null是它自由类型的唯一一个成员，它可以表示数字、字符串和对象是”无值“的。大多数编程语言和javascript一样含有null；你可能对null和nil很眼熟。

javascript还有第二个值来表示值的空缺。用未定义的值表示更深层次的"空值"。它是变量的一种取值，表明变量没有初始化，如果要查询对象属性或数组元素的值时返回undefined则说明这个属性或元素不存在。如果函数没有返回任何值，则返回undefined。引用没有提供实参的函数的形参的值也只会得到undefined。undefined是预定义的全局变量（它和null不一样，它不是关键字），它的值就是“未定义”。在ECMAScript3中，undefined是可读/写的变量，可以给它赋予任意值。这个错误在ECMAScript5中做了修正；undefined在该版本中是只读的。如果使用typeof运算符得到undefined的类型，则返回“undefined”，表明这个值是这个类型的唯一成员。

尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换。判断相等运算符“==”认为两者是相等的（要使用严格相等运算符“===”来区分它们）。在希望值是布尔类型的地方它们的值都是假值，和false类似。null和undefined都不包含任何属性和方法。实际上，使用“.”和“[]”来存取这两个值的成员和方法都会产生一个类型错误。

你或许认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。如果你想将它们赋值给变量或者属性，或将它们作为参数传入函数，最佳选择是使用null。

**3.5全局对象**

前几节我们讨论了javascript的原始类型和原始值。对象类型——对象、数组和函数——在本书中均会有独立章节来讲述。但有一类非常重要的对象，我们不得不现在就把它们讲清楚——全局对象。
全局对象（global object）在javascript中有着重要的用途：全局对象的属性是全局定义的符号，javascript程序可以直接使用。当javascript解释器启动时（或者任何web浏览器加载新页面的时候），它将创建一个新的全局对象，并给它一组定义的初始属性：

* 全局属性，比如undefined、Infinity和NaN
* 全局函数，比如isNaN()、parseInt()（见3.8.2节）和eval()（见4.12节）
* 构造函数，比如Date()、RegExp()、String()、Object()和Array()（见3.8.2节）
* 全局对象，比如Math和JSON（见6.9节）

全局对象的初始属性并不是保留字，但它们应该当做保留字来对待。2.4.1节列出了所有这些属性。本章对一部分全局属性也有描述。其他属性在其他章节也会讲述。可以在第三部分中通过名称查找到，或者通过别名“Global”来找到这些全局对象。对于客户端javascript来讲，window对象定义了一些额外的全局属性，可以在第四部分中查看它们。

在代码的最顶级——不在任何函数内的javascript代码——可以使用javascript关键字this来引用全局对象：

    var global = this;//定义一个引用全局对象的全局变量

在客户端javascript中，在其表示的浏览器窗口中的所有javascript代码中，window对象充当了全局对象。这个全局window对象有一个属性window引用其自身，它可以代替this来引用全局对象。window对象定义了核心全局属性，但它也针对web浏览器和客户端javascript定义了一少部分其他全局属性。
当初次创建的时候，全局对象定义了javascript中所有的预定义全局值。这个特殊对象同样包含了为程序定义的全局值。如果代码声明了一个全局变量，这个全局变量就是全局对象的一个属性，3.10.2节有关于此的详尽解释。

**3.6包装对象**

javascript对象是一种复合值：它是属性或已命名值的集合。通过“.”符号来引用属性值。当属性值是一个函数的时候，称其为方法。通过o.m()来调用对象o中的方法。

我们看到字符串也同样具有属性和方法：
```javascript
var s = "hello world!";//一个字符串
var word = s.substring(s.indexOf(" ")+1, s.length);//使用字符串的属性
```
字符串既然不是对象，为什么它会有属性呢？只要引用了字符串s的属性。javascript就会将字符串值通过调用new String(s)的方式转换成对象，这个对象继承了字符串的方法（见6.2.2节），并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁（其实在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样）。
同字符串一样，数字和布尔值也具有各自的方法：通过NUmber()和Boolean()构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。null和undefined没有包装对象：访问它们的属性会造成一个类型错误。

看如下代码，思考它们的执行结果：
```javascript
var s = "test";//创建一个字符串
s.len = 4;//给它设置一个属性
var t = s.len;//查询这个属性
```
当运行这段代码时，t的值是undefined。第二行代码创建一个临时字符串对象，并给其len属性赋值4，随即销毁这个对象。第三行通过原始的（没有修改过）字符串值创建一个新字符串对象，尝试读取其len属性，这个属性自然是不存在的，表达式求值结果为undefined。这段代码说明了在读取字符串、数字和布尔值的属性值（或方法）的时候，表现的像对象一样。但如果你试图给其属性赋值，则会忽略这个操作：修改只是发生在临时对象身上，而这个临时对象并未继续保留下来。

存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。通常，包装对象只是被看做是一种实现细节，而不用特别关注。由于字符串、数字和布尔值的属性都是只读的，并且不能给它们定义新属性，因此你需要明白它们是有别于对象。
lei
需要注意的是，可通过String()、Number()或Boolean()构造函数来显式创建包装对象：
```javascript
var s = "test",n = 1,b = true;//一个字符串、数字和布尔值
var S = new String(s);//一个字符串对象
var N = new Number(n);//一个数值对象
var B = new Boolean(b);//一个布尔对象
```
javascript会在必要时将将包装对象转换为原始值，因此上段代码中的对象S、N和B常常但不总是表现的和s、n和b一样。“==”等于运算符将原始值和其包装对象视为相等，但“===”全等运算符将它们视为不等。通过typeof运算符可以看到原始值和其包装对象的不同。

**3.7不可变的原始值和可变的对象引用**

javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本的区别。原始值是不可更改的，任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此——改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来就像是由字符组成的数组，我们期望可以通过指定索引来修改字符串中的字符。实际上，javascript是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。例如：
```javascript
var s = "hello";//定义一个由小写字母组成的文本
s.toUpperCase();//返回“HELLO”，但并没有改变s的值
s               //=> hello，原始字符串的值并未改变
```
原始值的比较是值的比较：只有在它们的值相等时它们才相等。这对数字、布尔值、null和undefined来说听起来有点难懂，并没有其他办法来比较它们。同样，对于字符串来说则并不明显：如果比较两个单独的字符串，当且仅当它们的长度相等且每个索引的字符都相等时，javascript才认为它们相等。

对象和原始值不同，首先，它们是可变的——它们的值是可修改的：
```javascript
var o = {x:1};//定义一个对象
o.x = 2;//通过修改对象属性值来更改对象
o.y = 3;//再次更改这个对象，给它增加一个新属性
var a = [1,2,3]//数组也是可修改的
a[0] = 0;//更改数组的一个元素
a[3] = 4;//给数组增加一个新元素
```
对象的比较并非值的比较，即使两个对象包含同样的属性及相同的值，它们也是不相等的。各个索引元素完全相等的两个数组也不相等。
```javascript
var o = {x:1},p = {x:1}//具有相同属性的两个对象
o===p//=>false 两个单独的对象永不相等
var a = [],b = [];//两个单独的空数组
a===b//=>false 两个单独的数组永不相等
```
我们通常将对象称为引用类型（reference type），以此来和javascript的基本类型区分开来。依照术语的叫法，对象值都是引用（reference）。对象的比较均是引用的比较，当且仅当它们引用同一个基对象时，它们才相等。
```javascript
var a = [];//定义一个引用空数组的变量s
var b = a;//变量b引用同一个数组
b[0] = 1;//通过变量b来修改引用的数组
a[0]//=>1 变量a也会修改
a===b//=>true a和b引用同一个数组，因此它们相等
```
就像你们看到的如上代码，将对象（或数组）赋值给一个变量，仅仅是赋值的引用值，对象本身并没有复制一次，如果你想得到一个对象或数组的副本，则必须显式复制对象的每个属性或数组的每个元素。下面这个例子则是通过循环来完成数组复制（见5.5.3节）。
```javascript
var a = ['a','b','c'];//待复制的数组
var b = [];//复制到的目标空数组
for(var i=0; i<a.length; i++){//遍历a[]中的每个元素
    b[i] = a[i];//将元素值复制到b中
}
```
同样的，如果我们想比较两个单独的对象或者数组，则必须比较它们的属性或元素。下面这段代码定义了一个比较两个数组的函数；
```javascript
function equalArrays(a,b){
    if(a.length != b.length) return false;//两个长度不同的数组不相等
    for(var i=0; i<a.length; i++){//循环遍历所有元素
        if (a[i] !== b[i]) return false;//如果有任意元素不等，则数组不相等
        return true;//否则它们相等
    }
}
```
**3.8类型转换**

javascript中的取值类型非常灵活，我们已经从布尔值看到了这一点：当javascript期望使用一个布尔值的时候，你可以提供任意类型值，javascript将根据需要自行转换类型。一些值（真值）转换为true，其他值（假值）转换为false。这在其他类型中同样适用：如果javascript期望使用一个字符串，它把给定的值将转换为字符串。如果javascript期望使用一个数字，它把给定的值将转换为数字（如果转换结果无意义的话将返回NaN），一些例子如下：
```javascript
10 + " objects"//=>"10 objects"，数字10转换成字符串
"7" * "4" //=> 28 两个字符串均转换为数字
var n = 1 - "x";//=>NaN 字符“x”无法转换为数字
n + " objects"//“NaN objects” NaN转换为字符串“NaN”
```
表3-2简要说明了在javascript中如何进行类型转换。

表3-2：javascript类型转换

|原始值|字符串|数字|布尔值|对象|
|:-----:|:--------:|:-------:|:-----:|:------:|
|undefined|"undefined"|NaN|false|throws TypeError|
|null|"null"|0|false|throws TypeError|
|true|"true"|1|true|new Boolean(true)|
|false|"false"|0|false|new Boolean(false)|
|""(空字符串)|"" |0|false|new String("")|
|"1.2"(非空，数字)|"1.2" |1.2|true|new String("1.2")|
|"one"(非空，非数字)|"one" |NaN|true|new String("one")|
|0|"0" |0|false|new Number(0)|
|-0|"0" |-0|false|new Number(-0)|
|NaN|"NaN"|NaN|false|new Number(NaN)|
|Infinity|"Infinity"|Infinity|true|new Number(Infinity)|
|-Infinity|"-Infinity"|Infinity|true|new Number(-Infinity)|
|1（无穷大，非零）|"1"|1|true|new Number(1)|
|{}（任意对象）|参考3.8.3节|参考3.8.3节|true|{}|
|[]（任意数组）|""|0|true|[]|
|[9]（1个数字元素）|"9"|9|true|[9]|
|['a']（其他数组）|使用join()方法|NaN|true|['a']|
|function(){}（任意函数）|参考3.8.3节|NaN|true|function(){}|

表3-2节中提到的原始值到原始值的转换相对简单，我们已经在3.3节讨论过转换为布尔值的情况了。
所有原始值转换为字符串的情形也已经明确定义。转换为数字的情形比较微妙。那些以数字表示的字符串可以直接转换为数字，也允许在开始和结尾处带有空格。但在开始和结尾处的任意非空格字符都不会被当成数字直接量的一部分，进而造成字符串转换为数字的结果为NaN。有一些数字转换看起来让人奇怪：true转换为1，false、空字符串和""转换为0。

原始值到对象的转换也非常简单，原始值通过调用String()、Number()或Boolean()构造函数，转换为它们各自的包装对象（见3.6节）。

null和undefined属于例外，当将它们用在期望是一个对象的地方都会造成一个类型错误（TypeError）异常，而不会执行正常的转换。

对象到原始值的转换多少有些复杂，3.8.3节将以此为专题专门讲述。

**3.8.1转换和相等性**

由于javascript可以做灵活的类型转换，因此其“==”相等运算符也随相等的含义灵活多变。例如，如下这些比较结果均是true：
```javascript
null == undefined//这两值被认为相等
"0" == 0//在比较之前字符串转换为数字
0 == false//在比较之前布尔值转换为数字
"0" == false//在比较之前字符串和布尔值都转换为数字
```
4.9.1节详细讲解了“==”等于运算符在判断两个值是否相等时做了哪些类型转换，并同样介绍了“===”恒等运算符在判断相等时未做任何类型转换。

需要特别注意的是，一个值转换为另一个值并不意味着两个值相等。比如，如果在期望使用布尔值的地方使用了undefined，它将会转换为false，但这并不表明undefined == false。javascript运算符和语句期望使用多样化的数据类型，并可以相互转换。if语句将undefined转换为false，但“==”运算符从不试图将其操作数转换为布尔值。

**3.8.2显式类型转换**

尽管javascript可以自动做许多类型转换，但有时仍需要做显式转换，或者为了代码变得清晰易读而做显式转换。

做显式类型转换最简单的方法就是使用Boolean()、Number()、String()或Object()函数。
我们在3.6节已经介绍过了。当不通过new运算符调用这些函数时，它们会作为类型转换函数并按照表3-2所描述的规则做类型转换：
```javascript
Number("3")//=>3
String(false)//=>"false"或使用false.toString()
Boolean([])//=>true
Object(3)//=> new Number(3)
```
需要注意的是，除了null或undefined之外的任何值都具有toString()方法，这个方法的执行结果通常和String()方法的返回结果一致。
同样需要注意的是，如果试图把null或undefined转换为对象，则会像表3-2所描述的那样抛出一个类型错误（TypeError）。
Object()函数在这种情况下不会抛出异常：它仅简单地返回一个新创建的空对象。

javascript中的某些运算符会做隐式的类型转换，有时用于类型转换。如果“+”运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元“+”运算符将其操作数转换为数字。同样，一元“!”运算符将其操作数转换为布尔值并取反。在代码中会经常见到这种类型转换的惯用法：
```javascript
x + "" //等价于String(x)
+x //等价于Number(x) 也可以写成x-0
!!x //等价于Boolean(x)，注意是双叹号
```
在计算机程序中数字的解析和格式化是非常普通的工作，javascript中提供了专门的函数和方法用来做更加精确的数字到字符串（number-to-string）和字符串到数字（string-to-number）的转换。

Number类定义的toString()方法可以接收表示转换基数（radix）的可选参数，如果不指定此参数，转换规则将是基于十进制的。同样，亦可以将数字转换为其他进制数（范围在2~36之间），例如：
```javascript
var n = 17;
binary_string = n.toString(2);//转换为“10001”
octal_string = "0" + n.toString(8);//转换为“021”
hex_string = "0x" + n.toString(16);//转换为“0x11”
```
当处理财务或科学数据的时候，在做数字到字符串的转换过程中，你期望自己控制输出中小数点位置和有效数字位数，或者决定是否需要指数记数法。Number类为这种数字到字符串的类型转换场景定义了三个方法。toExponential()使用指数记数法将数字转换为指数形式的字符串，其中小数点前只有一位，小数点后的位数则由参数指定（也就是说有效数字位数比指定的位数要多一位），toPrecision()根据指定的有效数字位数将数字转换为字符串。如果有效数字的位数少于数字整数部分的位数，则转换成指数形式。我们注意到，所有三个方法都会适当地进行四舍五入或填充0。看一下下面几个例子：
```javascript
var n = 123456.789;
n.toFixed(0);//"123457"
n.toFixed(2);//"123456.79"
n.toFixed(5);//"123456.78900"
n.toExponential(1);//"1.2e+5"
n.toExponential(3);//"1.235e+5"
n.toPrecision(4);//"1.235e+5"
n.toPrecision(7);//"123456.8"
n.toPrecision(10);//"123456.7890"
```
如果通过Number()转换函数传入一个字符串，它会试图将其转换为一个整数或浮点数直接量，这个方法只能基于十进制数进行转换，并且不能出现非法的尾随字符。parseInt()函数和parseFloat()函数（它们是全局函数，不从属于任何类的方法）更加灵活。parseInt()只解析整数，而parseFloat()则可以解析整数和浮点数。如果字符串前缀是“0x”或者“0X”，parseInt()将其解释为十六进制数，parseInt()和parseFloat()都会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回NaN：
```javascript
parseInt("3 blind mice")//=>3
parseFloat(" 3.14 meters");//=>3.14
parseInt("-12.34");//=>-12
parseInt("0xFF");//=>255
parseInt("0xff");//=>255
parseInt("-0xFF");//=>-255
parseFloat(".1");//=>0.1
parseInt("0.1");//=>0
parseInt(".1");//=>NaN 整数不能以“.”开始
parseInt("$72.47");//=>NaN 数字不能以“$”开始
```
parseInt()可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2~36，例如：
```javascript
parseInt("11",2);//=>3 (1*2+1)
parseInt("ff",16);//=>255 (15*16 + 15)
parseInt("zz",36);//=>1295 (35*36 + 35)
parseInt("077",8);//=>63 (7*8 + 7)
parseInt("077",10);//=>63 (7*10 + 7)
```

**3.8.3对象转换为原始值**
对象到布尔值的转换非常简单：所有的对象（包括数组和函数）都转换为true。对于包装对象亦是如此：new Boolean(false)是一个对象而不是原始值，它将转换为true。

对象到字符串（object-to-string）和对象到数字（object-to-number）的转换是通过调用待转换对象的一个方法来完成的。一个麻烦的事实是，javascript对象有两个不同的方法来执行转换，并且接下来要讨论的一些特殊场景更加复杂。值得注意的是，这里提到的字符串和数字的转换规则只适用于本地对象（native object）。宿主对象（例如，由web浏览器定义的对象）根据各自的算法可以转换成字符串和数字。

所有的对象继承了两个转换方法。第一个是toString(),它的作用是返回一个反映这个对象的字符串。默认的toString()方法并不会返回一个有趣的值（在例6-4中我们会发现它非常有用）：

    ({x:1, y:2}).toString() // => "[object object]"

很多类定义了更多特定版本的toString()方法。例如，数组类(Array class)的toString()方法将每个数组元素转换为一个字符串，并在元素之间添加逗号后合并成结果字符串。
函数类（functtion class）的toString()方法返回这个函数的实现定义的表示方式。实际上，这里的实现方式是通常是将用户定义的函数转换为javascript源代码字符串。日期类（Date class）定义的toString()方法返回了一个可读的（可被javascript解析的，这里的原文是javascript-parsable，意指可以通过javascript的方法过滤并再做封装）日期和时间字符串。
RegExp类（RegExp class）定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串：
```javascript
[1,2,3].toString() //=>"1,2,3"
(function(x){f(x);}).toString()//=>"function(x){\n f(x); \n}"
/\d+/g.toString() // => "/\\d+/g"
new Date(2010,0,1).toString()//=> "Fri Jan 01 2010 00:00:00 GMT-0800(PST)"
```
另一个转换对象的函数是valueOf()。这个方法的任务并未详细定义：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valueOf()方法只是简单返回对象本身。日期类定义的valueOf()方法会返回它的一个内部表示：1970年1月1日依来的毫秒数。
```javascript
var d = new Date(2010,0,1);//2010年1月1日（太平洋时间）
d.valueOf() //=> 1262332800000
```
通过使用我们刚刚讲解过的toString()和valueOf()方法，就可以做到对象到字符串和对象到数字的转换了。但需要注意的是，在某些特殊的场景中，javascript执行了完全不同的对象到原始值的转换。这些特殊场景在本节的最后会讲到。
javascript中对象到字符串的转换经过了如下这些步骤：

* 如果对象具有toString()方法，则调用这个方法。如果它返回一个原始值，javascript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。需要注意的是，原始值到字符串的转换在表3-2中已经有了详尽的说明。
* 如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么javascript会调用valueOf()方法。如果存在这个方法，则javascript调用它。如果返回值是原始值，javascript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。
* 否则，javascript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常。

在对象到数字的转换过程中，javascript做了同样的事情，只是它会首先尝试使用valueOf()方法：

* 如果对象具有valueOf()方法，后者返回一个原始值，则javascript将这个原始值转换为数字（如果需要的话）并返回这个数字。
* 否则，如果对象具有toString()方法，后者返回一个原始值，则javascript将其转换并返回。
* 否则，javascript抛出一个类型错误异常。

对象转换为数字的细节解释了为什么空数组会被转换为数字0以及为什么具有单个元素的数组同样会转换成一个数字。数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用toString()方法。空数组转换为空字符串，空字符串转换成为数字0。含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样。如果数组只包含一个数字元素，这个数字转换为字符串，再转换回数字。

javascript中的“+”运算符可以进行数学加法和字符串连接操作。如果它的其中一个操作数是对象，则javascript将使用特殊的方法将对象转换为原始值，而不是使用其他算术运算符的方法执行对象到数字的转换，“==”相等运算符与此类似。如果将对象和一个原始值比较，则转换将会遵照对象到原始值的转换方式进行。

“+”和“==”应用的对象到原始值的转换包含日期对象的一种特殊情形。日期类是javascript语言核心中唯一的预先定义类型，它定义了有意义的向字符串和数字类型的转换。对于所有非日期的对象来说，对象到原始值的转换基本上是对象到数字的转换（首先调用valueOF()），日期对象则使用对象到字符串的转换模式，然而，这里的转换和上文讲述的并不完全一致：通过valueOf或toString()返回的原始值将被直接使用，而不会被强制转换为数字或字符串。

和“==”一样，“<”运算符以及其他关系运算符也会做对象到原始值的转换，但要除去日期对象的特殊情形：任何对象都会首先尝试调用valueOf()，然后调用toString()。不管得到的原始值是否直接使用，它都不会进一步被转换为数字或字符串。

“+”、“==”、“!=”和关系运算符是唯一执行这种特殊的字符串到原始值的转换方式的运算符。其他运算符到特定类型的转换都很明确，而且对日期对象来讲也没有特殊情况。例如“-”减号运算符把它的两个操作数都转换为数字。下面的代码展示了日期对象和“+”、“-”、“==”以及“>”的运行结果：
```javascript
var now = new Date();//创建一个日期对象
typeof (now + 1)//=>"string"  "+"将日期转换为字符串
typeof (now - 1)//=> "number" "-"使用对象到数字的转换
now == now.toString() //=>true 隐式的和显式的字符串转换
now > (now - 1)//=>true ">"将日期转换为数字
```
**3.9变量声明**

在javascript程序中，使用一个变量之前应当先声明。变量是使用关键字var来声明的，如下所示：
```javascript
var i;
var sum;
```
也可以通过一个var关键字来声明多个变量：
```javascript
var i,sum;
```
而且还可以将变量的初始赋值和变量声明合写在一起：
```javascript
var message = "hello";
var i = 0, j = 0, k = 0;
```

我们未在var声明语句中给变量指定初始值，那么虽然声明了这个变量，但在给它存入一个值之前，它的初始值就是undefined。

我们注意到，在for和for/in循环（在第5章会讲到）中同样可以使用var语句，这样可以更简洁地声明在循环体语法内中使用的循环变量。例如：
```javascript
for(var i = 0; i < 10; i++) console.log(i);
for(var i = 0, j = 10; i<10; i++,j--) console.log(i*j);
for(var p in o) console.log(p);
```
如果你之前编写过诸如c或java的静态语言，你会注意到在javascript的变量声明中并没有指定变量的数据类型。javascript变量可以是任意数据类型。例如，在javascript中首先将数字赋值给一个变量，随后再将字符串赋值给这个变量，这是完全合法的：
```javascript
var i = 10;
i = "ten";
```
重复的声明和遗漏的声明：
使用var语句重复声明变量是合法且无害的。如果重复声明带有初始化器，那么这就和一条简单的赋值语句没什么两样。
如果你试图读取一个没有声明的变量的值，javascript会报错。在ECMAScript5严格模式（见5.7.3节）中，给一个没有声明的变量赋值也会报错。然而从历史上讲，在非严格模式下，如果给一个未声明的变量赋值，javascript实际上会给全局对象创建一个同名属性，并且它工作起来像（但并不完全一样，查看3.10.2节）一个正确声明的全局变量。这意味着你可以侥幸不声明全局变量。但这是一个不好的习惯并会造成很多bug，因此，你应当始终使用var来声明变量。

**3.10变量作用域**

一个变量的作用域（scope）是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在javascript代码中的任何地方都是有定义的。
然而在函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，它们只在函数体内有定义。
在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。

```javascript
var scope = "global";   //声明一个全局变量
function checkscope() {
    var scope = "local";//声明一个同名的局部变量
    return scope;       //返回局部变量的值，而不是全局变量的值
}
checkscope();           //=>"local"
```
尽管在全局作用域编写代码时可以不写var语句，但声明局部变量时则必须使用var语句。思考一下如果不这样做会怎样：

```javascript
scope = "global";           //声明一个全局变量，甚至不用var来声明
function checkscope2() {    
    scope = "local";        //糟糕！我们刚刚修改了全局变量
    myscope = "local";      //这里显式地声明了一个新的全局变量
    return [scope,myscope]; //返回两个值
}
checkscope2();//=>["local","local"]，产生了副作用
scope//=>"local"，全局变量修改了
myscope//=>"local"，全局命名空间搞乱了
```
函数定义是可以嵌套的。由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况，例如：

```javascript
var scope = "global scope";//全局变量
    function checkscope() {
        var scope = "local scope";//局部变量
        function nested() {
            var scope = "nested scope";//nested(嵌套)，嵌套作用域内的局部变量
            return scope;//返回当前作用域内的值
        }
        return nested();
    }
checkscope(); //"nested scope"，嵌套作用域
```

**3.10.1函数作用域和声明前提**

在一些类似c语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而javascript中没有块级作用域。
javascript取而代之地使用了函数作用域（function scope），变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

在如下所示的代码中，在不同位置定义了变量i、j和k，它们都在同一个作用域内——这三个变量在函数体内均是有定义的。

```javascript
function test(o){
    var i = 0;                      //i在整个函数体内均是有定义的
    if(typeof o == "object") {
        var j = 0;                  //j在函数体内是有定义的，不仅仅是在这个代码段内
        for (var k=0; k < 10; k++){ //k在函数体内是有定义的，不仅仅是在循环里
            console.log(k);         //输出数字0～9
        }
        console.log(k);             //k已经定义了，输出10
    }           
    console.log(j);                 //j已经定义了，但可能没有初始化
}
```
javascript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。javascript的这个特性被非正式地称为声明前提（hoisting），即javascript函数里声明的所有变量（但不涉及赋值）都被提前至函数体的顶部，看一下如下代码：

```javascript
var scope = "global";
function f() {
    console.log(scope);//输出"undefined"，而不是"global"
    var scope = "local";//变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的
    console.log(scope);//输出"local"
}
```
你可能会误以为函数中的第一行会输出“global”，因为代码还没有执行到var语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到var语句的时候，局部变量才会被真正赋值。因此，上述过程等价于：将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：

```javascript
function f() {
    var scope;//在函数顶部声明了局部变量
    console.log(scope);//变量存在，但其值是"undefined"
    scope = "local";//这里将其初始化并赋值
    console.log(scope);//这里它具有了我们所期望的值
}
```
在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的编程习惯。由于javascript没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近在使用变量之处。这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。

“声明提前”这步操作是在javascript引擎的“预编译”时进行的，是在代码开始运行之前，更多细节请阅读相关ppt：www.slideshare.net/lijing00333/javascript-engine。

**3.10.2作为属性的变量**

当声明一个javascript全局变量时，实际上是定义了全局对象的一个属性（3.5节）。当使用var声明一个变量时，创建的这个属性是不可配置的（见6.7节），也就是说这个变量无法通过delete运算符删除。可能你已经注意到了，如果你没有使用严格模式并给一个未声明的变量赋值的话，javascript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们。

```javascript
var truevar = 1;//声明一个不可删除的全局变量
fakevar = 2;//创建全局对象的一个可删除的属性
this.fakevar2 = 3;//同上
delete truevar //=>false 变量并没有被删除
delete fakevar //=>true 变量被删除
delete this.fakevar2 //=>true 变量被删除
```

javascript全局变量是全局对象的属性，这是在ECMAScript规范中强制规定的。对于局部变量则没有如此规定，但我们可以想象得到，局部变量当做跟函数调用相关的某个对象的属性。ECMAScript3规范称该对象为“调用对象”（call object），ECMAScript5规范称“声明上下文对象”（declarative environment record）。javascript可以允许使用this关键字来引用全局对象，却没有方法可以引用局部变量中存放的对象。这种存放局部变量的对象的特有性质，是一种对我们不可见的内部实现。然而，这些局部变量对象存在的观念是非常重要的。我们会在下一节展开讲述。

**3.10.3作用域链**
javascript是基于词法作用域的语言：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。全局变量在程序中始终都是有定义的。局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。

如果将一个局部变量看做是自定义实现的对象的属性的话，那么可以换个角度来解读变量作用域。每一段javascript代码（全局代码或函数）都有一个与之关联的作用域链（scope chain）。
这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当javascript需要查找变量x的值的时候（这个过程称做“变量解析”（variable resolution）），它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，javascript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError）异常。

在javascript的最顶层代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解对象链的创建规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。

作用域链的概念对于理解with语句（见5.7.1节）是非常有帮助的，同样对理解闭包（见8.6节）的概念也至关重要。


表达式和运算符
--------------

表达式（expression）javascript中的一个短语，javascript解释器会将其计算（evaluate）出一个结果。程序中的常量是最简单的一类表达式。变量名也是一种简单的表达式，它的值就是赋值给变量的值。复杂表达式是由简单表达式组成的。比如，数组访问表达式是由一个表示数组的表达式、左方括号、一个整数表达式和右方括号构成。它们所组成的新的表达式的运算结果是该数组的特定位置的元素值。同样的，函数调用表达式由一个表示函数对象的表达式和0个或多个参数表达式构成。

将简单表达式组合成复杂表达式最常用的方法就是使用运算符（operator）。运算符按照特定的运算规则对操作数（通常是两个）进行运算，并计算出新值。乘法运算符“*”是比较简单的例子。表达式x＊y是对两个变量表达式x和进行运算并得出结果。有时我们更愿意说运算符返回一个值而不是“计算”出一个值。

本章将讲解所有的javascript运算符，同时也讲解不涉及运算符的表达式（比如访问数组元素和函数调用）。如果你熟悉C语法风格的其他编程语言，你会发现大多数javascript表达式和运算符都似曾相识。

**4.1原始表达式**

最简单的表达式是“原始表达式”（primary expression）。
原始表达式是表达式的最小单位——它们不再包含其他表达式。javascript中的原始表达式包含常量或直接量、关键字和变量。
直接量是直接在程序中出现的常数值。它们看起来像：

    1.23       //数字直接量
    "hello"    //字符串直接量
    /pattern/  //正则表达式直接量

javascript数字直接量的语法在3.1节已经做了讲解。字符串直接量在3.2节做了讲解。正则表达式直接量语法在3.2.4节做了简单介绍，在第10章将做专门讲解。
javascript中的一些保留字构成了原始表达式：

    true//返回一个布尔值，真
    false//返回一个布尔值，假
    null//返回一个值，空
    this//返回“当前”对象

我们在3.3节和3.4节中学习了true、false和null。和其他关键字不同，this并不是一个常量，它在程序的不同地方返回的值也不相同。this关键字经常在面向对象编程中出现。在一个方法体内，this返回调用这个方法的对象。参照4.5节、第8章（8.2.2节）和第9章来获取关于this的详细信息。

最后，第三种原始表达式是变量：

    i//返回变量i的值
    sum//返回sum的值
    undefined//undefined是全局变量，和null不同，它不是一个关键字
    
当javascript代码中出现标志符，javascript会将其当做变量而去查找它的值。如果变量名不存在，表达式运算结果为undefined。然而，在ECMAScript5的严格模式中，对不存在的变量进行求值会抛出一个引用错误异常。    

**4.2对象和数组的初始化表达式**
**4.3函数定义表达式**
**4.4属性访问表达式**
**4.5调用表达式**
**4.6对象创建表达式**
对象创建表达式（object creation expression）创建一个对象并调用一个函数（这个函数称为构造函数）初始化新对象的属性。对象创建表达式和函数调用表达式非常类似，只是对象创建表达式之前多了一个关键字new：
```javascript
new Object()
new Point(2,3)
```
如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么这对空圆括号是可以省略掉的：
```javascript
new Object
new Date
```
当计算一个对象创建表达式的值时，和对象初始化表达式通过{}创建对象的做法一样，javascript首先创建一个新的空对象，然后，javascript通过传入指定的参数并将这个新对象当做this的值来调用一个指定的函数。这个函数可以使用this来初始化这个新创建对象的属性。那些被当做构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果一个构造函数确实返回了一个对象值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了。

**4.7运算符概述**
**4.8算术表达式**
**4.9关系表达式**

本节介绍javascript的关系运算符。关系运算符用于测试两个值之间的关系（比如“相等”，“小于”，或“是……的属性”），根据关系是否存在返回true或false。关系表达式总是返回一个布尔值，通常if、while或者for语句（参照第5章）中使用关系表达式，用以控制程序的执行流程。接下来的几节将会讲述相等和不等运算符、比较运算符和javascript中其他两个关系运算符in和instanceof。

**4.9.1相等和不等运算符**

“==”和“===”运算符用于比较两个值是否相等，当然它们对相等的定义不尽相同。两个运算符允许任意类型的操作数，如果操作数相等则放回true，否则返回false。“===”也称为严格相等运算符（strict equality）（有时也称做恒等运算符（identity operator）），它用来检测两个操作数是否严格相等。“==”运算符称做相等运算符（equality operator），它用来检测两个操作数是否相等，这里“相等”的定义非常宽松，可以允许进行类型转换。

javascript支持“=”、“==”和“===”运算符。你应当理解这些（赋值、相等、恒等）运算符之间的区别，并在编码过程中小心使用，尽管它们都可以称做“相等”，但为了减少概念混淆，应该把“=”称做“得到或赋值”，把“==”称做“相等”，把“===”称做严格相等。

“!=”和“!==”运算符的检测规则是“==”和“===”运算符的求反。如果两个值通过“==”的比较结果为true，那么通过“!=”的比较结果则为false。如果两值通过“===”的比较结果为true，那么通过“!==”的比较结果则为false。4.10节会提到，“!”运算符是布尔非运算符。我们只要记住“!=”称做“不相等”、“!===”称做“不严格相等”就可以了。

**4.9.2比较运算符**
**4.9.3in运算符**

in运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回true，例如：
```javascript
var point = {x:1,y:1};//定义一个对象
"x" in point;//=>true 对象有一个名为“x”的属性
"z" in point;//=>false 对象中不存在名为“z”的属性
"toString" in point;//=>true 对像继承了toString()方法

var data = [7,8,9];//拥有三个元素的数组
"0" in data;//=>true 数组包含元素“0”
1 in data;//=>true 数字转换为字符串
3 in data;//=>false 没有索引为3的元素
```

**4.9.4instanceof运算符**

instanceof运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧对象是右侧的类的实例，则表达式返回true；否则返回false。第9章将会讲到，javascript中对象的类是通过初始化它们的构造函数来定义的。这样的话，instanceof的右操作数应当是一个函数。比如：
```javascript
var d = new Date();//通过Date()构造函数来创建一个新对象
d instanceof Date();//计算结果为true，d是由Date()创建的
d instanceof Object();//计算结果为true，所有对象都是Object的实例
d instanceof Number();//计算结果为false，d不是一个Number对象
var a = [1,2,3];//通过数组直接量的方法创建一个数组
a instanceof Array;//计算结果为true，a是一个数组
a instanceof Object;//计算结果为true，所有的数组都是对象
a instanceof RegExp;//计算结果为false，数组不是正则表达式
```
需要注意的是，所有的对象都是Object的实例。当通过instanceof判断一个对象是否是一个类的实例的时候，这个判断也会包含对“父类”(superclass)的检测。如果instanceof的左操作数不是对象的话，instanceof返回false。如果右操作数不是函数，则抛出一个类型错误异常。

为了理解instanceof运算符是如何工作的，必须首先理解“原型链”（prototype chain）。
原型链作为javascript的继承机制，将在6.2.2节详细描述。为了计算表达式o instanceof f，javascript首先计算f.prototype，然后在原型链中查找o，如果找到，那么o是f（或者f的父类）的一个实例，表达式返回true。如果f.prototype不在o的原型链中的话，那么o就不是f的实例，instanceof返回false。
对象o中存在一个隐藏的成员，这个成员指向其父类的原型，如果父类的原型是另外一个类的实例的话，则这个原型对象中也存在一个隐藏成员指向另一个类的原型，这种链条将许多对象或类串接起来，既是原型链。原文所讲f.prototype不在o的原型链中也就是说f和o没有派生关系，更多细节请参照6.2.2节。


**4.10逻辑表达式**

逻辑运算符“&&”、“||”和“!”是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式。这些运算符在下面几节中会一一讲述，为了更好地理解它们，应当首先回顾一下3.3节提到的“真值”和“假值”的概念。

**4.11赋值表达式**
**4.12表达式计算**

和其他很多解释性语言一样，javascript同样可以解释运行由javascript源代码组成的字符串，并产生一个值。javascript通过全局函数eval()来完成这个工作：

    eval("3+2")//=>5

动态判断源代码中的字符串是一种强大的语言特性，几乎没有必要在实际中应用。如果你使用来eval(),你应当仔细考虑是否真的需要使用它。
**4.13其他运算符**
javascript支持很多其他各种各样的运算符，后续几节详细讨论它们。
**4.13.1条件运算符(?:)**
**4.13.2typeof运算符**
**4.13.3delete运算符**

delete是一元操作符，它用来删除对象属性或者数组元素，就像赋值、递增、递减运算符一样，delete也具有副作用的，它是用来做删除操作的，不是用来返回一个值的，例如：
```javascript
var o = {x:1,y:2};//定义一个对象
delete o.x;//删除一个属性
"x" in o;  //=>false 这个属性在对象中不再存在
var a = [1,2,3];//定义一个数组
delete a[2];//删除最后一个数组元素
2 in a;//=>false 元素2在数组中已经不存在了
a.length;//=>3 注意，数组长度并没有改变，尽管上一行代码删除了这个元素，但删除操作留下了一个“洞”，实际上并没有修改数组的长度，因此a数组的长度仍然是3
```
需要注意的是，删除属性或者删除数组元素不仅仅是设置了一个undefined的值。当删除一个属性时，这个属性将不再存在。读取一个不存在的属性将返回undefined，但是可以通过in运算符（见4.9.3节）来检测这个属性是否在对象中存在。

delete希望他的操作数是一个左值，如果它不是左值，那么delete将不进行任何操作同时返回true。否则，delete将试图删除这个指定的左值。如果删除成功，delete将返回true。然而并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，用户通过var语句声明的变量不能删除。同样，通过function语句定义的函数和函数参数也不能删除。
在ECMAScript5严格模式中，如果delete的操作数是非法的，比如变量、函数或函数参数，delete操作将抛出一个语法错误（SyntaxError）异常，只有操作数是一个属性访问表达式（见4.4节）时候它才会正常工作。在严格模式下，delete删除不可配置的属性（参照6.7节）时会抛出一个类型错误异常。在非严格模式中，这些delete操作都不会报错，只是简单地返回false，以表明操作数不能执行删除操作。
这里有一些关于delete运算符的例子：
```javascript
var o = {x:1,y:2};  //定义一个变量，初始化为对象
delete o.x;         //删除一个对象属性，返回true
typeof o.x;         //属性不存在，返回“undefined”
delete o.x;         //删除不存在的属性，返回true
delete o;           //不能删除通过var声明的变量，返回false
                    //在严格模式下，将抛出一个异常
delete 1;           //参数不是一个左值，返回true
this.x = 1;         //给全局对象定义一个属性，这里没有使用var
delete x;           //试图删除它，在非严格模式下返回true
                    //在严格模式下会抛出异常，这时使用“delete this.x”来代替
x;                  //运行时错误，没有定义x
```
6.3节还会有关于delete操作符的讨论。

**4.13.4void运算符**
**4.13.5逗号运算符(,)**


语句
----

第4章提到，表达式在javascript中是短语，那么语句（statement）就是javascript整句或命令。正如英文是用句号作结尾来分隔语句，javascript语句是以分号结束（见2.5节）。表达式计算出一个值，但语句用来执行以使某件事发生。

“使某事发生”的一个方法是计算带有副作用的表达式。诸如赋值和函数调用这些有副作用的表达式，是可以作为单独的语句的，这种把表达式当做语句的用法也称做表达式语句（expression statement）。类似的语句还有声明语句（declaration statement），声明语句用来声明新变量或定义新函数。

javascript程序无非就是一系列可执行语句的集合。默认情况下，javascript解释器依照语句的编写顺序依次执行。另一种“使某件事发生”的方法是改变语句的默认执行顺序。javascript中有很多语句和控制结构（control structure）来改变语句的默认执行顺序：

* 条件（conditional）语句，javascript解释器可以根据一个表达式的值来判断是执行还是跳过这些语句，如if语句和switch语句。
* 循环（loop）语句，可以重复执行语句，如while和for语句。
* 跳转（jump）语句，可以让解释器跳转至程序的其他部分继续执行，如break、return和throw语句。

接下来几节将介绍javascript中各式各样的语句及其语法。本章最后的表5-1对这些语句作了总结。一个javascript程序无非是一个以分号分隔的语句集合，所以一旦掌握了javascript语句，就可以开始编写javascript程序了。

**5.1表达式语句**

**5.2复合语句和空语句**

**5.3声明语句**

**5.4条件语句**

**5.5循环**

为了理解条件语句，可以将在javascript中的代码想象成一条条的分支路径。循环语句（looping statement）就是程序路径的一个回路。可以让一部分代码重复执行。javascript中有4种循环语句：while、do/while、for和for/in。下面几节将会依次讲解它们。其中最常用的循环就是对数组元素的遍历，7.6节详细讨论这种循环和使用数组类定义的特殊循环方法。
**5.5.1while**

**5.5.2do/while**

**5.5.3for**

**5.5.4for/in**

for/in语句也使用for关键字，但它是和常规的for循环完全不同的一类循环。for/in循环语句的语法如下：

    for(variable in object) statement

variable通常是一个变量名，也可以是一个可以产生左值的表达式或者一个通过var语句声明的变量，总之必须是一个适用于赋值表达式左侧的值。Object是一个表达式，这个表达式的计算结果是一个对象。同样，statement是一个语句或语句块，它构成了循环的主体。
使用for循环来遍历数组元素是非常简单的：
```javascript
for (var i = 0; i < a.length; i++)//i代表来数组元素的索引
    console.log(a[i]);//输出数组中的每个元素
```
而for/in循环则是用来更方便地遍历对象属性成员：
```javascript
for (var p in o)//将属性的名字赋值给变量p
console.log(o[p]);//输出每一个属性的值
```

**5.6跳转**

**5.7其他语句类型**

**5.8javascript语句小结**


对象
----

对象是javascript的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值，对象也可看做是属性的无序集合，每个属性都是一个名／值对。属性名是字符串，因此我们可以把对象看成是从字符串到值的映射。这种基本数据结构还有很多种叫法，有些我们已然非常熟悉，比如“散列”（hash）、“散列表”（hashtable）、“字典”（dictionary）、“关联数组”（associative array）。然而对象不仅仅是字符串到值的映射，除了可以保持自有的属性，javascript对象还可以从一个称为原型的对象继承属性。对象的方法通常是继承的属性。这种“原型式继承”（prototypal inheritance）是javascript的核心特征。

javascript对象是动态的——可以新增属性也可以删除属性——但它们常用来模拟静态对象以及静态类型语言中的“结构体”（struct）。有时它们也用做字符串的集合（忽略名值对中的值）。

除了字符串、数字、true、false、null和undefined之外，javascript中的值都是对象。尽管字符串、数字和布尔值不是对象，但它们的行为和不可变对象（参照3.6节）非常类似。

3.7节已经讲到，对象是可变的，我们通过引用而非值来操作对象。如果变量x是指向一个对象的引用，那么执行代码var y = x;变量y也是指向同一个对象的引用，而非这个对象的副本。通过变量y修改这个对象亦会对变量x造成影响。

对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。我们会在开始的几节讲述这些基础操作。后续的几节讲述高级主题，其中相当一部分内容来自于ECMAScript5.

属性包括名字和值。属性名可以是包含字符串在内的任意字符串，但对象中不能存在两个同名的属性。值可以是任意javascript值，或者（ECMAScript5中）可以是一个getter或setter函数（或两者都有）。6.6节会有关于getter和setter函数的讲解。除了名字和值之外，每个属性还有一些与之相关的值，称为“属性特性”：

* 可写（writable attribute），表明是否可以设置该属性的值
* 可枚举（enumerable attribute），表明是否可以通过for／in循环返回该属性
* 可配置（configurable attribute），表明是否可以删除或修改该属性。

在ECMAScript5之前，通过代码给对象创建的所有属性都是可写的、可枚举的和可配置的。在ECMAScript5中则可以对这些特性加以配置。6.7节讲述如何操作。除了包含属性之外，每个对象还拥有三个相关的对象特性（object attribute）：

* 对象的原型（prototype）指向另外一个对象，本对象的属性继承自它的原型对象。
* 对象的类（class）是一个标识对象类型的字符串
* 对象的扩展标记（extensible flag）指明了（在ECMAScript5中）是否可以向该对象添加新属性。

6.1.3节和6.2.2节会有关于原型和属性继承的讲述，6.8节会进一步详细讲述这三个特性。
最后，我们用下面这些术语来对三类javascript对象和两类属性作区别：

* 内置对象（native object）是由ECMAScript规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。
* 宿主对象（host object）是由javascript解释器所嵌入的宿主环境（比如web浏览器）定义的。客户端javascript中表示网页结构的HTMLElement对象均是宿主对象。既然宿主环境定义的方法可以当成普通的javascript函数对象，那么宿主对象也可以当成内置对象。
* 自定义对象（user-defined object）是由运行中的javascript代码创建的对象。
* 自有属性（own property）是直接在对象中定义的属性
* 继承属性（inherited property）是在对象的原型对象中定义的属性。

**6.1创建对象**
可以通过对象直接量、关键字new和(ECMAScript5中的)Object.create()函数来创建对象。
**6.1.1对象直接量**
创建对象最简单的方式就是在javascript代码中使用对象直接量。对象直接量是由若干名/值对组成的映射表，名/值对中间用冒号分隔，名/值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是javascript标识符也可以是字符串直接量（包括空字符串）。属性的值可以是任意类型的javascript表达式，表达式的值（可以是原始值也可以是对象值）就是这个属性的值。
```javascript
var empty = {};                             //没有任何属性的对象
var point = { x:0, y:0 };                   //两个属性
var point2 = { x:point.x, y:point.y+1};     //更复杂的值
var book = {               
    "main title": "javascript",             //属性名字里有空格，必须用字符串表示
    'sub-title': "the definitive guide",    //属性名字里有连字符，必须用字符串表示
    "for": "all audiences",                 //for是保留字，因此必须用引号
    author: {                               //这个属性的值是一个对象
        firstname: "david",                 //注意，这里的属性名没有引号
        surname: "flanagan"
    }
};
```
在ECMAScript5（以及ECMAScript3的一些实现）中，保留字可以用做不带引号的属性名。然而对于ECMAScript3来说，使用保留字作为属性名必须使用引号引起来。在ECMAScript5中，对象直接量中的最后一个属性后的逗号将忽略，且在ECMAScript3的大部分实现中也可以忽略这个逗号，但在IE中则报错。

对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象直接量的时候，也都会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用了对象直接量，它将创建很多新对象，并且每次创建的对象的属性值也有可能不同。

**6.1.2通过new创建对象**
new运算符创建并初始化一个新对象。关键字new后跟随一个函数调用。这里的函数称做构造函数（constructor），构造函数用以初始化一个新创建的对象。javascript语言核心中的原始类型都包含内置构造函数。例如：
```javascript
var o = new Object();//创建一个空对象，和{}一样
var a = new Array();//创建一个空数组，和[]一样
var d = new Date();//创建一个表示当前时间的Date对象
var r = new RegExp("js");//创建一个可以进行模式匹配的RegExp对象
```
除了这些内置构造函数，用自定义构造函数来初始化新对象也是非常常见的。第9章将详细讲述其中的细节。

**6.1.3原型**

在讲述第三种对象创建技术之前，我们应当首先解释一下原型。每一个javascript对象（null除外）都和另一个对象相关联。
“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。
所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过javascript代码Object.prototype获得对原型对象的引用。
通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。
因此，同使用{}创建对象一样，通过new Object()创建的对象也继承自Object.prototype。
同样，通过new Array()创建的对象的原型就是Array.prototype，通过new Date()创建的对象的原型就是Date.prototype。

没有原型的对象为数不多，Object.prototype就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。
所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自Object.prototype的原型。
例如，Date.prototype的属性继承自Object.prototype，因此由new Date()创建的Date对象的属性同时继承自Date.prototype和Object.prototype。
这一系列链接的原型对象就是所谓的“原型链”（prototype chain）。

6.2.2节讲述属性继承的工作机制。6.8.1节将会讲到如何获取对象的原型。第9章将会更详细地讨论原型和构造函数，包括如何通过编写构造函数定义对象的“类”，以及给构造函数的prototype属性赋值可以让其“实例”直接使用这个原型上的属性和方法。

**6.1.4Object.create()**
ECMAScript5定义了一个名为Object.create()的方法，它创建一个新对象，其中第一个参数是这个对象的原型。Object.create()提供第二个可选参数，用以对对象的属性进行进一步描述。[属性的特性]()这节会详细讲述第二个参数。
Object.create()是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可；
```javascript
var o1 = Object.create({x:1 ,y:2});      //o1继承了属性x和y
```
可以通过传入参数null来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如toString(),也就是说，它将不能和“+”运算符一起正常工作:
```javascript
var o2 = Object.create(null);            //o2不继承任何属性和方法
```
如果想创建一个普通的空对象（比如通过{}或new Object()创建的对象），需要传入Object.prototype:
```javascript
var o3 = Object.create(Object.prototype);//o3和{}和new Object()一样
```
可以通过任意原型创建新对象（换句话说，可以使任意对象可继承），这是一个强大的特性。在ECMAScript3中可以用类似下例的代码来模拟原型继承：
例子：通过原型继承创建一个新对象
//inherit() 返回了一个继承自原型对象p的属性的新对象
//这里使用ECMAScript5中的Object.create()函数（如果存在的话）
//如果不存在Object.create()，则退化使用其他方法
例6-1
```javascript
function inherit(p) {
    if (p == null) throw TypeError();              //p是一个对象，但不能是null
    if (Object.create)                             //如果Object.create()存在
        return Object.create(p);                   //直接使用它
    var t = typeof p;                              //否则进行进一步检测
    if (t !== "object" && t !== "function") throw TypeError();
    function f() {};                               //定义一个空构造函数
    f.prototype = p;                               //将其原型属性设置为p
    return new f();                                //使用f()创建p的继承对象
}
```
在看完[类和模块](#类和模块)这章关于构造函数的内容后，上面例子中的inherit()函数会更容易理解。现在只要知道它返回的新对象继承了参数对象的属性就可以了。注意，inherit()并不能完全代替Object.create()。它不能通过传入null原型来创建对象。而且不能接收可选的第二个参数。不过我们仍会在[对象]()这章和[类和模块]()这章的示例代码中多次用到inherit()。
inherit()函数的其中一个用途就是防止库函数无意间（非恶意地）修改那些不受你控制的对象。不是将对象直接作为参数传入函数，而是将它的继承对象传入函数。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象。
```javascript
var o = { x: "don't change this value"};
library_function(inherit(o));   //防止对o的意外修改
```
了解其工作原理，需要首先了解javascript中属性的查询和设置机制。接下来会讲到。

**6.2属性的查询和设置**
4.4节已经提到，可以通过点（.）或方括号（[]）运算符来获取属性的值。运算符左侧应当是一个表达式，它返回一个对象。对于（.）来说，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说（[]），方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字：
```javascript
var author = book.author;      //得到book的“author”属性
var name = author.surname;     //得到获得author的“surname”属性
var title = book["main title"];//得到book的“main title”属性
```
和查询属性值的写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧：
```javascript
book.edition = 6;                  //给book创建一个名为"edition"的属性
book["main title"] = "ECMAScript"; //给"main title"属性赋值
```
在ECMAScript3中，点运算符后的标识符不能是保留字，比如，o.for或o.class是非法的，因为for是javascript的关键字，class是保留字。如果一个对象的属性名是保留字，则必须使用方括号的形式访问它们，比如o["for"]和o["class"]。ECMAScript5对此放宽了限制（包括ECMAScript3的某些实现），可以在点运算符后直接使用保留字。
当使用方括号时，我们说方括号内的表达式必须返回字符串。其实更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值。在[数组]()这章里有一些例子中的方括号内使用了数字，这情况是非常常见的。

**6.2.1作为关联数组的对象**
上文提到，下面两个javascript表达式的值相同
```javascript
object.property
object["property"]
```
第一种语法使用点运算符和一个标识符，这和C和Java中访问一个结构体或对象的静态字段非常类似。第二种语法使用方括号和一个字符串，看起来像是数组，只是这个数组元素是通过字符串索引而不是数字索引。这种数组就是我们所说的关联数组（associative array），也称做散列、映射或字典（dictionary）。javascript对象都是关联数组，本节将讨论它的重要性。

在C、C++和Java和一些强类型（strong typed，强类型，为所有变量指定数据类型称为“强类型”。强／弱类型是指类型检查的严格程度。语言有无类型、弱类型和强类型三种。无类型的不检查，甚至不区分指令和数据。弱类型的检查很弱，仅能严格区分指令和数据。强类型的则严格的在编译期间进行检查）的语言中，对象只能拥有固定数目的属性，并且这些须提前定义好。由于javascript是弱类型语言，因此不必遵循这条规定，在任何对象中程序都可以创建任意数量的属性（这里的意思是可以动态地给对象添加属性。严格讲，javascript对象的属性个数是有上限的）。但当通过点运算符访问对象的属性时，属性名用一个标识符来表示。标识符必须直接出现在javascript程序中，它们不是数据类型，因此程序无法修改它们（“程序不能修改标志符”的意思是说，在程序运行时无法动态指定一个标志符，当然eval除外）。

反过来讲，当通过[]来访问对象的属性时，属性名通过字符串来表示。字符串是javascript的数据类型，在程序运行时可以修改和创建它们。因此，可以在javascript中使用下面这种代码：
```javascript
var addr = "";
for(i = 0; i<4; i++){
    addr += customer["address" + i]+'\n';
}
```
这段代码读取customer的adderss0、address1、address2和address3属性，并将它们连接起来。
这个例子主要说明了使用数组写法和用字符串表达式来访问对象属性的灵活性。这段代码也可以通过点运算符来重写，但是很多场景只能通过数组写法来完成。假设你正在写一个程序，这个程序利用网络资源计算当前用户股票市场投资的金额。程序允许用户输入每只股票的名称和购股份额。该程序使用名为portfolio的对象来存储这些信息。每只股票在这个对象中都有对应的属性，属性名称就是股票名称，属性值就是购股数量，例如，如果用户持有IBM的50股，那么portfolio.ibm属性的值就为50。
下面是程序的部分代码，这个函数用来给portfolio添加新的股票：
```javascript
function addstock(portfolio,stockname,shares){
    portfolio[stockname] = shares;
}
```
由于用户是在程序运行时输入股票名称，因此在之前无法得知这些股票的名称是什么。而由于在写程序的时候不知道属性名称，因此无法通过点运算符来访问对象portfolio的属性。但可以使用[]运算符，因为它使用字符串值（字符串值是动态的，可以在运行时更改）而不是标识符(标识符是静态的，必须写死在程序中)作为索引对属性进行访问。

第5章介绍了for／in循环（6.5节还会进一步介绍）。当使用for／in循环遍历关联数组时，就可以清晰地体会到for／in的强大之处。下面例子就是利用for／in计算portfolio的总计值：
```javascript
function getvalue(portfolio) {
    var total = 0.0;
    for(stock in portfolio) {           //遍历portfolio中的每只股票
        var shares = portfolio[stock];  //得到每只股票的份额
        var price = getquote(stock);    //查找股票价格
        total += shares * price;        //将结果累加至total中
    }
    return total;                       //返回total的值
}
```

**6.2.2继承**
javascript对象具有“自有属性”（own property），也有一些属性是从原型对象继承而来的。为了更好地理解这种继承，必须更深入地了解属性访问的细节。本节中的许多示例代码借用了例6-1中的inherit()函数，通过给它传入指定原型对象来创建实例。

假设要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x。如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者查找到一个原型是null的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。
```javascript
var o = {};         //o 从Object.prototype 继承对象的方法
o.x = 1;            //给o定义一个属性
var p = inherit(o); //p继承o和Object.prototype
p.y = 2;            //给p定义一个属性y
var q = inherit(p); //q继承p、o和Object.prototype
q.z = 3;            //给q定义一个属性
var s = q.toString();//toString继承自Object.prototype
q.x + q.y            //=> 3 x和y分别继承自o和p
```
现在假设给对象o的属性x赋值，如果o中已经有属性x（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性x的值。如果o中不存在属性x，那么赋值操作给o添加一个新属性x。如果之前o继承自属性x，那么这个继承的属性就被新创建的同名属性覆盖了。
属性赋值操作首先检查原型链，以此判定是否允许赋值操作。例如，如果o继承自一个只读属性x，那么赋值操作是不允许的（6.2.3节将对此进行详细讨论）。如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。在javascript中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是javascript的一个重要特性，该特性让程序员可以有选择地覆盖（override）继承的属性。
```javascript
var unitcircle = {r:1};     //一个用来继承的对象
var c = inherit(unitcircle);//c继承属性r
c.x = 1; c.y = 1;           //c定义两个属性
c.r = 2 ;                   //c覆盖继承来的属性
unitcircle.r;               //=> 1 原型对象没有修改
```
属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性，但有一个例外，如果o继承自属性x，而这个属性是一个具有setter方法的accessor属性（参照6.6节）。那么这时将调用setter方法而不是给o创建一个属性x。需要注意的是，setter方法是由对象o调用的，而不是定义这个属性的原型对象调用的。因此如果setter方法定义任意属性，这个操作只是针对o本身，并不会修改原型链。

**6.2.3属性访问错误**

属性访问并不总是返回或设置一个值。本节讲述查询或设置属性时的一些出错情况。
查询一个不存在的属性并不会报错，如果在对象o自身的属性或继承的属性中均未找到属性x，属性访问表达式o.x返回undefined。回想一下我们的book对象有属性“sub-title”，而没有属性“subtitle”：

    book.subtitle;//=>undefined 属性不存在

但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。null和undefined值都没有属性，因此查询这些值的属性会报错，接上例：
```javascript
//抛出一个类型错误异常，undefined没有length属性
var len = book.subtitle.length;
```
除非确定book和book.subtitle都是（或在行为上）对象，否则不能这样写表达式book.subtitle.length，因为这样会报错，下面提供了两种避免出错的方法：
```javascript
//一种冗余但很易懂的方法
var len = undefined;
if (book) {
    if (book.subtitle) len = book.subtitle.length;
}
//一种更简练的常用方法，获取subtitle的length属性或undefined
var len = book&&book.subtitle&&book.subtitle.length;
```
为了理解这里的第二种方法为什么可以避免类型错误异常，可以参照4.10.1节中关于&&运算符的短路行为。
当然，给null和undefined设置属性也会报类型错误。给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性，但让人颇感意外的是，这些设置属性的失败操作不会报错：
```javascript
//内置构造函数的原型是可读的
Object.prototype = 0;//赋值失败，但没报错，Object.prototype没有修改
```
这是一个历史遗留问题，这个bug在ECMAScript5的严格模式中已经修复。在严格模式中，任何失败的属性设置操作都会抛出一个类型错误异常。
尽管属性赋值成功或失败的规律看起来很简单，但要描述清楚并不容易。在这些场景下给对象o设置属性p会失败：

* o中的属性p是只读的；不能给只读属性重新赋值（defineProperty()方法中有一个例外，可以对可配置的只读属性重新赋值）。
* o中的属性p是继承属性，且它是只读的，不能通过同名自有属性覆盖只读的继承属性。
* o中不存在自有属性p：o没有使用setter方法继承属性p，并且o的可扩展性（extensible attribute）是false（参照6.8.3节）。如果o中不存在p，而且没有setter方法可供调用，则p一定会添加至o中。但如果o不是可扩展的，那么o中不能定义新属性。

**6.3删除属性**

delete运算符（见4.13.3节）可以删除对象的属性。它的操作数应当是一个属性访问表达式。让人意外的是，delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性(a={p:{x:1}};b=a.p;delete a.p;执行这段代码之后b.x的值依然是1。由于已经删除的属性的引用依然存在，因此在javascript的某些实现中，可能因为这种不严谨的代码而造成内存泄漏。所以在销毁对象的时候，要遍历属性中的属性，依次删除)：

    delete book.author;//book不再有属性author
    delete book["main title"];//book也不再有属性“main title”

delete运算符只能删除自由属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）。
当delete表达式删除成功或没有任何副作用（比如删除不存在的属性）时，它返回true。如果delete后不是一个属性访问表达式，delete同样返回true：
```javascript
o = {x:1};//o有一个属性x，并继承属性toString
delete o.x;//删除x，返回true
delete o.x;//什么都没做（x已经不存在了），返回true
delete o.toString;//什么也没做（toString是继承来的），返回true
delete 1;//无意义，返回true
```
delete不能删除那些可配置性为false的属性（尽管可以删除不可扩展对象的可配置属性）。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。在严格模式中，删除一个不可配置属性会报一个类型错误。在非严格模式中（以及ECMAScript3中），在这些情况下的delete操作会返回false：
```javascript
delete Object.prototype;//不能删除，属性是不可配置的
var x = 1;//声明一个全局变量
delete this.x//不能删除这个属性
function f() {}//声明一个全局函数
delete this.f;//也不能删除全局函数
```
当在非严格模式中删除全局对象的可配置属性时，可以省略对全局对象的引用，直接在delete操作符后跟随要删除的属性名即可。
```javascript
this.x = 1;//创建一个可配置的全局属性（没有用var）
delete x;//将它删除
```
然而在严格模式中，delete后跟随一个非法的操作数（比如x），则会报一个语法错误，因此必须显式指定对象及其属性：
```javascript
delete x;//在严格模式下报语法错误
delete this.x//正常工作
```

**6.4检测属性**

javascript对象可以看做属性的集合，我们经常会检测集合中成员的所属关系——判断某个属性是否存在于某个对象中。可以通过in运算符、hasOwnPreperty()和propertyIsEnumerable()方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。

in运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回true：
```javascript
var o = {x:1};//
"x" in o;//true: "x"是o的属性
"y" in o;//false: "y"不是o的属性
"toString" in o;//true: o继承toString属性
```
对象的hasOwnProperty()方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回false：
```javascript
var o = {x:1};
o.hasOwnProperty("x");//true: o有一个自有属性x
o.hasOwnProperty("y");//false: o中不存在属性y
o.hasOwnProperty("toString");//false: toString是继承属性
```
propertyIsEnumerable()是hasOwnProperty()的增强版，只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为true时它才返回true。某些内置属性是不可枚举的。通常由javascript代码创建的属性都是可枚举的，除非在javascript5中使用一个特殊的方法来改变属性的可枚举性，随后会提到：
```javascript
var o = inherit({y:2});
o.x = 1;
o.propertyIsEnumerable("x");//true o有一个可枚举的自有属性x
o.propertyIsEnumerable("y");//false y是继承来的
Object.prototype.propertyIsEnumerable("toString");//false 不可枚举
```
除了使用in运算符之外，另一种更简便的方法是使用“!==”判断一个属性是否是undefined：
```javascript
var o {x:1}
o.x !== undefined;//true o中有属性x
o.y !== undefined;//false o中没有属性y
o.toString !== undefined;//true o继承了toString属性
```
然而有一种场景只能使用in运算符而不能使用上述属性访问的方式。in可以区分不存在的属性和存在但值为undefined的属性。例如下面的代码：
```javascript
var o ={x:undefined};//属性被显式赋值为undefined
o.x !== undefined;//false 属性存在，但值为undefined
o.y !== undefined;//false 属性不存在
"x" in o;//true 属性存在
"y" in o;//false 属性不存在
delete o.x;//删除了属性x
"x" in o;//false 属性不再存在
```
注意，上述代码中使用的是“!==”运算符，而不是“!=”。“!==”可以区分undefined和null。有时则不必作这些区分：
```javascript
//如果o中含有属性x，且x的值不是null或undefined，o.x乘以2
if(o.x != null) o.x*=2;
//如果o中含有属性x，且x的值不能转换为false，o.x乘以2
//如果x是undefined、null、false、""、0或NaN，则它保持不变
if(o.x) o.x*=2;
```
**6.5枚举属性**

除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用for/in循环遍历，ECMAScript5提供了两个更好用的替代方案。
5.5.4节讨论过for/in循环，for/in循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的（除非用下文中提到的一个方法将它们转换为不可枚举的）。例如：
```javascript
var o = {x:1, y:2, z:3};//三个可枚举的自有属性
o.propertyIsEnumerable("toString")//=>false，不可枚举
for(p in o)//遍历属性
console.log(p)//输出x、y和z，不会输出toString
```
有很多实用工具库给Object.prototype添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。然而在ECMAScript5标准之前，这些新添加的方法是不能定义为不可枚举的，因此它们都可以在for/in循环中枚举出来。为了避免这种情况，需要过滤for/in循环返回的属性，下面两种方式是最常见的：
```javascript
for(p in o){
    if(!o.hasOwnProperty(p)) continue;//跳过继承的属性
}
for(p in o){
    if(typeof o[p] === "function") continue;//跳过方法
}
```
例6-2定义了一些有用的工具函数来操控对象的属性，这些函数用到了for/in循环。实际上extend()函数经常出现在javascript实用工具库中。
这里实现的extend()逻辑虽然正确，但并不能弥补IE中有一些众所周知的bug，在例8-3中会有更健壮的extend()实现。
例6-2：用来枚举属性的对象工具函数
```javascript
/*
 * Copy the enumerable properties of p to o, and return o.
 * If o and p have a property by the same name, o's property is overwritten.
 * This function does not handle getters and setters or copy attributes.
 *把p中的可枚举属性复制到o中，并返回o，如果o和p中含有同名属性，则覆盖o中的属性，这个函数并不处理getter和setter以及复制属性
 */
function extend(o, p) {
    for(prop in p) {                         // For all props in p，遍历p中的所有属性
        o[prop] = p[prop];                   // Add the property to o，将属性添加至o中
    }
    return o;
}

/*
 * Copy the enumerable properties of p to o, and return o.
 * If o and p have a property by the same name, o's property is left alone.
 * This function does not handle getters and setters or copy attributes.
 *将p中的可枚举属性复制至o中，并返回o，如果o和p中同名的属性，o中的属性将不受影响，这个函数将不处理getter和setter以及复制属性 
 */
function merge(o, p) {
    for(prop in p) {                           // For all props in p，遍历p中所有的属性
        if (o.hasOwnProperty[prop]) continue;  // Except those already in o，过滤掉已经在o中存在的属性
        o[prop] = p[prop];                     // Add the property to o，将属性添加至o中
    }
    return o;
}

/*
 * Remove properties from o if there is not a property with the same name in p.
 * Return o.
 *如果o中的属性在p中没有同名属性，则从o中删除这个属性，返回o
 */
function restrict(o, p) {
    for(prop in o) {                         // For all props in o，遍历o中所有的属性
        if (!(prop in p)) delete o[prop];    // Delete if not in p，如果在p中不存在，则删除之
    }
    return o;
}

/*
 * For each property of p, delete the property with the same name from o.
 * Return o.
 *如果o中的属性在p中存在同名属性，则从o中删除这个属性，返回o
 */
function subtract(o, p) {
    for(prop in p) {                         // For all props in p，遍历p中所有的属性
        delete o[prop];                      // Delete from o (deleting a
                                             // nonexistent prop is harmless)，从o中删除（删除一个不存在的属性不会报错）
    }
    return o;
}

/*
 * Return a new object that holds the properties of both o and p.
 * If o and p have properties by the same name, the values from o are used.
 *返回一个新对象，这个对象同时拥有o的属性和p的属性，如果o和p中有重名属性，使用p中的属性值
 */
function union(o,p) { return extend(extend({},o), p); }

/*
 * Return a new object that holds only the properties of o that also appear
 * in p. This is something like the intersection of o and p, but the values of
 * the properties in p are discarded
 *返回一个新对象，这个对象拥有同时在o和p中出现的属性，很像求o和p的交集，但p中属性的值被忽略
 */
function intersection(o,p) { return restrict(extend({}, o), p); }

/*
 * Return an array that holds the names of the enumerable own properties of o.
 *返回一个数组，这个数组包含的是o中可枚举的自有属性的名字
 */
function keys(o) {
    if (typeof o !== "object") throw TypeError();  // Object argument required，参数必须是对象
    var result = [];                 // The array we will return，将要返回的数组
    for(var prop in o) {             // For all enumerable properties，遍历所有可枚举的属性
        if (o.hasOwnProperty(prop))  // If it is an own property，判断是否是自有属性
            result.push(prop);       // add it to the array.将属性名添加至数组中
    }
    return result;                   // Return the array.返回这个数组
}
```
除了for/in循环之外，ECMAScript5定义了两个用以枚举属性名称的函数。第一个是Object.keys()，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成，它的工作原理和例6-2中的工具函数keys()类似。
ECMAScript5中第二个枚举的属性的函数是Object.getOwnPropertyNames(),它和Object.keys()类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。在ECMAScript3中是无法实现的类似的函数的，因为ECMAScript3中没有提供任何方法来获取对象不可枚举的属性。

**6.6属性getter和setter**

我们知道，对象属性是由名字、值和一组特性（attribute）构成的。在ECMAScript5中（包括除IE之外的最新主流浏览器的ECMAScript3的实现），属性值可以用一个或两个方法替代，这两个方法就是getter和setter。有getter和setter定义的属性称做“存取器属性”（accessor property），它不同于“数据属性”（data property），数据属性只有一个简单的值。

当程序查询存取器属性的值时，javascript调用getter方法（无参数）。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，javascript调用setter方法，将赋值表达式右侧的值当做参数传入setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略setter方法的返回值。

和数据属性不同，存取器属性不具有可写性（writable attribute）。如果属性同时具有getter和setter方法，那么它是一个读／写属性。如果它只有setter方法，那么它是一个只写属性（数据属性中有一些例外），读取只写属性总是返回undefined。

定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法：
```javascript
var o = {
//普通的数据属性
data_prop: value,
//存取器属性都是成对定义的函数
get accessor_prop(){/*这里是函数体*/}
set accessor_prop(value){/*这里是函数体*/}
};
```
存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用function关键字，而是使用get和（或）set。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。例如，思考下面这个表示2D笛卡尔点坐标的对象。它有两个普通的属性x和y分别表示对应点的x坐标和y坐标，它还有两个等价的存取器属性用来表示点的极坐标：
```javascript
var p = {
//x和y是普通的可读写的数据属性
x:1.0,
y:1.0,
//r是可读写的存取器属性，它有getter和setter
//函数体结束后不要忘记带上逗号
get r() {return Math.sqrt(this.x*this.x+this.y*this.y);},
set r(newvalue) {
    var oldvalue = Math.sqrt(this.x*this.x+this.y*this.y);
    var ratio = newvalue/oldvalue;
    this.x *= ratio;
    this.y *= ratio;
},
//theta是只读存取器属性，它只有getter方法
get theta() { return Math.atan2(this.y,this.x);}
};
```
注意在这段代码中getter和setter里this关键字的用法。javascript把这些函数当做对象的方法的来调用，也就是说，在函数体内的this指向表示这个点的对象，因此，r属性的getter方法可以通过this.x和this.y引用x和y属性。8.2.2节会对方法和this关键字做更详尽的讲述。

和数据属性一样，存取器属性是可以继承的，因此可以将上述代码中的对象p当做另一个“点”的原型。可以给新对象定义它的x和y属性。8.2.2节会对方法和this关键字做更详尽的讲述。

和数据属性一样，存取器属性是可以继承的，因此可以将上述代码中的对象p当做另一个“点”的原型。可以给新对象定义它的x和y属性，但r和theta属性是继承来的：
```javascript
var q = inherit(p);//创建一个继承getter和setter的新对象
q.x = 1, q,y = 1;//给q添加两个属性
console.log(q.r);//可以使用继承的存取器属性
console.log(q.theta);
```
这段代码使用存取器属性定义api，api提供了表示同一组数据的两种方法（笛卡尔坐标系表示法和极坐标系表示法）。还有很多场景可以用到存取器属性，比如智能检测属性的写入值以及在每次属性读取时返回不同值：
```javascript
//这个对象产生严格自增的序列号
var serialnum = {
//这个数组属性包含下一个序列号
//$符号暗示这个属性是一个私有属性
$n: 0,
//返回当前值，然后自增
get next() { return this.$n++; },
//给n设置新的值，但只有当它比当前值大时才设置成功
set next(n) {
    if(n >= this.$n) this.$n = n;
    else throw "序列号的值不能比当前值小";
}
}
```
最后我们再来看一个例子，这个例子使用getter方法实现一种“神奇”的属性：
```javascript
//这个对象有一个可以返回随机数的存取器属性
//例如，表达式“random.octet”产生一个随机数
//每次产生的随机数都在0~255之间
var random = {
    get octet() {return Math.floor(Math.random()*256);},
    get uint16() {return Math.floor(Math.random()*65536);},
    get int16() {return Math.floor(Math.random()*65536)-32768;}
};
```
本节介绍了如何给对象直接量定义存取器属性。下一步会介绍如何给一个已经存在的对象添加一个存取器属性。

**6.7属性的特性**

除了名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。在ECMAScript3中无法设置这些特性，所有通过ECMAScript3的程序创建的属性都是可写的、可枚举的和可配置的，且无法对这些特性做修改。本节将讲述ECMAScript5中查询和设置这些属性特性的api，这些api对于库的开发者来说非常重要，因为：

* 可以通过这些api给原型对象添加方法，并将它们设置成不可枚举的，这让它们看起来更像内置方法。
* 可以通过这些api给对象定义不能修改或删除的属性，借此“锁定”这个对象。

在本节里，我们将存取器属性的getter和setter方法看成是属性的特性。按照这个逻辑，我们也可以把数据属性的值同样看做属性的特性。因此，可以认为一个属性包含一个名字和4个特性。数据属性的4个特性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable）。存取器属性不具有值（value）特性和可写性，它们的可写性是由setter方法存在与否决定的。因此存取器属性的4个特性是读取（get）、写入（set）、可枚举性和可配置性。   

为了实现属性特性的查询和设置操作，ECMAScript5中定义了一个名为“属性描述符”（property descriptor）的对象，这个对象代表那4个特性。描述符对象的属性和它们所描述的属性特性是同名的。因此，数据属性的描述符对象的属性有value、writable、enumerable和configurable。存取器属性的描述符对象则用get属性和set属性代替value和writable。其中writable、enumerable和configurable都是布尔值，当然，get属性和set属性是函数值。

通过调用Object.getOwnPropertyDescriptor()可以获得某个对象特定属性的属性描述符：
```javascript
//返回{value:1,writable:true,enumerable:true;configurable:true}
Object.getOwnPropertyDescripor({x:1},"x");
//查询上下文中定义的random对象的octet属性
//返回{get:/*func*/, set:undefined,enumerable:true;configurable:true}
Object.getOwnPropertyDescriptor(random,"octet");
//对于继承属性和不存在的属性，返回undefined
Object.getOwnPropertyDescriptor({},"x"); //undefined，没有这个属性
Object.getOwnPropertyDescriptor({},"toString");//undefined，继承属性
```
从函数名字就可以看出，Object.getOwnPropertyDescriptor()只能得到自有属性的描述符。要想获得继承属性的特性，需要遍历原型链（参照6.8.1节的Object.getPrototypeOf()）。

要想设置属性的特性，或者想让新建属性具有某种特性，则需要调用Object.definePeoperty()，传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象。
```javascript
var o = {};//创建一个空对象
//添加一个不可枚举的数据属性x，并赋值为1
Object.defineProperty(o,"x",{value:1,writable:true,enumerable:false,configurable:true});
//属性是存在的，但不可枚举
o.x;//=>1
Object.kes(o)//=>[]
//现在只对属性x做修改，让它变为只读
Object.defineProperty(o,"x",{writable:false});
//试图更改这个属性的值
o.x = 2;//操作失败，但不报错，而在严格模式中抛出类型错误异常
o.x //=> 1
//属性依然是可配置的，因此可以通过这种方式对它进行修改：
Object.defineProperty(o,"x",{value:2});
o.x //=>2
//现在将x从数据属性修改为存取器属性
Object.defineProperty(o,"x",{get:function(){return o;}});
o.x //=>0
```
传入Object.defineProperty()的属性描述符对象不必包含所有4个特性。对于新创建的属性来说，默认的特征值是false或undefined。对于修改的已有属性来说，默认的特性值没有做任何修改。注意，这个方法要么修改已有属性要么新建自有属性，但不能修改继承属性。

如果同时修改或创建多个属性，则需要使用Object.defineProperties()。第一个参数是要修改的对象，第二个参数是一个映射表，它包含要新建或修改的属性的名称，以及它们的属性描述符，例如：
```javascript
var p = Object.defineProperties({},{
    x:{value:1,writable:true,enumerable:true,configurable:true},
    y:{value:1,writable:true,enumerable:true,configurable:true},
    r:{
        get: function(){return Math.sqrt(this.x*this.x + this.y*this.y)},
        enumerable: true,
        configurable: true
    }
});
```
这段代码从一个空对象开始，然后给它添加两个数据属性和一个只读存取器属性。最终Object.defineProperties()返回修改后的对象（和Object.defineProperty()一样）。

对于那些不允许创建或修改的属性来说，如果用Object.defineProperty()和Object.defineProperties()对其操作（新建或修改）就会抛出类型错误异常，比如，给一个不可扩展的对象（参照6.8.3节）新增属性就会抛出类型错误异常。造成这些方法抛出类型错误异常的其他原因则和特性本身有关。可写性控制着对值特性的修改。可配置性控制着对其他特性（包括属性是否可以删除）的修改。然而规则远不止这么简单，例如，如果属性是可配置的话，则可以修改不可写属性的值。同样，如果属性是不可配置的，仍然可以将可写属性修改为不可写属性。下面是完整的规则，任何对Object.defineProperty()或Object.defineProperties()违反规则的使用都会抛出类型错误异常：

* 如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性。
* 如果属性是不可配置的，则不能修改它的可配置性和可枚举性。
* 如果存取器属性是不可配置的，则不能修改其getter和setter方法，也不能将它转换为数据属性。
* 如果数据属性是不可配置的，则不能将它转换为存取器属性。
* 如果数据属性是不可配置的，则不能将它的可写性从false修改为true，但可以从true修改为false。
* 如果数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写的，然后修改它的值，最后转换为不可写的）

例6-2实现了extend()函数，这个函数把一个对象的属性复制到另一个对象中。这个函数只是简单地复制属性名和值，没有复制属性的特性，而且也没有复制存取器属性的getter和setter方法，只是将它们简单地转换为静态的数据属性。例6-3给出了改进的extend()，它使用Object.getOwnPropertyDescriptor()和Object.defineProperty()对属性的所有特性进行复制。新的extend()作为不可枚举属性添加到Object.prototype中，因此它是Object上定义的新方法，而不是一个独立的函数。

```javascript
/*
 * Add a nonenumerable extend() method to Object.prototype.
 * This method extends the object on which it is called by copying properties
 * from the object passed as its argument.  All property attributes are
 * copied, not just the property value.  All own properties (even non-
 * enumerable ones) of the argument object are copied unless a property
 * with the same name already exists in the target object.
 *给Object.prototype添加一个不可枚举的extend()方法
 *这个方法继承自调用它的对象，将作为参数传入对象的属性一一复制
 *除了值之外，也复制属性的所有特性，除非在目标对象中存在同名的属性,
 *参数对象的所有自有对象（包括不可枚举的属性）也会一一复制
 */
Object.defineProperty(Object.prototype,
    "extend",                  // Define Object.prototype.extend，定义Object.prototype.extend
    {
        writable: true,
        enumerable: false,     // Make it nonenumerable，将其定义为不可枚举的
        configurable: true,
        value: function(o) {   // Its value is this function，值就是这个函数
            // Get all own props, even nonenumerable ones，得到所有的自有属性，包括不可枚举属性
            var names = Object.getOwnPropertyNames(o);
            // Loop through them，遍历它们
            for(var i = 0; i < names.length; i++) {
                // Skip props already in this object，如果属性已经存在，则跳过
                if (names[i] in this) continue;
                // Get property description from o，获得o中的属性的描述符
                var desc = Object.getOwnPropertyDescriptor(o,names[i]);
                // Use it to create property on this，用它给this创建一个属性
                Object.defineProperty(this, names[i], desc);
            }
        }
    });
```
getter和setter的老式api：
可以通过6.6节描述的对象直接量语法给新对象定义存取器属性，但不能查询属性的getter和setter方法或给已有的对象添加新的存取器属性。在ECMAScript5中，可以通过Object.getOwnPropertyDescriptor()和Object.defineProperty()来完成这些工作。
在ECMAScript5标准被采纳之前，大多数javascript的实现（IE浏览器除外）已经可以支持对象直接量语法中的get和set写法。这些实现提供了非标准的老式api用来查询和设置getter和setter。这些api由4个方法组成，所有对象都拥有这些方法。__lookupGetter__()和__lookupSetter__()用以返回一个命名属性的getter和setter方法。__defineGetter__()和__defineSetter__()用以定义getter和setter，这两个函数的第一个参数是属性名字，第二个参数是getter和setter方法。这4个方法都是以两条下划线作前缀，两条下划线做后缀，以表明它们是非标准的方法。本书第三部分没有对非标准方法做介绍。

**6.8对象的三个属性**

每一个对象都有与之相关的原型（prototype）、类（class）和可扩展性（extensible attribute）。下面几节将会展开描述这些属性有什么作用，以及如何查询和设置它们。

**6.8.1原型属性**

对象的原型属性是用来继承属性的（关于原型和原型继承的更多内容请参照6.1.3节和6.2.2节），这个属性如此重要，以至于我们经常把“o的原型属性”直接叫做“o的原型”。

原型属性是在实例对象创建之初就设置好的，回想一下6.1.3节提到的，通过对象直接量创建的对象使用Object.prototype作为它们的原型。通过new创建的对象使用构造函数的prototype属性作为它们的原型。通过Object.create()创建的对象使用第一个参数（也可以是null）作为它们的原型。

在ECMAScript5中，将对象作为参数传入Object.getPrototypeOf()可以查询它的原型。在ECMAScript3中，则没有与之等价的函数，但经常使用表达式o.constructor.prototype来检测一个对象的原型。通过new表达式创建的对象，通常继承一个constructor属性，这个属性指代创建这个对象的构造函数。更多细节将会放在9.2节进一步讨论，9.2节还解释了使用这种方法来检测对象原型的方式并不可靠的原因。注意，通过对象直接量或Object.create()创建的对象包含一个名为constructor的属性，这个属性指代Object()构造函数。因此，constructor.prototype才是对象直接量的真正的原型，但对于通过Object.create()创建的对象则往往不是这样。
要想检测一个对象是否是另一个对象的原型（或处于原型链中），请使用isPrototypeOf()方法。例如，可以通过p.isPrototypeOf(o)来检测p是否是o的原型：
```javascript
var p = {x:1}//定义一个原型对象
var o = Object.create(p);//使用这个原型创建一个对象
p.isPrototypeOf(o); //=>true　o继承自p
Object.prototype.isPrototypeOf(o) //=>true o继承自Object.prototype
Object.prototype.isPrototypeOf(p) //=>true p继承自Object.prototype
```
需要注意的是，isPrototypeOf()函数实现的功能和instcanceof运算符非常类似（参照4.9.4节）。
Mozilla实现的javascript（包括早些年的netscape）对外暴露了一个专门命名__proto__的属性，用以直接查询/设置对象的原型。但并不推荐使用__proto__，因为尽管Safari和Chrome的当前版本都支持它，但IE和Opera还未实现它（可能以后也不会实现）。实现了ECMAScript5的firefox版本依然支持__proto__，但对修改不可扩展的对象的原型做了限制。

**6.8.2类属性**

对象的类属性（class attribute）是一个字符串，用以表示对象的类型信息。ECMAScript3和ECMAScript5都未提设置这个属性的方法，并只有一种间接的方法可以查询它。默认的toString()方法（继承自Object.prototype）返回了如下这种格式的字符串：

    [object class]
    
因此，要想获得对象的类，可以调用对象的toString()方法，然后提取已返回字符串的第8个到倒数第二个位置之间的字符。不过让人感觉棘手的是，很多对象继承的toString()方法重写了，为了能调用正确的toString()版本，必须间接地调用Function.call()方法（参照8.7.3节）。例6-4中的classof()函数可以返回传递给它的任意对象的类：
```javascript
function classof(o) {
    if (o === null) return "Null";
    if (o === undefined) return "Undefined";
    return Object.prototype.toString.call(o).slice(8,-1);
}
```
classof()函数可以传入任何类型的参数。数字、字符串和布尔值可以直接调用toString()方法，就和对象调用toString()方法一样，并且这个函数包含了对null和undefined的特殊处理（在ECMAScript5中不需要对这些特殊情况做处理）。通过内置构造函数（比如Array和Date）创建的对象包含“类属性”（class attribute），它与构造函数名称相匹配。宿主对象也包含有意义的“类属性”，但这和具体的javascript实现有关。通过对象直接量和Object.create创建的对象的类属性是“Object”，那些自定义构造函数创建的对象也是一样，类属性也是“Object”，因此对于自定义的类来说，没办法通过类属性来区分对象的类：
```javascript
classof(null)//=> "Null"
classof(1)//=> "Number"
classof("")//=> "String"
classof(false)//=> "Boolean"
classof({})//=> "Object"
classof([])//=> "Array"
classof(/./)//=> "Regexp"
classof(new Date())//=> "Date"
classof(window)//=> "Window"(这是客户端宿主对象)
function f() {};//定义一个自定义的构造函数
classof(new f());//=> "Object"
```

**6.8.3可扩展性**

对象的可扩展性用以表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展性是由javascript引擎定义的。在ECMAScript5中，所有的内置对象和自定义对象都是可扩展的，除非将它们转换为不可扩展的，同样，宿主对象的可扩展性也是由实现ECMAScript5的javascript引擎定义的。

ECMAScript5定义了用来查询和设置对象可扩展性的函数。通过将对象传入Object.esExtensible()，来判断该对象是否是可扩展的。如果想将对象转换为不可扩展的，需要调用Object.preventExtensions(),将待转换的对象作为参数传进去。注意，一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了。同样需要注意的是，preventExtensions()只影响到对象本身的可扩展性。如果给一个不可扩展的对象的原型添加属性，这个不可扩展的对象同样会继承这些新属性。

可扩展属性的目的是将对象“锁定”，以避免外界的干扰。对象的可扩展性通常和属性的可配值性与可写性配合使用，ECMAScript5定义的一些函数可以更方便地设置多种属性。

Object.seal()和Object.preventExtensions()类似，除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的。也就是说，不能给这个对象添加新属性，而且它已有的属性也不能删除或配置，不过它已有的可写属性依然可以设置。可于那些已经封闭（sealed）起来的对象是不能解封的。可以使用Object.isSealed()来检测对象是否封闭。

Object.freeze()将更严格地锁定对象——“冻结”（frozen）。除了将对象设置为不可扩展和将其属性设置为不可配置的之外，还可以将它自有的所有数据属性设置为只读（如果对象的存取器属性具有setter方法，存取器属性将不受影响，仍可以通过给属性赋值调用它们）。使用Object.isFrozen()来检测对象是否冻结。
Object.preventExtensions()、Object.seal()和Object.freeze()都返回传入的对象，也就是说，可以通过函数嵌套的方式调用它们：
```javascript
//创建一个封闭对象，包括一个冻结的原型和一个不可枚举的属性
var o = Object.seal(Object.create(Object.freeze({x:1}),{y:{value:2, writable:true}})):
```

**6.9序列化对象**

对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript5提供了内置函数JSON.stringify()和JSON.parse()用来序列化和还原javascript对象。这些方法都使用JSON作为数据交换格式，JSON的全称是“JavaScript Object Notation”——javascript对象表示法，它的语法和javascript对象与数组直接量的语法非常相近：
```javascript
o = {x:1, y:{z:[false,null,""]}};//定义一个测试对象
s = JSON.stringify(o);//s是 '{x:1, y:{z:[false,null,""]}}'
p = JSON>parse(s);//p是o的深拷贝
```

    ECMAScript5中的这些函数的本地实现和http://json.org/json2.js中的公共域ECMAScript3版本的实现非常类似，或者说完全一样，因此可以通过引入json2.js模块在ECMAScript3的环境中使用ECMAScript5中的这些函数。
    
json的语法是javascript语法的子集，它并不能表示javascript里的所有值。支持对象、数组、字符串、无穷大数字、true、false和null，并且它们可以序列化和还原。NaN、Infinity和-Infinity序列化的结果是null，日期对象序列化的结果是ISO格式的日期字符串（参照Date.toJSON()函数），但JSON.parse()依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error对象和undefined值不能序列化和还原。JSON.stringify()只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。JSON.stringify()和JSON.parse()都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。第三部分有关于这些函数的详细文档。

**6.10对象方法**

上文已经讨论过，所有的javascript对象都从Object.prototype继承属性（除了那些不通过原型显式创建的对象）。这些继承属性主要是方法，因为javascript程序员普遍对继承方法更感兴趣。我们已经讨论过hasOwnProperty()、propertyIsEnumerable()和isPrototypeOF()这三个方法，以及在Object构造函数里定义的静态函数Object.create()和Object.getPrototypeOf()等。这节将对定义在Object.prototype里的对象方法展开讲解，这些方法非常好用而且使用广泛，但一些特定的类会重写这些方法。

**6.10.1toString()方法**

toString()方法没有参数，它将返回一个表示调用这个方法的对象值的字符串。在需要将对象转换为字符串的时候，javascript都会调用这个方法。比如，当使用“+”运算符连接一个字符串和一个对象时或者在希望使用字符串的方法中使用了对象时都会调用toString()。

默认的toString()方法的返回值带有的信息量很少（尽管它在检测对象的类型时非常有用，参照6.8.2），例如，下面这行代码的计算结果为字符串“[object Object]”：

    var s = {x:1, y:1}.toString();

由于默认的toString()方法并不会输出很多有用的信息。因此很多类都带有自定义的toString()。例如，当数组转换为字符串的时候，结果是一个数组元素列表，只是每个元素都转换成了字符串，再比如，当函数转换为字符串的时候，得到函数的源代码。第三部分有关于toString()的详细文档说明，比如Array.toString()、Date.toString()以及Function.toString()。
9.3.6节介绍如何给自定义类重写toString()方法。

**6.10.2toLocaleString()方法**

除了基本的toString()方法之外，对象都包含toLocaleString()方法，这个方法返回一个表示这个对象的本地化字符串。Object中默认的toLocaleString()方法并不做任何本地化自身的操作，它仅调用toString()方法并返回对应值。Date和Numer类对toLocaleString()做了定制，可以用它对数字、日期和时间做本地化的转换。Array类的toLocaleString()方法和toString()方法很像，唯一的不同是每个数组元素会调用toLocaleString()方法转换为字符串，而不是调用各自的toString()方法。

**6.10.3toJSON()方法**

Object.prototype实际上没有定义toJSON()方法，但对于需要执行序列化的对象来说，JSON.stringify()方法会调用toJSON()方法。如果在待序列化的对象中存在这个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。具体示例参加Date.toJSON()。

**6.10.4valueOf()方法**

valueOf()方法和toString()方法非常类似，但往往当Javascript需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，javascript就会自动调用这个方法。默认的valueOF()方法不足为奇，但有些内置类自定义了valueOf()方法（比如Date.valueOf()），9.6.3节讨论如何给自定义对象类型定义valueOf()方法。

数组
----

数组是值得有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。javascript数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组，这允许创建复杂的数据结构，如对象的数组和数组的数组。javascript数组的索引是基于零的32位数值：第一个索引是0，最大可能的索引为4294967294（2的32次方减去2），数组最大能容纳4294967295个元素。javascript数组是动态的，根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。javascript数组可能是稀疏的：数组元素的索引不一定是连续的，它们之间可以有空缺。每个javascript数组都有一个length属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length比所有元素索引要大。

javascript数组是javascript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。我们将在本章的其他地方更多地讨论特殊化的数组。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。

数组继承自Array.prototype中的属性，它定义了一套丰富的数组操作方法，7.8节和7.9节涵盖这方面的内容。大多数这些方法是通用的，这意味着它们不仅对真正的数组有效，而且对“类数组对象”同样有效。7.11节讨论类数组对象。在ECMAScript5中，字符串的行为与字符数组类似，我们将在7.12节讨论。

**7.1创建数组**

使用数组直接量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可。例如：
```javascript
var empty = [];//没有元素的数组
var primes = [2, 3, 5, 7, 11];//有5个数值的数组
var misc = [1.1, true, "a" ,]//3个不同类型的元素和结尾的逗号
```
数组直接量中的值不一定要是常量：它们可以是任意的表达式：
```javascript
var base = 1024;
var table = [base, base+1, base+2, base+3]; 
```
它可以包含对象直接量或其他数组直接量：

    var b = [[1,{x:1,y:2}],[2,{x:3,y:4}]];

如果省略数组直接量中的某个值，省略的元素将被赋予undefined值：
```javascript
var count = [1,,3];//数组有3个元素，中间的那个元素值为undefined
var undefs =  [,,];//数组有2个元素，都是undefined
```
数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。

调用构造函数Array()是创建数组的另一种方法。可以用三种方式调用构造函数。

* 调用时没有参数：


    var a = new Array();
    
该方法创建一个没有任何元素的空数组，等同于数组直接量[]。

* 调用时有一个数值参数，它指定长度：


    var a = new Array(10);
    
该技术创建指定长度的数组。当预先知道所需要元素个数时，这种形式的Array()构造函数可以用来预分配一数组空间。注意，数组中没有存储值，甚至数组的索引属性“0”、“1”等还没未定义。

* 显式指定两个或多个数组元素或者数组的一个非数值元素：


    var a = new Array(5,4,3,2,1,"testing, testing");
    
以这种形式，构造函数的参数将会成为新数组的元素。使用数组字面量比这样使用Array()构造函数要简单多了。

**7.2数组元素的读和写**

使用[]操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。因此，如下代码都是合法的javascript语句：
```javascript
var a = ["world"];//从一个元素的数组开始
var value = a[0];//读第0个元素
a[1] = 3.14;//写第1个元素
i = 2;
a[i] = 3;//写第2个元素
a[i + 1] = "hello";//写第3个元素
a[a[i]] = a[0];//读第0个和第2个元素，写第3个元素
```
请记住，数组是对象的特殊形式。使用方括号访问数组元素就像使用方括号访问对象的属性一样。javascript将指定的数字索引值转换成字符串——索引值1变成“1”——然后将其作为属性名来使用。关于索引值从数字转换为字符串没什么特别之处：对常规对象也可以这么做：

    o = {};//创建一个普通的对象
    o[1] = "one";//用一个整数来索引它

数组的特别之处在于，当使用小于2的32次方非负整数作为属性名时数组会自动维护其length属性值。如上，创建仅有一个元素的数组。然后在索引1、2和3处分别进行赋值。当我们这么做时数组的length属性值变为：

    a.length //=>4

清晰地区分数组的索引和对象的属性名是非常有用的。所有的索引都是属性名，但只有在0~2的32次方减2之间的整数属性名才是索引。所有数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的length属性名。

注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性。当使用一个浮点数和一个整数相等时情况也是一样的：
```javascript
    a[-1.23] = true;//这将创建一个名为“-1.23”的属性
    a["1000"] = 0;//这是数组的第1001个元素
    a[1.000] //和a[1]相等
```
事实上，数组索引仅仅是对象属性名的一种特殊类型，这意味着javascript数组没有“越界”错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到undefined值。类似于对象，对于数组同样存在这种情况。

既然数组是对象，那么它们可以从原型中继承元素。在ECMAScript5中，数组可以定义元素的getter和setter方法（见6.6节）。如果一个数组确实继承了元素或使用了元素的getter和setter方法，你应该期望它使用非优化的代码路径：访问这种数组的元素的时间会与常规对象属性的查找时间相近。

**7.3稀疏数组**

稀疏数组是包含从0开始的不连续索引的数组。通常，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。可以用Array()构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组：
```javascript
a = new Array(5);//数组没有元素，但是a.length是5
a = [];//创建一个空数组，length是0
a[1000] = 0;//赋值添加一个元素，但是设置length为1001；
```
后面会看到你也可以用delete操作符来生产稀疏数组。
足够稀疏的数组通常在实现上比稠密的数组更慢，内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。

注意，当在数组直接量中省略值时不会创建稀疏数组。省略的元素在数组中是存在的，其值为undefined。这和数组元素根本不存在是有一些微妙的区别的。可以用in操作符检测两者之间的区别：
```javascript
var a1 = [,,,];//数组是[undefined,undefined,undefined]
var a2 = new Array(3);//该数组根本没有元素
0 in a1;//=>true a1在索引0处有一个元素
0 in a2;//=>false a2在索引0处没有元素
```
当使用for/in循环时，a1和a2之间的区别也很明显（7.6节）。
需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如[1,,3]）,这时多得到的数组也是稀疏数组，省略掉的值是不存在的：
```javascript
var a1 = [,];//此数组没有元素，长度是1
var a2 = [undefined];//此数组包含一个值为undefined的元素
0 in a1;//=> false a1在索引0处没有元素
0 in a2;//=> true a2在索引0处有一个值为undefined的元素
```
在一些旧版本的实现中（比如firefox3），在存在连续逗号的情况下，插入undefined值的操作则与此不同，在这些实现中，[1,,3]和[1,undefined,3]是一模一样的。

TODO：ECMAscript6有了变动

了解稀疏数组是了解javascript数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数javascript数组不是稀疏数组。并且，如果你确定碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样对待它们，只不过它们包含一些undefined的值。

**7.4数组长度**

每个数组有一个length属性，就是这个属性使其区别于常规的javascript对象。针对稠密（也就是非稀疏）数组，length属性值代表数组中元素的个数。其值比数组中最大的索引大1：
```javascript
[].length //=>0 数组没有元素
['a','b','c'].length //=>3 最大的索引为2，length为3
```
当数组是稀疏时，length属性值大于元素的个数。而且关于此我们可以说的一切也就是数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊行为。第一个如同上面的描述：如果为一个数组元素赋值，它的索引i大于或等于现有数组的长度时，length属性的值将设置为i+1;

第二个特殊的行为就是设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除：
```javascript
a = [1,2,3,4,5];//从第5个元素的数组开始
a.length = 3;//现在a为[1,2,3]
a.length = 0;//删除所有的元素。a为[]
a.length = 5;//长度为5，但是没有元素，就像new Array(5)
```
还可以将数组的length属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。
在ECMAScript5中，可以用Object.defineProperty()让数组的length属性变成只读的（见6.7节）：
```javascript
a = [1,2,3];//从3个元素的数组开始
Object.defineProperty(a,"length",{writable:false});//让length属性只读
a.length = 0;//a不会改变
```
类似地，如果让一个数组元素不可配置，就不能删除它。如果不能删除它，length属性不能设置为小于不可配置元素的索引值。（见6.7节和6.8.3节的Object.seal()和Object.freeze()方法。）

**7.5数组元素的添加和删除**

我们已经见过添加数组元素最简单的方法：为新索引赋值。
```javascript
a = [];//开始是一个空数组
a[0] = "zero";//然后向其中添加元素
a[1] = "one";
```
也可以用push()方法在数组末尾增加一个或多个元素：
```javascript
a = [];//开始是一个空数组
a.push("zero");//在末尾添加一个元素 a = ["zero"]
a.push("one","two");//再添加两个元素 a = ["zero","one","two"]
```
在数组尾部压入一个元素与给数组a[a.length]赋值是一样的。可以使用unshift()方法（在7.8节有描述）在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。

可以像删除对象属性一样使用delete运算符来删除数组元素：
```javascript
a = [1,2,3];
delete a[1];//a在索引1的位置不再有元素
1 in a      //=> false 数组索引1并未在数组中定义
a.length    //=> 3 delete操作并不影响数组长度
```
删除数组元素与为其赋值undefined值是类似的（但有一些微妙的区别）。注意，对一个数组元素使用delete不会修改数组的length属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组。

上面我们看到，也可以简单地设置length属性为一个新的期望长度来删除数组尾部的元素。数组有pop()方法（它和push()一起使用），后者一次使减少长度1并返回被删除元素的值。还有一个shift()方法（它和unshift()一起使用），从数组头部删除一个元素。和delete不同的是shift()方法将所有元素下移到比当前索引低1的地方。7.8节和第三部分涵盖pop()和shift()的内容。

**7.6数组遍历**

使用for循环（见5.5.3节）是遍历数组元素最常见的方法：
```javascript
var keys = Object.keys(o);//获得o对象属性名组成的数组
var values = [];//数组中存储匹配属性的值
for (var i = 0; i< keys.length; i++){//对于数组中每个索引
    var key = keys[i];//获得索引处的键值    
    values[i] = o[key];//在values数组中保存属性值
}
```
在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询：
```javascript
for(var i =0, len = keys.length; i < len; i++){
    //循环体仍然不变
}
```
这些例子假设数组是稠密的，并且所有的元素都是合法数据。否则，使用数组元素之前应该先检测它们。如果想要排除null、undefined和不存在的元素，代码如下：
```javascript
for (var i = 0 ;i < a.length; i++){
    if(!a[i]) continue;//跳过null、undefined和不存在的元素
    //循环体
}
```
如果只想跳过undefined和不存在的元素，代码如下：
```javascript
for(var i = 0; i<a.length; i++){
    if(a[i] === undefined) continue;//跳过undefined和不存的元素
    //循环体
}
```
最后，如果只想跳过不存在的元素而仍然要处理存在的undefined元素，代码如下：
```javascript
for(var i = 0; i < a.length; i++){
    if(!(i in a)) continue;//跳过不存在的元素
    //循环体
}
```
还可以使用for/in循环（见5.5.4节）处理稀疏数组。循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量。不存在的索引将不会遍历到：
```javascript
for(var index in sparseArray){
    var value = sparseArray[index];
    //此处可以使用索引和值做一些事情
}
```
在6.5节已经注意到for/in循环能够枚举继承的属性名，如添加Array.prototype中的方法。由于这个原因，在数组上不应该使用for/in循环，除非使用额外的检测方法来过滤不想要的属性。如下检测代码取其一即可：
```javascript
for (var i in o){
    if(!a.hasOwnProperty(i)) continue;//跳过继承的属性
    //循环体
}
for (var i in a){
    //跳过不是非负整数的i
    if(String(Math.floor(Math.abs(Number(i)))) !== i) continue;
}
```
ECMAScript规范允许for/in循环以不同的顺序遍历对象的属性。通常数组元素的遍历实现是升序的，但不能保证一定是这样的。特别地，如果数组同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现各不相同，如果算法依赖于遍历的顺序，那么最好不要使用for/in而用常规的for循环。

ECMAScript5定义了一些遍历数组元素的新方法，按照索引的顺序按个传递给定义的一个函数。这些方法中最常用的就是forEach()方法：
```javascript
var data = [1,2,3,4,5];//这是需要遍历的数组
var sumOfSquares = 0;//要得到数据的平方和
data.forEach(function(x){//把每个元素传递给此函数
    sumOfSquares += x*x;//平方相加
})；
sumOfSquares //=>55 1+4+9+16+25
```
forEach()和相关的遍历方法使得数组拥有简单而强大的函数式编程风格。它们涵盖在7.9节中，当涉及函数式编程时，还将在8.8节再次碰到它们。

**7.7多维数组**

javascript不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次[]操作符即可。
例如，假设变量matrix是一个数组的数组，它的基本元素是数值，那么matrix[x]的每个元素是包含一个数值数组，访问数组中特定数值的代码为matrix[x][y]。这里有一个具体的例子，它使用二维数组作为一个九九乘法表：
```javascript
//创建一个多维数组
var table = new Array(10);//表格有10行
for(var i = 0; i < table.length; i++)
table[i] = new Array(10);//每行有10列
//初始化数组
for(var row = 0; row < table.length; row++){
    for(col = 0; col < table[row].length; col++){
        table[row][col] = row*col;
    }
}
//使用多维数组来计算（查询）5*7
var product = table[5][7];//35
```

**7.8数组方法**

ECMAScript3在Array.prototype中定义了一些很有用的操作数组的函数，这意味着这些函数作为任何数组的方法都是可用的。下面几节介绍ECMAScript3中的这些方法。像通常一样，完整的细节参见第四部分关于数组内容。ECMAScript5中新增加了一些新的数组遍历方法：它们涵盖在7.9节中。

**7.8.1join()**

Array.join()方法将数组中所有元素都转化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生成的字符串中来分隔数组中的各个元素。如果不指定分隔符，默认使用逗号。如以下代码所示：
```javascript
var a = [1,2,3]//创建一个包含三个元素的数组
a.join();//=> "1,2,3"
a.join(" ")//=> "1 2 3"
a.join("");//=> "123"
var b = new Array(10);//长度为10的空数组
b.join('-');//=>'---------' 9个连字号组成的字符串
```
Array.join()方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。

**7.8.2reverse()**

Array.reverse()方法将数组中的元素颠倒顺序，返回逆序的数组。它采取了替换，换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列它们。例如，下面的代码使用reverse()和join()方法生成字符串“3，2，1”：
```javascript
var a = [1,2,3];
a.reverse().join() //=> "3,2,1" 并且现在的a是[3,2,1]
```

**7.8.3sort()**

Array.sort()方法将数组中的元素排序并返回排序后的数组。当不带参数调用sort()时，数组元素以字母表顺序排序（如有必要将临时转化为字符串进行比较）：
```javascript
var a = new Array("banana","cherry","apple");
a.sort();
var s = a.join(", ");//s == "apple, banana, cherry"
```
如果数组包含undefined元素，它们会被排到数组的尾部。
为了按照其他方式而非字母表顺序进行数组排序，必须给sort()方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。并且，假设两个值相等（也就是说，它们的顺序无关紧要），函数应该返回0。因此，例如，用数值大小而非字母表顺序进行数组排序，代码如下：
```javascript
var a = [33, 4, 1111, 222];
a.sort();//字母表顺序：111，22，33，4
a.sort(function(a,b) {//数值排序 4，33，222，1111
    return a-b;//根据顺序，返回负数、0、正数
})
a.sort(function (a,b){return b-a});//数值大小相反的顺序
```
注意，这里使用匿名函数表达式非常方便。既然比较函数只使用一次，就没必要给它们命名了。
另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将参数都转化为小写字符串（使用toLowerCase()方法），再开始比较：
```javascript
a = ['ant', 'Bug', 'cat', 'Dog'];
a.sort();//区分大小写的排序，['Bug','Dog','ant','cat']
a.sort(function(s,t){//不区分大小写的排序
    var a = s.toLowerCase();
    var b = t.toLowerCase();
    if(a < b) return -1;
    if(a > b) return 1;
    return 0;
});//=> ['ant','Bug','cat','Dog']
```

**7.8.4concat()**

Array.concat()方法创建并返回一个新数组，它的元素包括调用concat()的原始数组的元素和concat()的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat()不会递归扁平化数组的数组。concat()也不会修改调用的数组。下面有一些示例：
```javascript
var a = [1,2,3];
a.contact(4,5);//返回[1,2,3,4,5]
a.contact([4,5]);//返回[1,2,3,4,5]
a.contact([4,5],[6,7]);//返回[1,2,3,4,5,6,7]
a.contact(4,[5,[6,7]]);//返回[1,2,3,4,5,[6,7]]
```

**7.8.5slice()**

Array.slice()方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定的位置之间的所有数组元素。如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如参数中出现负数，它表示相对于数组中最后一个元素的位置。例如，参数-1指定了最后一个元素，而-3指定了倒数第三个元素。注意，slice()不会修改调用的数组。下面有一些示例：
```javascript
var a = [1,2,3,4,5];
a.slice(0,3);//返回[1,2,3]
a.slice(3);//返回[4,5]
a.slice(1,-1);//返回[2,3,4]
a.slice(-3,-2);//返回[3]
```

**7.8.6splice()**

Array.splice()方法是在数组中插入或删除元素的通用方法。不同于slice()和concat()，splice()会修改调用的数组。注意，splice()和slice()拥有非常相似的名字，但它们的功能却有本质的区别。

splice()能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分任然是保持连续的。splice()的第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素的个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice()返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：
```javascript
var a = [1,2,3,4,5,6,7,8];
a.splice(4);//返回[5,6,7,8]; a是[1,2,3,4]
a.splice(1,2);//返回[2,3]; a是[1,4]
a.splice(1,1);//返回[4]; a是[1]
```

splice()的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。例如：
```javascript
var a = [1,2,3,4,5];
a.splice(2,0,'a','b');//返回[]; a是[1,2,'a','b',3,4,5]
a.splice(2,2,[1,2],3);//返回['a','b']; a是[1,2,[1,2],3,3,4,5]
```
注意，区别于concat(),splice()会插入数组本身而非数组的元素。

**7.8.7push()和pop()**

push()和pop()方法允许将数组当做栈来使用。push()方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop()方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。注意，两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用push()和pop()能够用javascript数组实现先进后出的栈。例如：
```javascript
var stack = [];//stack: []
stack.push(1,2);//stack: [1,2] 返回2
stack.pop();//stack: [1] 返回2
stack.push(3);//stack: [1,3] 返回2
stack.pop();//stack: [1] 返回3
stack.push([4,5]);//stack: [1,[4,5]] 返回2
stack.pop();//stack: [1] 返回[4,5]
stack.pop();//stack: [] 返回1
```

**7.8.8unshift()和shift()**

unshift()和shift()方法的行为非常类似于push()和pop()，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。unshift()在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度，shift()删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如：
```javascript
var a = []; // a:[]
a.unshift(1);//a:[1]
a.unshift(22);//
a.shift();//
a.unshift(3,[4,5]);//
a.shift();//
a.shift();//
a.shift();//
```
注意，当使用多个参数调用unshift()时它的行为令人惊讶。参数是一次性插入的（就像splice（）方法）而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。

**7.8.9toString()和toLocaleString()**

数组和其他javascript对象一样拥有toString()方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的toString()方法）并且输出用逗号分隔的字符串列表。注意，输出不包括方括号或其他形式的包裹数组值的分隔符。例如：
```javascript
[1,2,3].toString()//
["a","b","c"].toString()//
[1,[2,'c']].toString()//
```
注意，这里与不使用任何参数调用join()方法返回的字符串是一样的。
toLocaleString()是toString()方法的本地化版本。它调用元素的toLocaleString()方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串。

**7.9ecmascript5中的数组方法**

ECMAScript5定义了9个新的数组方法来遍历、映射、过滤、检测、简化和搜素数组。下面几节描述了这些方法。
但在开始详细介绍之前，很有必要对ECMAScript5中的数组方法做一个概述。首先，大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，可以忽略后两个参数。大多数ECMAScript5数组方法的第一个参数是一个函数，第二个参数是可选的。如果有第二个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的this关键字的值来使用。被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。ECMAScript5中的数组方法都不会修改它们调用的原始数组。当然，传递给这些方法的函数是可以修改这些数组的。

**7.9.1forEach()**

forEach()方法从头至尾遍历数组，为每个元素调用指定的函数。如上所述，传递的函数作为forEach()的第一个参数。然后forEach()使用三个参数调用该函数：数组元素、元素的索引和数组本身。如果只关心数组元素的值，可以编写只有一个参数的函数——额外的参数将忽略：
```javascript
var data = [1,2,3,4,5];//
//计算数组元素的值
var sum = 0;//
data.forEach(function(value){sum +=value});//
sum //
//每个数组元素的值自加1
data.forEach(function(v,i,a){a[i]=v+1;});
data//
```
注意，forEach()无法在所有元素都传递给调用的函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try块中，并能抛出一个异常，如果forEach()调用的函数抛出foreach.break异常，循环会提前终止：
```javascript
function foreach(a,f,t) {
    try {a.forEach(f,t);}
    catch(e) {
        if(e === foreach.break) return;
        else throw e;
    }
}
foreach.break = new Error("StopIteration");
```

**7.9.2map()**

map()方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。例如：
```javascript
a = [1,2,3];
b = a.map(function(x){return x*x});// b是[1,4,9]
```
传递给map()的函数的调用方式和传递给forEach()的函数的调用方式一样。但传递给map()的函数应该有返回值。注意，map()返回的是新数组，它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。

**7.9.3filter()**

filter()方法返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的：
该函数返回true或false。调用判定函数就像调用forEach()和map()一样。如果返回值为true或能转化为true的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中。例如：
```javascript
a = [5,4,3,2,1];
smallvalues = a.filter(function(x){return x < 3});//
everyother = a.filter(function(x,i){return i%2 ==0});//
```
注意，filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：

    var dense = sparse.filter(function(){return true}):
    
甚至，压缩空缺并删除undefined和null元素，可以这样使用filter():

    a = a.filter(function(x){return x !== undefined && x != null;});

**7.9.4every()和some()**

every()和some()方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回true或false。
every()方法就像数学中的“针对所有”的量词：当且仅当针对数组中的所有元素调用判定函数都返回true，它才返回true：
```javascript
a = [1,2,3,4,5];
a.every(function(x){return x < 10})//=>true 所有的值<10
a.every(function(x){return x % 2 === 0})//=>false 不是所有的值都是偶数
```
some()方法就像数学中的“存在”的量词：当数组中至少有一个元素调用判定函数返回true，它就返回true：并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false：
```javascript
a = [1,2,3,4,5];
a.some(function(x){return x%2 ===0;})//=> true a含有偶数值
a.some(isNaN)//=> false a不包含非数值元素
```
注意，一旦every()和some()确认该返回什么值它们就会停止遍历数组元素。some()在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它就会遍历整个数组。every恰好相反：它在判定函数第一次返回false后就返回false，但如果判定函数一直返回true，它将会遍历整个数组。注意，根据数学上的惯例，在空数组上调用时，every()返回true，some()返回false。

**7.9.5 reduce()和reduceRight()**

reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。举例说明它是如何工作的：
```javascript
var a = [1,2,3,4,5]
var sum = a.reduce(function(x,y) { return x+y }, 0);//数组求和
var product = a.reduce(function(x,y) { return x*y }, 1);//数组求积
var max = a.reduce(function(x,y) { return (x>y)?x:y; });//求最大值
```
reduce()需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。

reduce()使用的函数与forEach()和map()使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第2~4个参数传递给函数。第一个参数是到目前为止的化简操作累积的结果。第一次调用函数时，第一个参数是一个初始值，它就是传递给reduce()的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。在上面的第一个例子中，第一次调用化简函数时的参数是0和1。将两者相加并返回1.再次调用时的参数是1和2，它返回3。然后它计算3+3=6、6+4=10，最后计算10+5=15。最后的值是15，reduce()返回这个值。

可能已经注意到了，上面第三次调用reduce()时只有一个参数：没有指定初始值。当不指定初始值调用reduce()时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和与求积的例子中，可以省略初始值参数。

在空数组上，不带初始值参数调用reduce()将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值——reduce()只是简单地返回那个值而不会调用化简函数。

reduceRight()的工作原理和reduce()一样，不同的是它按照数组索引从高到低（从右到左）处理数组，而不是从低到高。如果化简操作的优先顺序是从右到左，你可能想使用它，例如：
```javascript
var a = [2,3,4]
//计算2^(3^4)。乘方操作的优先顺序是从右到左
var big = a.reduceRight(function(accumulator,value){
    return Math.pow(value,accumulator);
});
```
注意，reduce()和reduceRight()都能接收一个可选的参数，它指定了化简函数调用时的this关键字的值。可选的初始值参数仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，请参看Function.bind()方法。
值得注意的是，上面描述的every()和some()方法是一种类型的数组化化简操作。但是不同的是，它们会尽早终止遍历而不总是访问每一个数组元素。
为了简单起见，到目前位置所展示的例子都是数值的，但数学计算不是reduce()和reduceRight()的唯一意图。考虑一下例6-2中的union()函数。它计算两个对象的“并集”，并返回另一个新对象，新对象具有二者的属性。该函数期待两个对象并返回另一个对象，所以它的工作原理和一个化简函数一样，并且可以使用reduce()来把它一般化，计算任意数目的对象的“并集”。
```javascript
var objects = [{x:1}, {y:2}, {z:3}]
var merged = objects.reduce(union);//=> {x:1, y:2, z:3}
```
回想一下，当两个对象拥有同名的属性时，union()函数使用第一个参数的属性值。这样，reduce()和reduceRight()在使用union()时给出了不同的结果
```javascript
var objects = [{x:1,a:1},{y:2,a:2},{z:3,a:3}];
var leftunion = objects.reduce(union);//{x:1, y:2, z:3, a:1}
var leftunion = objects.reduceRight(union);//{x:1, y:2, z:3, a:3}
```

**7.9.6indexOf()和lastIndexOf()**

indexOF()和lastIndexOf()搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。indexOf()从头至尾搜索，而lastIndexOf()则反向搜索。
```javascript
a = [0,1,2,1,0]
a.indexOf(1) //=>1 a[1]是1
a.lastIndexOf(1) //=>3 a[3]是1
a.indexOf(3) //=>-1 没有值为3的元素
```
不同于本节描述的其他方法，indexOf()和lastIndexOf()方法不接收一个函数作为其参数。第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索。如果省略该参数，indexOf()从头开始搜索，而lastIndexOf()从末尾开始搜索。第二个参数也可以是负数，它代表相对数组末尾的偏移量，对于splice()方法：例如，-1指定数组的最后一个元素。

如下函数在一个数组中搜索指定的值并返回包含所有匹配的数组索引的一个数组。它展示了如何运用indexOf()的第二个参数来查找除了第一个以外匹配的值。
```javascript
//在数组中查找所有出现的x，并返回一个包含匹配索引的数组
function findall(a,x) {
    var results = [],//将会返回的数组
    len = a.length,//待搜索数组的长度
    pos = 0;//开始搜索的位置
    while(pos<len){//循环搜索多个元素
        pos = a.indexOf(x,pos);//搜索
        if(pos === -1) break;//未找到，就完成搜索
        results.push(pos);//否则，在数组中存储索引
        pos = pos + i;//并从下一个位置开始搜索
    }
    return results;//返回包含索引的数组
}
```
注意，字符串也有indexOf()和lastIndexOf()方法，它们和数组方法的功能类似。

**7.10数组类型**

我们在本章中到处都可以看见数组是具有特殊行为的对象。给定一个未知的对象，判定它是否为数组通常非常有用。在ECMASCript5中，可以使用Array.isArray()函数来做这件事：
```javascript
Array.isArray([])//=>true
Array.isArray({})//=>false
```
但是，在ECMAScript5以前，要区分数组和非数组对象却令人惊讶地困难。typeof操作符在这里帮不上忙：对数组它返回“对象”（并且对于除了函数以外的所有对象都是如此）。instanceof操作符只能用于简单的情形：
```javascript
[] instanceof Array //=>true
({}) instanceof Array //=>false
```
使用instanceof的问题是在web浏览器中有可能有多个窗口或窗体（frame）存在。每个窗口都有自己的javascript环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足已证明instanceof操作符不能视为一个可靠的数组检测方法。

解决方案是检查对象的类属性（见6.8.2节）。对数组而言该属性的值总是“Array”，因此在ECMASCript3中isArray()函数的代码可以这样书写：
```javascript
var isArray = function.isArray || function(o) {
    return typeof o === "Object" && Object.prototype.toString.call(o) === "[object Array]";
};
```
实际上，此处类属性的检测就是ECMAScript5中Array.isArray()函数所做的事情。获得对象类属性的技术使用了6.8.2节和例6-4中展示的Object.prototype.toString()方法。

**7.11类数组对象**

我们已经看到，javascript数组的有一些特性是其他对象所没有的：

* 当有新的元素添加到列表中时，自动更新length属性。
* 设置length为一个较小值将截断数组
* 从Array.prototype中继承一些有用的方法。
* 其类属性为“Array”

这些特性让javascript数组和常规的对象有明显的区别。但是它们不是定义数组的本质特性。一种常常完全合理的看法把拥有一个数值length属性和对应非负整数属性的对象看做一种类型的数组。

实践中这些“类数组”对象实际上偶尔出现，虽然不能在它们之上直接调用数组方法或者期望length属性有什么特殊的行为，但是仍然可以用针对真正数组遍历的代码来遍历它们。结论就是很多数组算法针对类数组对象工作得很好，就像针对真正的数组一样。如果算法把数组看成只读的或者如果它们至少保持数组长度不变，也尤其是这种情况。

以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”：
```javascript
var a = {};//从一个常规空对象开始
//添加一些属性，称为“类数组”
var i = 0;
while(i<10) {
    a[i] = i*i;
    i++;
}
a.length = i;
//现在，当做真正的数组遍历它
var total = 0;
for(var j = 0; j<a.length; j++){
    total += a[j];
}
```
8.3.2节描述的Arguments对象就是一个类数组对象。在客户端javascript中，一些DOM方法（如document.getElementsByTagName()）也返回类数组对象。下面有一个函数可以用来检测类数组对象：
```javascript
//判定o是否是一个类数组对象
//字符串和函数有length属性，但是它们
//可以用typeof检测将其排除。在客户端javascript中，DOM文本节点
//也有length属性，需要用额外判断o.nodeType != 3 将其排除
function isArrayLike(o) {
    if( o &&                                //o非null、undefined等
        typeof o === "object" &&            //o是对象
        isFinite(o.length)&&                //o.length是有限数值
        o.length >= 0 &&                    //o.length为非负值
        o.length === Math.floor(o.length) &&//o.length是整数
        o.length < 4294967296)              //o.lenght<2^32
        return true;                        //o是类数组对象
    else
        return false;                       //否则它不是
}
```
将在7.12节中看到在ECMAScript5中字符串的行为与数组类似（并且有些浏览器在ECMAScript5之前已经让字符串变成索引的了）。然而，类似上述的类数组对象的检测方法针对字符串常常返回false——它们通常最好当做字符串处理，而非数组。

javascript数组方法是特意定义为通用的，因此它们不仅应用在真正的数组而且在类数组对象上都能正确工作。在ECMAScript5中，所有数组方法都是通用的。在ECMAScript3中，除了toString()和toLocaleString()以外的所有方法也是通用的。（concat()方法是一个特例：虽然可以用在类数组对象上，但它没有将那个对象扩充进返回的数组中。）既然类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。尽管如此，可以间接地使用function.call方法调用：
```javascript
var a = {"0":"a", "1":"b", "2":"c", lenght:3};//类数组对象
Array.join(a,"+")
Array.slice(a,0)
Array.map(a,function(x){return x.toUpperCase();})
```
当用在类数组对象上时，数组方法的静态函数版本非常有用。但既然它们不是标准的，不能期望它们在所有的浏览器中都有定义。可以这样书写代码来保证使用它们之前是存在的：
```javascript
Array.join = Array.join || function (a,sep) {
    return Array.prototype.join.call(a,sep);
};
Array.slice = Array.slice || function (a,from,to) {
    return Array.prototype.slice.call(a,from,to);
};
Array.map = Array.map || function (a,f,thisArg) {
    return Array.prototype.map.call(a,f,thisArg);
};
```

**7.12作为数组的字符串**

在ECMAscript5（在众多最近的浏览器实现——包括IE8——早于ECMAScript5）中，字符串的行为类似于只读的数组。除了用charAt()方法来访问单个的字符以外，还可以使用方括号：
```javascript
var s = test;
s.charAt(0) //=>"t"
s[1] //=>"e"
```
当然，针对字符串的typeof操作符仍然返回“string”，但是如果给Array.isArray()传递字符串，它将返回false。

可索引的字符串的最大的好处就是简单，用方括号代替了charAt()调用，这样更加简洁、可读并且可能更高效。不仅如此，字符串的行为类似于数组的事实使得通用的数组方法可以应用到字符串上。例如：
```javascript
s = "javascript"
Array.prototype.join.call(s,"") //=>"J a v a S c r i p t"
Array.prototype.filter.call(s,  //过滤字符串中的字符
    function(x) {
    return x.match(/[^aeiou]/);//只匹配非元音字母
    }).join("") //=> "JvScrpt"
```
请记住，字符串是不可变值，故当把它们作为数组看待时，它们是只读的。如push()、sort()、reverse()和splice()等数组方法会修改数组，它们在字符串上是无效的。不仅如此，使用数组方法来修改字符串会导致错误：出错的时候没有提示。

函数
----

函数是这样的一段javascript代码，它只定义一次，但可能被执行或调用任意次。你可能已经从诸如子例程（subroutine）或者过程（proceduew）这些名字里对函数的概念有所了解。javascript函数是参数化的：函数的定义会包括一个称为形参（patamer）的标识符列表，这些参数在函数体中像局部变量一样工作。函数调用会为形参提供实参的值。（参数有形参（parameter）和实参（argument）的区别，形参相当于函数中定义的变量，实参是在运行时的函数调用时传入的参数）函数使用它们实参的值来计算返回值，成为该函数调用表达式的值。除了实参之外，每次调用还会拥有另一个值——本次调用还会拥有另一个值——本次调用的上下文——这就是this关键字的值。

如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文（context），也就是该函数的this的值。用于初始化一个新创建的对象的函数称为构造函数（constructor）。6.1节会对构造函数有进一步的讲解，第9章还会再谈到它。

在javascript里，函数即对象，程序可以随意操控它们。比如，javascript可以把函数赋值给变量，或者作为参数传递给其他函数。因为函数就是对象，所以可以给它们设置属性，甚至调用它们的方法。

javascript的函数可以嵌套在其他函数中定义的，这样它们就可以访问它们被定义时所处的作用域中的任何变量。这意味着javascript函数构成了一个闭包（closure），它给javascript带来了非常强劲的编程能力。

**8.1函数定义**

函数使用function关键字来定义，它可以用在函数定义表达式（见4.3节）或者函数声明语句（见5.3.2节）里。在两种形式中，函数定义都从function关键字开始，其后跟随这些组成部分：

* 函数名称标识符。函数名称是函数声明语句必需的部分。它的用途就像变量的名字，新定义的函数对象会赋值给这个变量。对函数定义表达式来说，这个名字是可选的：如果存在，该名字只存在于函数体中，并指代表函数对象本身。
* 一对圆括号，其中包含由0个或者多个用逗号隔开的标识符组成的列表。这些标识符是函数的参数名称，它们就像函数体中的局部变量一样。
* 一对花括号，其中包含0条或多条javascript语句。这些语句构成了函数体：一旦调用函数，就会执行这些语句。

例8-1分别展示了函数语句和表达式两种方式的函数定义。注意，以表达式来定义函数只适用于它作为一个大的表达式的一部分，比如在赋值和调用过程中定义函数：
例8-1：定义javascript函数
```javascript
// Print the name and value of each property of o.  Return undefined.
//输出o的每个属性的名称和值，返回undefined
function printprops(o) {
    for(var p in o) 
        console.log(p + ": " + o[p] + "\n"); 
}

// Compute the distance between Cartesian points (x1,y1) and (x2,y2).
//计算两个笛卡尔坐标(x1,y1)和(x2,y2)之间的距离
function distance(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    return Math.sqrt(dx*dx + dy*dy);
}

// A recursive function (one that calls itself) that computes factorials
// Recall that x! is the product of x and all positive integers less than it.
//计算阶乘的递归函数（调用自身的函数）
//x!的值是从x到x递减（步长为1）的值的类乘
function factorial(x) {
    if (x <= 1) return 1;
    return x * factorial(x-1);
}

// This function expression defines a function that squares its argument.
// Note that we assign it to a variable
//这个函数表达式定义了一个函数用来求传入参数的平方
//注意我们把它赋值给一个变量
var square = function(x) { return x*x; }

// Function expressions can include names, which is useful for recursion.
//函数表达式可以包含名称，这在递归时很有用
var f = function fact(x) { if (x <= 1) return 1; else return x*fact(x-1); };

// Function expressions can also be used as arguments to other functions:
//函数表达式也可以作为参数传给其他函数
data.sort(function(a,b) { return a-b; });

// Function expressions are sometimes defined and immediately invoked:
//函数表达式有时定义后立即调用
var tensquared = (function(x) {return x*x;}(10));
```
注意：以表达式方式定义的函数，函数的名称是可选的。一条函数声明语句实际上声明了一个变量，并把一个函数对象赋值给它。相对而言，定义函数表达式时并没有声明一个变量。函数可以命名，就像上面的阶乘函数，它需要一个名称来指代自己。如果一个函数定义表达式包含名称，函数的局部作用域将会包含一个绑定到函数对象的名称。实际上，函数的名称将成为函数内部的一个局部变量。通常而言，以表达式方式定义函数时都不需要名称，这会让定义它们的代码更为紧凑。函数定义表达式特别适合用来定义那些只会用到一次的函数，比如上面展示的最后两个例子。

函数命名：
任何合法的javascript标识符都可以用做一个函数的名称。命名时要尽量选择描述性强而又简洁的函数名。在这两者之间做到恰到好处是一门艺术，需要丰富的经验。精心挑选的函数名可以极大地改善代码的可读性（从而也提高了可维护性）。
函数名称通常是动词或以动词为前缀的词组。通常函数名的第一个字符为小写，这是一种编程的约定。当函数名包含多个单词时，一种约定是将单词以下划线分隔，就像like_this()。还有另外一种约定，就是除了第一个单词之外的单词首字母使用大写字母，就像likeThis()。有一些函数是用做内部函数或私有函数（不是作为公用API的一部分），这种函数名通常以一条下划线为前缀。
在一些编程风格中，或者编程框架里，通常为那些经常调用的函数指定短名称，比如客户端javascript框架jQuery（第19章会详细讲述）就将最常用的方法重命名为$()（一个美元符号）（2.4节提到，美元符号和下划线是除了字母和数字之外的两个合法的javascript标识符）

如5.3.2节所述，函数声明语句“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。不过，以表达式定义的函数就另当别论了，为了调用一个函数，必须要能引用它，而要使用一个以表达式方式定义的函数之前，必须把它赋值给一个变量。变量的声明提前了（参见3.10.1节），但给变量赋值是不会提前的，所以，以表达式方式定义的函数在定义之前无法调用。

请注意，例8-1中的大多数函数都是用来计算出一个值的，它们使用return把值返回给调用者。而printprops()函数的不用之处在于，它的任务是输出对象各属性的名称和值。没有必要返回值，该函数不包含return语句。printprops()函数的返回值始终是undefined。（没有返回值的函数有时称为过程）

嵌套函数：
在javascript里，函数可以嵌套在其他函数里。例如：
```javascript
function hypotenuse(a,b) {
    function square(x) {return x*x}
    return Math.sqrt(square(a) + square(b));
}
```
嵌套函数的有趣之处在于它的变量作用域规则：它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量。例如：在上面的代码里，内部函数square()可以读写外部函数hypotenuse()定义的参数a和b。这些作用域规则对内嵌函数非常重要，我们会在8.6节再深入了解它们。

5.3.2节曾提到，函数声明语句并非真正的语句，ECMAScript规范只是允许它们作为顶级语句。它们可以出现在全局代码里，或者内嵌在其他函数中，但它们不能出现在循环、条件判断，或者try/cache/finally以及with语句中。（有些javascript的实现并未严格遵守这条规则，比如，Firefox就允许在if语句中出现条件函数声明）注意，此限制仅适用于以语句声明形式定义的函数。函数定义表达式可以出现在javascript代码的任何地方。

**8.2函数调用**

构成函数主体的javascript代码在定义之时并不会执行，只有调用该函数时，它们才会执行。有4种方式来调用javascript函数：

* 作为函数
* 作为方法
* 作为构造函数
* 通过它们的call()和apply()方法间接调用

**8.2.1函数调用**

使用调用表达式可以进行普通的的函数调用也可进行方法调用（见4.5节）。一个调用表达式由多个函数表达式组成，每个函数表达式都是由一个函数对象和左圆括号、参数列表和右圆括号组成，参数列表是由逗号分隔的零个或多个参数表达式组成。如果函数表达式是一个属性访问表达式，即该函数是一个对象的属性或数组中的一个元素，那么它就是一个方法调用表达式。下面将会解释这种情形。下面的代码展示了一些普通的函数调用表达式：
```javascript
printprops({x:1});
var total = distance(0,0,2,1) + distance(2,1,3,5);
var probability = factorial(5)/factorial(13)
```
在一个调用中，每个参数表达式（圆括号之间的部分）都会计算出一个值，计算的结果作为参数传递给另外一个函数。这些值作为实参传递给声明函数时定义的形参。在函数体中存在一个形参的引用，指向当前传入的实参列表，通过它可以获得参数的值。

对于普通的函数调用，函数的返回值成为调用表达式的值。如果该函数返回是因为解释器到达结尾，返回值就是undefined。如果函数返回是因为解释器执行到一条return语句，返回值就是return之后的表达式的值，如果return语句没有值，则返回undefined。

根据ECMAScript3和非严格的ECMAScript5对函数调用的规定，调用上下文（this的值）是全局对象。然而，在严格模式下，调用的上下文则是undefined。
以函数形式调用的函数通常不使用this关键字。不过，“this”可以用来判断当前是否是严格模式。
```javascript
//定义并调用一个函数来确定当前脚本运行时是否为严格模式
var strict = (function(){return !this;}());
```

**8.2.2方法调用**

一个方法无非是个保存在一个对象的属性里的javascript函数。如果有一个函数f和一个对象o，则可以用下面的代码给o定义一个名为m()的方法：

    o.m = f;
    
给对象o定义了方法m()，调用它时就像这样：

    o.m();
    
或者，如果m()需要两个实参，调用起来则像这样：

    o.m(x,y);

上面的代码是一个调用表达式：它包括一个函数表达式o.m，以及两个实参表达式x和y，函数表达式本身就是一个属性访问表达式（见4.4节），这意味着该函数被当做一个方法，而不是作为一个普通函数来调用。

对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即：调用上下文。属性访问表达式由两部分组成：一个对象（本例中的o）和属性名称（m）。在像这样的方法调用表达式里，对象o成为调用上下文，函数体可以使用关键字this引用该对象。下面是一个具体的例子：
```javascript
var calculator = {//对象直接量
    operand1:1,
    operand2:1,
    add: function() {
    //注意this关键字的用法，this指代当前对象
        this.result = this.operand1 + this.operand2;
    }
};
calculator.add();//这个方法调用计算i+1的结果
calculator.result;//=>2
```
大多数方法调用使用点符号来访问属性，使用方括号（的属性访问表达式）也可以进行属性访问操作。下面两个例子都是函数调用：
```javascript
o["m"](x,y);//o.m(x,y)的另外一种写法
a[0](z)//同样是一个方法调用（这里假设a[0]是一个函数）
```

方法调用可能包括更复杂的属性访问表达式：
```javascript
customer.surname.toUpperCase();//调用customer.surname的方法
f().m();//在f()调用结束后继续调用返回值中的方法m()
```
方法和this关键字是面向对象编程范例的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参——这个实参是一个对象，方法调用的母体就是这个对象。通常来讲，基于那个对象的方法可以执行多种操作，方法调用的语法已经很清晰地表明了函数将基于一个对象进行操作，比较下面两行代码：
```javascript
rect.setSize(width,height);
setRectSize(rect,width,height);
```
我们假设这两行代码的功能完全一样，它们都作用于一个假定的对象rect。可以看出，第一行的方法调用语法非常清晰地表明这个函数执行的载体是rect对象，函数中的所有操作都将基于这个对象。

**8.2.3构造函数调用**
如果函数或方法调用之前带有关键字new，它就构成构造函数调用（构造函数调用在4.6节和6.1.2节有简单介绍，[类和模块](#类和模块)这章会对构造函数做更详细地讨论）。构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。

如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内，这和函数调用和方法调用是一致的。但如果构造函数没有形参，javascript构造函数调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号，比如，下面这两行代码是等价的：
```javascript
var o = new Object();
var o = new Object;
```
构造函数调用创建一个新的空对象，这个对象继承自构造函数的prototype属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数可以使用this关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式new o.m()中，调用上下文并不是o。

构造函数通常不使用return关键字，它们通常初始化新对象。当构造函数的函数体执行完毕时，它会显示返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显示地使用return语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。

**8.2.4间接调用**

javascript中的函数也是对象，和其他javascript对象没什么两样，函数对象也可以包含方法。其中的两个方法call()和apply()可以用来间接地调用函数。两个方法都允许显式指定调用所需的this值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。call()方法使用它自有的实参列表作为函数的实参，apply()方法则要求以数组的形式传入参数。8.7.3节会有关于call()和apply()方法的详细讨论。

**8.3函数的实参和形参**

javascript中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。实际上，javascript函数调用甚至不检查传入形参的个数。下面几节将会讨论当调用函数时的实参个数和声明的形参个数不匹配时出现的状况，同样说明了如何显式测试函数实参的类型，以避免非法的实参传入函数。

**8.3.1可选形参**

当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。因此在调用函数时形参是否可选以及是否可以省略应当保持较好的适应性。为了做到这一点，应当给省略的参数赋一个合理的默认值，来看这个例子：
```javascript
//将对象o中可枚举的属性名追加至数组a中，并返回这个数组a
//如果省略a，则创建一个新数组并返回这个新数组
function getPropertyNames(o,/*optional*/ a){
    if(a === undefined) a = [];//如果未定义，则使用新数组
    for(var property in o) a.push(property);
    return a;
}
//这个函数调用可以传入1个或2个实参
var a = getPropertyNames(o);//将o的属性存储到一个新数组中
getPropertyNames(p,a);//将p的属性追加至数组a中
```
如果在第一行代码中不使用if语句，可以使用“||”运算符，这是一种习惯用法：
```javascript
a = a || [];
```
回忆一下，4.10.2节介绍了“||”运算符，如果第一个实参是真值的话就返回第一个实参；否则返回第二个实参。在这个场景下，如果作为第二个实参传入任意对象，那么函数就会使用这个对象。如果省略掉第二个实参（或者传递null以及其他任何值），那么就新创建一个空数组，并赋值给a。

需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没办法省略第一个实参并传入第二个实参的，它必须将undefined作为第一个实参显式传入。同样注意在函数定义中使用注释/*optional*/来强调形参是可选的。

**8.3.2可变长的实参列表：实参对象**

当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用。参数对象解决了这个问题。在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象（参照7.11节），这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。

假设定义了函数f，它的实参只有一个x。如果调用这个函数时传入两个实参，第一个实参可以通过参数名x来获得，也可以通过arguments[0]来得到。第二个实参只能通过arguments[i]来得到。此处，和真正数组一样，arguments也包含一个length属性，用以标识其所包含元素的个数。因此，如果调用函数f()时传入两个参数，arguments.length的值就是2。

实参对象在很多地方都非常有用，下面的例子展示了使用它来验证实参的个数，从而调用正确的逻辑，因为javascript本身不会这么做：
```javascript
function f(x,y,z) {
    //首先，验证传入实参的个数是否正确
    if(arguments.length != 3) {
        throw new Error("function f called with" + arguments.length + "arguments, but it expects 3 arguments.");
    }
    //再执行函数的其他逻辑…
}
```

需要注意的是，通常不必像这样检查实参个数。大多数情况下javascript的默认行为是可以满足需要的：省略的实参都将是undefined，多出的参数会自动忽略。

实参对象有一个重要的用处，就是让函数可以操作任意数量的实参。下面的函数就可以接收任意数量的实参，并返回传入实参的最大值（内置函数Max.max()的功能与之类似）：
```javascript
function max(/**/) {
    var max = Number.NEGATIVE_INFINITY;
    //遍历实参，查找并记住最大值
    for (var i= 0; i < arguments.length; i++){
        if(arguments[i] > max) max = arguments[i];
    //返回最大值
    return max;
    }
}
var largest = max(i, 10, 100, 2, 3, 1000, 4, 5, 10000, 6);//=>10000
```
类似这种函数可以接收任意个数的实参，这种函数也称为“不定实参函数”（varargs function），这个术语源自古老的C语言。

注意，不定实参函数的实参个数不能为零，arguments[]对象最适合的应用场景是在这样一类函数中，这类函数包含固定个数的命名和必需参数，以及随后个数不定的可选实参。

记住，arguments并不是真正的数组，它是一个实参对象。每个实参对象都包含以数字为索引的一组元素以及length属性，但它毕竟不是真正的数组。可以这样理解，它是一个对象，只是碰巧具有以数字为索引的属性。参照7.11节以获得更多关于类数组对象的信息。

数组对象包含一个非同寻常的特性。在非严格模式下，当一个函数包含若干形参，实参对象的数组元素是函数形参所对应实参的别名，实参对象中以数字为索引，并且形参名称可以认为是相同变量的不同命名。通过实参名字来修改实参值的话，通过arguments[]数组也可以获得到更改后的值，下面这个例子清除地说明了这一点：
```javascript
function f(x) {
    console.log(x);//输出实参的初始值
    arguments[0] = null;//修改实参数组的元素同样会修改x的值
    console.log(x);//输出“null”
}
```
如果实参对象是一个普通数组的话，第二条console.log(x)语句的结果绝对不会是null，在这个例子中，arguments[0]和x指代同一个值，修改其中一个的值会影响到另一个。
在ECMAScript5中移除了实参对象的这个特殊特性。在严格模式下还有一点（和非严格模式下相比的）不同，在非严格模式中，函数里的arguments仅仅是一个标识符，在严格模式中，它变成了一个保留字。严格模式中的函数无法使用arguments作为形参名或局部变量名，也不能给arguments赋值。

callee和caller属性：
除了数组元素，实参对象还定义了callee和caller属性。在ECMAScript5严格模式中，对这两个属性的读写操作都会产生一个类型错误。而在非严格模式下，ECMAScript标准规范规定callee属性指代当前正在执行的函数。caller是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过caller属性可以访问调用栈。callee属性在某些时候会非常有用，比如在匿名函数中通过callee来递归地调用自身。
```javascript
var factorial = function(x) {
    if(x <= 1) return 1;
    return x*arguments.callee(x-1);
}
```

**8.3.3将对象属性用做实参**

当一个函数包含超过三个形参时，对于程序员来说，要记住调用函数中实参的正确顺序实在让人头疼。每次调用这个函数时都要不厌其烦地查阅文档，为了不让程序员每次都翻阅手册这么麻烦，最好通过名/值对的形式传入参数，这样参数的顺序就无关紧要了。为了实现这种风格的方法调用，定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据。下面的代码就展示了这种风格的函数调用，这种写法允许在函数中设置省略参数的默认值：
```javascript
//将原始数组的length元素复制至目标数组
//开始复制原始数组的from_start元素
//并且将其复制至目标数组的to_start中
//要记住实参的顺序并不容易
function arraycopy(/*array*/from,/*index*/from_start,/*array*/to,/*index*/to_start,/*integer*/length)
{
    //逻辑代码
}
//这个版本的实现效率稍微有些低，但你不必再去记住实参的顺序
//并且from_start和to_start都默认为0
function easycopy(args) {
    arraycopy(args.from,
              args.from_start||0,//注意这里设置了默认值
              args.to,
              args.to_start||0,args.length);
}
//来看如何调用easycopy()
var a = [1, 2, 3, 4], b = [];
easycopy({ from: a, to:b, length: 4 });
```

**8.3.4实参类型**

javascript方法的形参并未声明类型，在形参传入函数体之前也未做任何类型检查。可以采用语义化的单词来给函数实参命名，或者像刚才的示例代码中的arraycopy()方法一样给实参补充注释，以此使代码自文档化，对于可选的实参来说，可以在注释中补充一下“这个实参是可选的”。当一个方法可以接收任意数量的实参时，可以使用省略号：
```javascript
function max(/*number...*/){/*代码区*/}
```
3.8节已经提到，javascript在必要的时候会进行类型转换。因此如果函数期望接收一个字符串实参，而调用函数时出入其他类型的值，所传入的值会在函数体内将其用做字符串的地方转换为字符串类型。所有的原始类型都可以转换为字符串，所有的对象都包含toString()方法（尽管不一定有用），所以这种场景下是不会有任何错误的。

然而事情不总是这样，回头看一下刚才提到的arraycopy()方法。这个方法期望它的第一个实参是一个数组。当传入一个非数组的值作为第一个实参时（通常会传入类数组对象），尽管看起来是没有问题的，实际上会出错。除非所写的函数是只用到一两次的“用完即丢”函数，你应当添加类似的实参类型检查逻辑，因为宁愿程序在传入非法值时报错，也不愿非法值导致程序在执行时报错，相比而言，逻辑执行时的报错消息不甚清晰且更难处理。下面这个例子中的函数就做了这种类型检查。注意这里使用了7.11节的isArrayLike()函数：
```javascript
//返回数组（或类数组对象）a的元素的累加和
//数组a中必须为数字，null和undefined的元素都将忽略
function sum(a) {
    if(isArrayLike(a)) {
        var total = 0;
        for (var i = 0; i< a.length; i++){ //遍历所有元素
            var element = a[i];
            if(element == null) continue; //要跳过null和undefined
            if(isFinite(element)) total += element;
            else throw new Error("sum():elements must be finite numbers");
        }
        return total;
    }
    else throw new Error("sum():argument must be array-like");
}
```
这里的sum()方法进行了非常严格的实参检查，当传入非法的值时会给出容易看懂的错误提示信息。但当涉及类数组对象和真正的数组（不考虑数组元素是否是null还是undefined），这种做法带来的灵活性其实并不大。

javascript是一种非常灵活的弱类型语言，有时适合编写实参类型和实参个数的不确定性的函数。接下来的flexisum()方法就是这样（可能走向了一个极端）。比如，它可以接受任意数量的实参，并可以递归地处理实参是数组的情况，这样的话，它就可以用做不定实参函数或者实参是数组的函数。此外，这个方法尽可能的在抛出异常之前将非数字转换为数字：
```javascript
function flexisum(a) {
    var total = 0;
    for (var i=0; i < arguments.length; i++) {
        var element = arguments[i],n;
        if(element == null) continue;//忽略null和undefined实参
        if(isArray(element)) //如果实参是数组
            n = flexisum.apply(this,element);//递归地计算累加和
        else if (typeof element === "function")//否则，如果是函数…
            n = Number(element());//调用它并做类型转换
        else
            n = Number(element);//否则直接做类型转换
        if (isNaN(n)) //如果无法转换为数字，则抛出异常
            throw Error("flexisum(): can't convert" + element + "to number");
        total += n;//否则，将n累加至total
    }
    return total;
}
```


**8.4作为值的函数**

函数可以定义，也可以调用，这是函数最重要的特性。函数定义和调用是javascript的词法特性，对于其他大多数编程语言来说亦是如此。然而在javascript中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数等。

为了便于理解javascript中的函数是如何用做数据的以及javascript语法，来看一下这样一个函数定义：
```javascript
function square(x) { return x*x; }
```
这个定义创建一个新的函数对象，并将其赋值给变量square。函数的名字实际上是看不见的，它（square）仅仅是变量的名字，这个变量指代函数对象。函数还可以赋值给其他的变量，并且仍可以正常工作：
```javascript
var s = square;//现在s和square指代同一个函数
square(4);//=> 16
s(4);//=> 16
```
除了可以将函数赋值给变量，同样可以将函数赋值给对象的属性。当函数作为对象的属性调用时，函数就称为方法：
```javascript
var o = {square: function(x) {return x*x}};//对象直接量
var y = o.square(16);//y等于256
```
函数甚至不需要带名字，当把它们赋值给数组元素时：
```javascript
var a = [function(x) {return x*x;},20];//数组直接量
a[0](a[1]);//=>400
```
最后一句代码看起来很奇怪，但的确是合法的函数调用表达式！
例8-2展示了将函数用做值时的一些例子，这段代码可能会难读一些，但注释解释了代码的具体含义：
例8-2：将函数用做值
```javascript
// We define some simple functions here，在这里定义了一些简单的函数
function add(x,y) { return x + y; }
function subtract(x,y) { return x - y; }
function multiply(x,y) { return x * y; }
function divide(x,y) { return x / y; }

// Here's a function that takes one of the above functions，这里的函数以上面的某个函数作为参数
// as an argument and invokes it on two operands，并给它传入两个操作数然后调用它
function operate(operator, operand1, operand2) {
    return operator(operand1, operand2);
}

// We could invoke this function like this to compute the value (2+3) + (4*5):
// 这行代码所示的函数调用实际上计算了(2+3) + (4*5)的值
var i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));

// For the sake of the example, we implement the simple functions again, 
// this time using function literals within an object literal;
// 我们为这个例子重复实现一个简单的函数，这次实现使用函数直接量，这些函数直接量定义在一个对象直接量中
var operators = {
    add:      function(x,y) { return x+y; },
    subtract: function(x,y) { return x-y; },
    multiply: function(x,y) { return x*y; },
    divide:   function(x,y) { return x/y; },
    pow:      Math.pow  // Works for predefined functions too
};

// This function takes the name of an operator, looks up that operator
// in the object, and then invokes it on the supplied operands. Note
// the syntax used to invoke the operator function.
// 这个函数接收一个名字作为运算符，在对象中查找这个运算符，然后将它作用于所提供的操作数，注意这里调用运算符函数的语法
function operate2(operation, operand1, operand2) {
    if (typeof operators[operation] === "function")
        return operators[operation](operand1, operand2);
    else throw "unknown operator";
}

// Compute the value ("hello" + " " + "world") like this： 这样来计算("hello"+""+"world")的值
var j = operate2("add", "hello", operate2("add", " ", "world"));
// Using the predefined Math.pow() function: 使用预定义的函数Math.pow()
var k = operate2("pow", 10, 2);
```
这里是将函数用做值的另外一个例子，考虑一下Array.sort()方法。这个方法用来对数组元素进行排序。因为排序的规则有很多（基于数值大小、字母表顺序、日期大小、从小到大、从大到小等）,sort()方法可以接收一个函数作为参数，用来处理具体的排序操作。这个函数的作用非常简单，对于任意两个值都返回一个值，以指定它们在排序后的数组中的先后顺序。这个函数参数使得Array.sort()具有更完美的通用性和无限可扩展性，它可以对任何类型的数据进行任意排序。7.8.3节有示例代码。

自定义函数属性：
javascript中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个”静态“变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。比如，假设你想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个整数。而函数不能两次返回同一个值，为了做到这一点，函数必须能够跟踪它每次返回的值，而且这些值的信息需要在不同的的函数调用过程中持久化。可以将这些信息存放到全局变量中，但这并不是必需的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中，下面这个例子就实现了这样一个函数，每次调用函数都会返回一个唯一的整数：
```javascript
//初始化函数对象的计数器属性
//由于函数声明被提前了，因此这里是可以在函数声明
//之前给它的成员赋值的
uniqueInteger.counter = 0;
//每次调用这个函数都会返回一个不同的整数
//它使用一个属性来记住下一次将要返回的值
function uniqueInteger() {
    return uniqueInteger.counter++;//先返回计数器的值，然后计数器自增1
}
```
来看另外一个例子，下面这个函数factorial()使用了自身的属性（将自身当做数组来对待）来缓存上一次的计算结果：
```javascript
//计算阶乘，并将结果缓存至函数的属性中
function factorial(n) { 
    if (isFinite(n)&&n>0&&n==Math.round(n)) {   //有限的正整数
        if(!(n in factorial))                   //如果没有缓存结果
            factorial[n] = n * factorial(n-1);  //计算结果并缓存之
        return factorial[n];                    //返回缓存结果
    }
    else return NaN;//如果输入有误
}
factorial[i] = 1;//初始化缓存以保存这种基本情况
```

**8.5作为命名空间的函数**

3.10.1节介绍了javascript中的函数作用域的概念：在函数中声明的变量在整个函数体内都是可见的（包括在嵌套的函数中），在函数的外部是不可见的。不在任何函数内的声明的变量是全局变量，在整个javascript程序中都是可见的。在javascript中是无法声明只在一个代码块内可见的变量，基于这个原因，我们常常简单地定义一个函数用做临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间。

比如，假设你写了一段javascript模块代码，这段代码将要用在不同的javascript程序中（对于客户端javascript来讲通常是用在各种各样的网页中）。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量：
```javascript
function mymodule() {
    //模块代码
    //这个模块所使用的所有变量都是局部变量
    //而不是污染全局命名空间
}
mymodule();//不要忘了还要调用这个函数
```
这段代码仅仅定义了一个单独的全局变量：名叫"mymodule"的函数。这样还是太麻烦，可以直接定义一个匿名函数，并在单个表达式中调用它：
```javascript
(function() {   //mymodule()函数重写为匿名的函数表达式
    //模块代码
}());   //结束函数定义并立即调用它
```
这种定义匿名函数并立即在单个表达式中调用它的写法非常常见，已经成为一种惯用法了。注意上面的代码的圆括号的用法，function之前的左圆括号是必需的，因为如果不写这个左圆括号，javascript解释器会试图将关键字function解析为函数声明语句。使用圆括号javascript解释器才会正确地将其解析为函数定义表达式。使用圆括号是习惯用法，尽管有些时候没有必要也不应当省略。这里定义的函数会立即调用。

例8-3展示了这种命名空间技术。它定义了一个返回extend()函数的匿名函数，正如在例6-2中所展示的那样，匿名函数中的代码检测了是否出现了一个众所周知的IE bug，如果出现了这个bug，就返回一个带补丁的函数版本。此外，这个匿名函数命名空间用来隐藏一组属性名。

例8-3：特定场景下返回带补丁的extend()版本
```javascript
// Define an extend function that copies the properties of its second and 
// subsequent arguments onto its first argument.
// We work around an IE bug here: in many versions of IE, the for/in loop
// won't enumerate an enumerable property of o if the prototype of o has 
// a nonenumerable property by the same name. This means that properties
// like toString are not handled correctly unless we explicitly check for them.
// 定义一个扩展函数，用来将第二个以及后续参数复制至第一个参数
// 这里我们处理了IE bug：在多数IE版本中
// 如果o的属性拥有一个不可枚举的同名属性，则for/in循环
// 不会枚举对象o的可枚举属性，也就是说，将不会正确地处理诸如toString的属性
// 除非我们显式检测它
var extend = (function() {  // Assign the return value of this function ，将这个函数的返回值赋值给extend
    // First check for the presence of the bug before patching it.，在修复它之前，首先检查是否存在bug
    for(var p in {toString:null}) {
        // If we get here, then the for/in loop works correctly and we return
        // 如果代码执行到这里，那么for/in循环会正确工作并返回
        // a simple version of the extend() function
        // 一个简单版本的extend()函数
        return function extend(o) {
            for(var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for(var prop in source) o[prop] = source[prop];
            }
            return o;
        };
    }
    // If we get here, it means that the for/in loop did not enumerate
    // the toString property of the test object. So return a version
    // of the extend() function that explicitly tests for the nonenumerable
    // properties of Object.prototype.
    // 如果代码执行到这里，说明for/in循环不会枚举测试对象的toString属性，因此返回另一个版本的extend()函数，这个函数显式测试
    // Object.prototype中的不可枚举属性
    return function patched_extend(o) {
        for(var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            // Copy all the enumerable properties，复制所有的可枚举属性
            for(var prop in source) o[prop] = source[prop];

            // And now check the special-case properties，现在检查特殊属性
            for(var j = 0; j < protoprops.length; j++) {
                prop = protoprops[j];
                if (source.hasOwnProperty(prop)) o[prop] = source[prop];
            }
        }
        return o;
    };

    // This is the list of special-case properties we check for
    // 这个列表列出了需要检查的特殊属性
    var protoprops = ["toString", "valueOf", "constructor", "hasOwnProperty",
                      "isPrototypeOf", "propertyIsEnumerable","toLocaleString"];
}());
```

**8.6闭包**

和其他大多数的现代编程语言一样，javascript也采用词法作用域（lexical scoping），也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定。为了实现这种词法作用域，javascript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链（在继续阅读后续的章节之前，应当复习一下3.10节和3.10.3节中讲到的变量作用域和作用域链的概念）。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中国称为“闭包”。这个术语非常古老，是指函数变量可以被隐藏于作用域链之内，因此看起来是函数将变量“包裹”了起来。

从技术的角度讲，所有的javascript函数都是闭包的：它们都是对象，它们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事情就变得非常微妙。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包。以至于这种编程模式在javascript中非常常见。当你第一次碰到闭包时可能会觉得非常让人费解，一旦你理解掌握了闭包之后，就能非常自如地使用它了，了解这一点至关重要。

理解闭包首先要了解嵌套函数的词法作用域规则。看一下这段代码（这段代码和你刚在3.10节中看到的代码非常类似）：
```javascript
var scope = "global scope"//全局变量
function checkscope() {
    var scope = "local scope";//局部变量
    function f() {return scope;}//在作用域中返回这个值
    return f():
}
checkscope()//=>"local scope"
```
checkscope()函数声明了一个局部变量，并定义了一个函数f()，函数f()返回了这个变量的值，最后将函数f()的执行结果返回。你应当非常清楚为什么调用checkscope()会返回“local scope”。现在我们对这段代码做一点改动。你知道这段代码返回什么吗？
```javascript
var scope = "global scope";//全局变量
function checkscope() {
    var scope = "local scope";//局部变量
    function f() {return scope;}//在作用域中返回这个值
    return f;
}
checkscope()()//返回值是什么
```
在这段代码中，我们将函数内的一对圆括号移动到了checkscope()之后。checkscope()现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对圆括号）会发生什么事情呢？

回想一下词法作用域的基本规则：javascript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数f()定义在这个作用域链里，其中的变量scope一定是局部变量，不管在何时何地执行函数f()，这种绑定在执行f()时依然有效。因此最后一段代码返回“local scope”，而不是“global scope”。简言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了在其中定义它们的外部函数。

实现闭包：如果你理解了词法作用域的规则，你就能很容易地理解闭包：函数定义时的作用域链到函数执行时依然有效。然而很多程序员觉得闭包非常难理解，因为它们在深入学习闭包的实现细节时将自己搞得晕头转向。他们觉得在外部函数中定义的局部变量在函数返回后就不存在了（之所以有这种想法是因为很多人以为函数执行结束后，与之相关的作用域链似乎也不存在了，但在javascript中并非如此），那么嵌套的函数如何能调用不存在的作用域链呢？如果你想搞清楚这个问题，你需要更深入地了解类似c语言这种更底层的编程语言，并了解基于栈的CPU架构：如果一个函数的局部变量定义在CPU的栈中，那么当函数返回时它们的确就不存在了。
但回想一下在3.10.3节中是如何定义作用域链的。我们将作用域链描述为一个对象列表，不是绑定的栈。每次调用javascript函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中。但函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也没有引用指向这个绑定对象，它就会被当做垃圾回收掉。如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链指向的一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来，那么它们也会和所指向的变量绑定对象一样当做垃圾回收。但是如果这个函数定义了嵌套的函数，并将它们作为返回值返回或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套的函数。它就不会被当做垃圾回收，并且它所指向的变量绑定对象也不会被当做垃圾回收。作者在这里清楚地解释了闭包和垃圾回收之间的关系，如果使用不慎，闭包很容易造成“循环引用”，当DOM对象和javascript对象之间存在循环引用时需要格外小心，在某些浏览器下会造成内存泄漏。

在8.4.1节中定义了uniqueInteger()函数，这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟踪上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致uniqueInteger()函数不一定能产生“唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用做私有状态。我们可以利用闭包这样来重写uniqueInteger()函数：

```javascript
var uniqueInteger = (function() {//定义函数并立即调用
    var counter = 0;//函数的私有状态
    return function() {return counter++;};
}())；
```
你需要仔细阅读这段代码才能理解其含义。粗略来看，第一行代码看起来像将函数值给一个变量uniqueInteger，实际上，这段代码定义了一个立即调用的函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量uniqueInteger。现在，我们来看函数体，这个函数返回另外一个函数，这是一个嵌套的函数，我们将它赋值给变量uniqueInteger，嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的counter变量。当外部函数返回之后，其他任何代码都无法访问counter变量，只有内部的函数才能访问它。

像counter一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链，看一下这段代码：
```javascript
function counter() {
    var n = 0;
    return {
        count: function() { return n++; },
        reset: function() { n=0; }
    };
}
var c = counter(), d = counter();//创建两个计数器
c.count();//=> 0
d.count();//=> 0 它们互不干扰
c.reset();//reset() 和 count() 方法共享状态
c.count();//=> 0 因为我们重置了c 
d.count();//=> 1 而没有重置d
```
counter()函数返回一个“计数器”对象，这个对象包含两个方法：count()返回下一个整数，reset()将计数器重置为内部状态。首先要理解，这两个方法都可以访问私有变量n。再者，每次调用counter()都会创建一个新的作用域链和一个新的私有变量。因此，如果调用counter()两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的count()或reset()不会影响到另一个对象。

从技术角度看，其实可以将这个闭包合并为属性存取器方法getter和setter。下面这段代码所示的counter()函数的版本是6.6节中代码的变种，所不同的是，这里私有状态的实现是利用了闭包，而不是利用普通的对象属性来实现。
```javascript
function counter(n) {//函数参数n是一个私有变量
    return {
        //属性getter方法返回并给私有计数器var递增1
        get count() {return n++},
        //属性setter不允许n递减
        set count(m) {
        if (m>=n) n=m;
        else throw Error("count can only be set to a larger value");
        }
    };
}
var c = counter(1000);
c.count //=> 1000
c.count //=> 1001
c.count = 2000
c.count //=> 2000
c.count = 2000//=> Error!
```
需要注意的是，这个版本的counter()函数并未声明局部变量，而这是使用参数n来保存私有状态，属性存取器方法可以访问n。这样的话，调用counter()函数就可以指定私有变量的初始值了。

例8-4是这种使用闭包技术来共享的私有状态的通用做法。这个例子定义了addPrivateProperty()函数，这个函数定义了一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值。它将这些嵌套函数添加为所指定对象的方法。
```javascript
// This function adds property accessor methods for a property with
//这个函数给对象o增加了属性存取器方法
// the specified name to the object o.  The methods are named get<name>
//方法名称为get<name>和set<name>。如果提供了一个判定函数
// and set<name>.  If a predicate function is supplied, the setter
//setter方法就会用它来检测参数的合法性，然后在存储它
// method uses it to test its argument for validity before storing it.
// If the predicate returns false, the setter method throws an exception.
//如果判定函数返回false，setter方法抛出一个异常
// The unusual thing about this function is that the property value
//这个函数有一个非同寻常之处，就是getter和setter函数
// that is manipulated by the getter and setter methods is not stored in
//所操作的属性值并没有存储在对象o中
// the object o.  Instead, the value is stored only in a local variable
// 相反，这个值仅仅是保存在函数中的局部变量
// in this function.  The getter and setter methods are also defined
//getter和setter方法同样是局部函数，因此可以访问这个局部变量
// locally to this function and therefore have access to this local variable.
// This means that the value is private to the two accessor methods, and it 
// 也就是说，对于两个存取器方法来说这个变量是私有的
// cannot be set or modified except through the setter method.
//没有办法绕过存取器方法来设置或修改这个值
function addPrivateProperty(o, name, predicate) {
    var value;  // This is the property value，这是一个属性值
    // The getter method simply returns the value.，getter方法简单地将其返回
    o["get" + name] = function() { return value; };
    //The setter method stores the value or throws an exception if
    //setter方法首先检查值是否合法，若不合法就抛出异常
    // the predicate rejects the value.
    //否则就将其存储起来
    o["set" + name] = function(v) {
        if (predicate && !predicate(v))
            throw Error("set" + name + ": invalid value " + v);
        else
            value = v;
    };
}

// The following code demonstrates the addPrivateProperty() method.
//下面的代码展示了addPrivateProperty()方法
var o = {};  // Here is an empty object，设置一个空对象

// Add property accessor methods getName and setName()，增加属性存取器方法getName()和setName()
// Ensure that only string values are allowed，确保只允许字符串值
addPrivateProperty(o, "Name", function(x) { return typeof x == "string"; });

o.setName("Frank");       // Set the property value，设置属性值
console.log(o.getName()); // Get the property value，得到属性值
o.setName(0);             // Try to set a value of the wrong type，试图设置一个错误类型的值
```
我们已经给出了很多例子，在同一个作用域链中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但还是要特别小心那些不希望共享的变量往往不经意间共享给了其他的闭包，了解这一点也很重要。看一下下面这段代码：
```javascript
//这个函数返回一个总是返回v的函数
function constfunc(v) { return function() {return v;};}
//创建一个数组用来存储常数函数
var funcs = [];
for (var i = 0; i< 10; i++) func[i] = constfunc(i);
//在第5个位置的元素所表示的函数返回值为5
funcs[5]()//=> 5
```
这段代码利用了循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误，那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码：
```javascript
//返回一个函数组成的数组，它们的返回值是0～9
function constfuncs() {
    var funcs = [];
    for (var i =0; i < 10; i++) {
        funcs[i] = function() {return i;};
        return funcs;
    }
}
var funcs = constfuncs();
funcs[5]()//返回值是什么
```
上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量i。当constfuncs()返回时，变量i的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域链都是“活动的”，记住这一点非常重要。嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照（static snapshot）。

书写闭包的时候还需注意一件事情，this是javascript的关键字，而不是变量。正如之前讨论的，每个函数调用都包含一个this值，如果闭包在外部函数里是无法访问this的（严格讲，闭包内的逻辑是可以使用this的，但这个this和当初定义函数时的this不是同一个，即便是同一个this，this的值是随着调用栈的变化而变化的，而闭包里的逻辑所取到的this的值也是不确定的，因此外部函数内的闭包是可以使用this的，但要非常小心地使用才行，作者在这里提到的将this转存为一个变量的做法就可以避免this的不确定性带来的歧义。），除非外部函数将this转存为一个变量：
```javascript
    var self = this;//将this保存至一个变量中，以便嵌套的函数能够访问它
```
绑定arguments的问题与之类似。arguments并不是一个关键字，但在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的arguments，因此闭包内无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另一个变量中：
```javascript
var outerArguments = arguments;//保存起来以便嵌套的函数能使用它
```
在本章接下来讲到的例8-5中就利用了这种编程技巧来定义闭包，以便在闭包中可以访问外部函数的this和arguments值。

**8.7函数属性、方法和构造函数**

我们看到在javascript程序中，函数是值。对函数执行typeof运算会返回字符串“function”，但是函数是javascript中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，就像普通的对象可以拥有属性和方法一样。甚至可以用Function()构造函数来创建新的函数对象。接下来几节就会着重介绍函数属性和方法以及Function()构造函数。在第三部分也有关于这些内容的讲解。

**8.7.1 length属性**

在函数体里，arguments.length表示传入函数的实参的个数。而函数本身的length属性则有着不同含义。函数的length属性是只读属性，它代表函数实参的数量，这里的参数指的是“形参”而非“实参”，也就是在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数。

下面的代码定义了一个名叫check()的函数，从另外一个函数给它传入arguments数组，它比较arguments.length（实际传入的实参个数）和arguments.callee.length（期望传入的实参个数）来判断所传入的实参个数是否正确。如果个数不正确，则抛出异常。check()函数之后定义一个测试函数f()，用来展示check()的用法：
```javascript
//这个函数使用arguments.callee，因此它不能在严格模式下工作
funtion check(args) {
    var actual = args.length;//实参的真实个数
    var expected = args.callee.length;//期望的实参个数
    if (actual !== expected )//如果不同则抛出异常
    throw Error("Expected" + expected + "args; got " + actual);
}
function f(x,y,z) {
    check(arguments); //检查实参个数和期望的实参个数是否一致
    return x + y + z; //再执行函数的后续逻辑
}
```

**8.7.2 prototype属性**

每一个函数都包含一个prototype属性，这个属性是指向一个对象的引用，这个对象称做“原型对象”（prototype object）。每一个函数都包含不同的原型对象。当将函数用做构造函数的时候，新创建的对象会从原型对象上继承属性。6.1.3节讨论了原型和prototype属性，在第9章里会有进一步讨论。

**8.7.3 call()方法和apply()方法**

我们可以将call()和apply()看做是某个对象的方法，通过调用方法的形式来间接调用（见8.2.4节）函数（比如在例6-4我们使用了call()方法来调用一个对象的Object.prototype.toString方法，用以输出对象的类）。call()和apply()的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得对它的引用。要想以对象o的方法来调用函数f(),可以这样使用call()和apply():
```javascript
f.call(o);
f.apply(o);
```
每行代码和下面代码的功能类似（假设对象o中预先不存在名为m的属性）
```javascript
o.m = f;// 将f存储为o的临时方法
o.m();// 调用它，不传入参数
delete o.m;// 将临时方法删除
```

在ECMAScript5的严格模式中，call()和apply()的第一个实参都会变为this的值，哪怕传入的实参是原始值甚至是null或undefined。在ECMAScript3和非严格模式中，传入的null和undefined都会被全局对象代替，而其他原始值则会被相应的包装对象（wrapper object）所替代。

对于call()来说，第一个调用上下文实参之后的所有实参就是要传入待调用函数的值。比如，以对象o的方法的形式调用函数f()，并传入两个参数，可以使用这样的代码：

    f.call(o, 1, 2);
    
apply()方法和call()类似，但传入实参的形式和call()有所不同，它的实参都放入一个数组当中：

    f.apply(o,[1,2]);
    
如果一个函数的实参可以是任意数量，给apply()传入的参数数组可以是任意长度的。比如，为了找出数组中最大的数值元素，调用Math.max()方法的时候可以给apply()传入一个包含任意个元素的数组：

    var biggest = Math.max.apply(Math, array_of_numbers);

需要注意的是，传入apply()的参数数组可以是类数组对象也可以是真实数组。实际上，可以将当前函数的arguments数组直接传入（另一个函数的）apply()来调用另一个函数，参照如下代码：
```javascript
//将对象o中名为m()的方法替换为另一个方法
//可以在调用原始的方法之前和之后记录日志消息
function trace(o, m) {
    var original = o[m];//在闭包中保存原始方法
    o[m] = function() {
        console.log(new Date(), "Entering:", m); //输出日志信息
        var result = original.apply(this, arguments); //调用原始函数
        console.log(new Date(), "Exiting:", m); //输出日志消息
        return result;  //返回结果
    }
}
```
trace()函数接收两个参数，一个对象和一个方法名，它将指定的方法替换为一个新方法，这个新方法是“包裹”原始方法的另一个泛函数。这种动态修改已有方法的做法有时称做“monkey-patching”。

**8.7.4 bind()方法**

bind()是在ECMAScript 5中新增的方法，但在ECMAScript3中可以轻易模拟bind()。从名字就可以看出，这个方法的主要作用域就是将函数绑定至某个对象。当在函数f()上调用bind()方法并传入一个对象o作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数f()当做o的方法来调用。传入新函数的任何实参都将传入原始函数，比如：
```javascript
function f(y) { return this.x + y; } //这个是待绑定的函数
var o = { x : 1 }; //将要绑定的对象
var g = f.bind(o); //通过调用g(x)来调用o.f(x)
g(2) //=>3
```
可以通过如下代码轻易地实现这种绑定：
```javascript
//返回一个函数，通过调用它来调用o中的方法f()，传递它所有的实参
function bind(f, o) {
    if (f.bind) return f.bind(o); //如果bind()方法存在的话，使用bind()方法
    else return function() {    //否则，这样绑定
        return f.apply(o, arguments);
    }
}
```
ECMAScript5中的bind()方法不仅仅是将函数绑定至一个对象，它还附带一些其他应用，除了第一个实参之外，传入bind()的实参也会绑定至this，这个附带的应用是一种常见的函数式编程技术，有时也被称为“柯里化”（curring）。参照下面这个例子中的bind()方法实现：
```javascript
var sum = function(x,y) {return x+y};//返回两个实参的和值
//创建一个类似sum的新函数，但this的值绑定到null
//并且第一个参数绑定到1，这个新的函数期望只传入一个实参
var succ = sum.bind(null, 1);   
succ(2) //=>3 x绑定到1，并传入2作为实参y
function f(y,z) { return this.x + y + z };//另外一个做累加计算的函数
var g = f.bind({x:1}, 2);//绑定this和y
g(3) //=> 6 this.x绑定了1，y绑定到了2，z绑定到了3
```
我们可以绑定this的值并在ECMAScript3中实现这个附带的应用。例8-5中的示例代码就模拟实现了标准的bind()方法。

注意，我们将这个方法另存为Function.prototype.bind，以便所有的函数对象都继承它，这种技术在9.4节中有详细介绍：
例8-5：ECMAScript3版本的Function.bind()方法
```javascript
if (!Function.prototype.bind) {
    Function.prototype.bind = function(o /*, args */) {
        // Save the this and arguments values into variables so we can
        // use them in the nested function below.
        // 将this和arguments的值保存至变量中
        // 以便在后面嵌套的函数中可以使用它们
        var self = this, boundArgs = arguments;

        // The return value of the bind() method is a function
        // bind()方法的返回值是一个函数
        return function() {
            // Build up an argument list, starting with any args passed
            // to bind after the first one, and follow those with all args
            // passed to this function.
            //创建一个实参列表，将传入bind()的第二个及后续的实参都传入这个函数
            var args = [], i;
            for(i = 1; i < boundArgs.length; i++) args.push(boundArgs[i]);
            for(i = 0; i < arguments.length; i++) args.push(arguments[i]);
            
            // Now invoke self as a method of o, with those arguments
            // 现在将self作为o的方法来调用，传入这些实参
            return self.apply(o, args);
        };
    };
}
```
我们注意到，bind()方法返回的函数是一个闭包，在这个闭包的外部函数中声明了self和boundArgs变量，这两个变量在闭包里用到。尽管定义闭包的内部函数已经从外部函数中返回，而且调用这个闭包逻辑的时刻要在外部函数返回之后（在闭包中照样可以正确访问这两个变量）。

ECMAScript5定义的bind()方法也有一些特性是上述ECMAScript3代码无法模拟的。首先，真正的bind()方法返回一个函数对象，这个函数对象的length属性是绑定函数的形参个数减去实参的个数（length的值不能小于零）。再者，ECMAScript5的bind()方法可以顺带用做构造函数。如果bind()返回的函数用做构造函数，将忽略传入bind()的this，原始函数就会以构造函数的形式调用，它的实参也已经绑定。由bind()方法所返回的函数并不包含prototype属性（普通函数固有的prototype属性是不能删除的），并且将这些绑定的函数用做构造函数时所创建对象从原始的未绑定的构造函数中继承prototype。同样，在使用instanceof运算符时，绑定构造函数和未绑定构造函数并无两样。

**8.7.5 toString()方法**
和所有的javascript对象一样，函数也有toString()方法，ECMAScript规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数（非全部）的toString()方法的实现都返回函数的完整源码。内置函数往往返回一个类似“[native code]”的字符串作为函数体。

**8.7.6Function()构造函数**

不管是通过函数定义语句还是函数直接量表达式，函数的定义都要使用function关键字。但函数还可以通过Function()构造函数来定义，比如：

    var f = new Function("x", "y", "return x*y;");

这一行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价：

    var f = function(x, y) { return x*y; }

Function()构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体，它可以包含任意的javascript语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串——函数体——即可。

注意，Function()构造函数并不需要通过传入实参以指定函数名。就像函数直接量一样，Function()构造函数创建一个匿名函数。
关于Function()构造函数有几点需要特别注意：
* Function()构造函数允许javascript在运行时动态地创建并编译函数
* 每次调用Function()函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。
* 最后一点，也是关于Function()构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数执行，正如下面代码所示：

```javascript
var scope = "global";
function constructFunction() {
    var scope = "local";
    return new Function("return scope");//无法捕获局部作用域
}
//这一行代码返回global，因为通过Function()构造函数
//所返回的函数使用的不是局部作用域
constructFunction()(); //=>"global"
```
我们可以将Function()构造函数认为是在全局作用域中执行的eval()（参照4.12.2节），eval()可以在自己的私有作用域内定义新变量和函数，Function()构造函数在实际编程过程中很少会用到。

**8.7.7 可调用的对象**

我们在7.11节中提到“类数组对象”并不是真正的数组，但大部分场景下可以将其当做数组来对待。对于函数也存在类似的情况。“可调用的对象”（callable object）是一个对象，可以在函数调用表达式中调用这个对象。所有的函数都是可调用的，但并非所有的可调对象都是函数。

截至目前，可调用对象在两个javascript实现中不能算作函数。
首先，IE web浏览器（IE8及之前的版本）实现了客户端方法（诸如Window.alert()和Document.getElementsById()），使用了可调用的宿主对象，而不是内置函数对象。IE中的这些方法在其他浏览器中也都存在，但它们本质上不是Function对象。IE9将它们实现为真正的函数，因此这类可调用的对象将越来越罕见。

另外一个常见的可调用对象是RegExp对象（在众多浏览器中均有实现），可以直接调用RegExp对象，这比调用它的exec()方法更快捷一些。在javascript中这是一个彻头彻尾的非标准特性，最开始是由Netscape提出，后被其他浏览器厂商所复制，仅仅是为了和Netscape兼容。代码最好不要对可调用的RegExp对象有太多的依赖，这个特性在不久的将来可能会废弃并删除。对RegExp执行typeof运算的结果并不统一，在有些浏览器中返回“function”，在有些中返回“object”。

如果想检测一个对象是否是真正的函数对象（并且具有函数方法），可以参照例6-4中的代码检测它的class属性（见6.8.2节）：
```javascript
function isFunction(x) {
    return Object.prototype.toString.call(x) === "[object Function]";
}
```
注意，这里的isFunction()函数和7.10节的isArray()函数极其类似。

**8.8函数式编程**

和Lisp、Haskell不同，javascript并非函数式编程语言，但在javascript中可以像操控对象一样操控函数，也就是说可以在javascript中应用函数式编程技术。ECMAScript5中的数组方法（诸如map()和reduce()）就可以非常适合用于函数式编程风格。接下来的几节会着重介绍javascript中的函数式编程技术。对javascript函数的探讨会让人倍感兴奋，你会体会到javascript函数非常强大，而不仅仅是学习一种编程风格而已。

**8.8.1 使用函数处理数组**

假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话，代码会是这样：
```javascript
var data = [1,1,3,5,5]; //这里是待处理的数组
//平均数是所有元素的累加和值除以元素个数
var total = 0;
for (var i = 0; i<data.length; i++ ){
    total += data[i];
}
var mean = total/data.length; //平均数是3
//计算标准差，首先计算每个数据减去平均数之后偏差的平方让后求和
total = 0;
for (var i = 0; i < data.length; i++) {
    var deviation = data[i] - mean;
    total += deviation*deviation;
}
var stddev = Math.sqrt(total/(data.length - 1)); //标准差的值是2        
```
可以使用数组方法map()和reduce()来实现同样的计算，这种实现极其简洁（参照7.9节来查看这些方法）：
```javascript
//首先定义两个简单的函数
var sum = function(x,y) {return x+y};
var square = function(x) {return x*x};
//然后将这些函数和数组方法配合使用计算出的平均数和标准差
var data = [1,1,3,5,5];
var mean = data.reduce(sum)/data.length;
var deviations = data.map(function(x){return x-mean});
var stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length - 1));
```
如果我们基于ECMAScript3来如何实现呢？因为ECMAScript3中并不包含这些数组方法，如果不存在内置方法的话我们可以自定义map()和reduce()函数：
```javascript
//对于每个数组元素调用函数f()，并返回一个结果数组
//如果Array.prototype.map定义了的话，就使用这个方法
var map = Array.prototype.map
    ? function(a, f) { return a.map(f); } //如果已经存在map()方法，就直接使用它
    : function(a, f) {                  //否则，自己实现一个 
        var results = [];
        for (var i = 0, len = a.length; i < len; i++ ) {
            if (i in a) results[i] = f.call(null, a[i], i, a);
        }
        return results;
    };
//使用函数f()和可选的初始值将数组a减至一个值
//如果Array.prototype.reduce存在的话，就使用这个方法
var reduce = Array.prototype.reduce 
    ? function(a, f, initial) { //如果reduce()方法存在的话
    if (arguments.length > 2)
        return a.reduce(f, initial); //如果传入一个初始值
        else return a.reduce(f); //否则没有初始值
    }
    : function(a, f, initial) { //这个算法来自ES5规范
        var i = 0, len = a.length, accumulator; 
        //以特定的初始值开始，否则第一个值取自a
        if (arguments.length > 2) accumulator = initial;
        else { //找到数组中第一个已定义的索引
            if (len == 0) throw TypeError();
            while (i < len) {
                if (i in a) {
                    accumulator = a[i++];
                    break;
                }
                else i++;
            }
            if (i == len) throw TypeError();
        }
        //对于数组中剩下的元素依次调用f()
        while (i < len) {
            if (i in a)
                accumulator = f.call(undefined, accumulator, a[i], i, a);
            i++;
        }
        return accumulator;
    };
```
使用定义的map()和reduce()函数，计算平均值和标准差的代码看起来像这样：
```javascript
var data = [1,1,3,5,5];
var sum = function(x, y) { return x+y; };
var square = function(x) { return x*x; };
var mean = reduce(data, sum)/data.length;
var deviations = map(data, function(x) {return x-mean;});
var stddev = Math.sqrt(reduce(map(deviations, square), sum)/(data.length -1));
```


**8.8.2 高阶函数**
所谓高阶函数（higher-order function）就是操作函数的函数，它接收一个或多个函数作为参考，并返回一个新函数，来看这个例子：
```javascript
//这个高阶函数返回一个新的函数，这个新的函数将它的实参传入f()
//并返回f的返回值的逻辑非
function not (f) {
    return function() { //返回一个新的函数
        var result = f.apply(this, arguments); // 调用f()
        return !result; //对结果求反
    };
}
var even = function(x) { //判断a是否为偶数的函数
    return x%2 === 0;  
};
var odd = not(even); //一个新函数，所做的事情和even()相反
[1, 1, 3, 5, 5].every(add); //=>true 每个元素都是奇数
```
上面的not()函数就是一个高阶函数，因为它接收一个函数作为参数，并返回一个新函数。另外一个例子，来看下面的mapper()函数，它也是接收一个函数作为参数，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上。这个函数使用了之前定义的map()函数，但要首先理解这两个函数有哪里不同，理解这一点至关重要：
```javascript
//所返回的函数的参数应当是一个实参数组，并对每个数组元素执行函数f()
//并返回所有计算结果组成的数组
//可以对比一下这个函数和上文提到的map()函数
function mapper(f) {
    return function(a) {return map(a, f);};
}
var increment = function(x) {return x+1;};
var incrementer = mapper(increment);
incrementer([1,2,3]) //=> [2,3,4]
```
这里是一个更常见的例子，它接收两个函数f()和g()，并返回一个新的函数用以计算f(g()):
```javascript
//返回一个新的可以计算f(g(...))的函数
//返回的函数h()将它所有的实参传入g()，然后将g()的返回值传入f()
//调用f()和g()时的this值和调用h()时的this值是同一个this
function compose (f, g) {
    return function() {
        //需要给f()传入一个参数，所以使用f()的call()方法
        //需要给g()传入很多参数，所以使用g()的apply()方法
        return f.call(this, g.apply(this, arguments));
    };
}
var square = function(x) {return x*x; };
var sum = function(x, y) {return x+y; };
var squareofsum = compose(square, sum);
squareofsum(2, 3)//=> 25
```
本章后续几节中定义了partial()和memoize()函数，这两个函数是非常重要的高阶函数。

**8.8.3 不完全函数**

函数f()（见8.7.4节）的bind()方法返回一个新函数，给新函数传入特定的上下文和一组特定的参数，然后调用函数f()。我们说它把函数“绑定至”对象并传入一部分参数。bind()方法只是将实参放在（完整实参列表的）左侧，也就是说传入bind()的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入bind()的实参放在（完整实参列表的）右侧：
```javascript
//实现一个工具函数将类数组对象（或对象）转换为真正的数组
//在后面的示例代码中用到了这个方法将arguments对象转换为真正的数组
function array(a, n) { return Array.prototype.slice.call(a, n || 0);}
//这个函数的实参传递至左侧
function partialLeft(f /*, ...*/) {
    var args = arguments; //保存外部的实参数组
    return function() { //并返回这个函数
        var a = array(args, 1); //开始处理外部的第1个args
        a = a.concat(array(arguments)); //然后增加所有的内部实参
        return f.apply(this, a);    //然后基于这个实参列表调用f()
    };
}
//这个函数的实参传递至右侧
function partialRight(f /*, ...*/) {
    var args = arguments; //保存外部实参数组
    return function() { //调用这个函数
        var a = array(arguments); //从内部参数开始
        a = a.concat(array(args, i)); //然后从外部第i个args开始添加
        return f.apply(this, a); // 最后基于这个实参列表调用f()
    };
}
//这个函数的实参被用做模板
//实参列表中的undefined值都被填充
function partial(f /*, ...*/) {
    var args = arguments; //保存外部实参数组
    return function() {
        var a = array(args, i); //从外部args开始
        var i = 0, j = 0;
        //遍历args，从内部实参填充undefined值
        for (; i < a.length; i++)
            if (a[i] === undefined) a[i] = arguments[j++];
        //现在将剩下的内部实参都追加进去
        a = a.concat(array(arguments, j));
        return f.apply(this, a);
    };
}
//这个函数带有三个实参
var f = function(x, y, z) {return x*(y -z);};
//注意这三个不完全调用之间的区别
partialLeft(f, 2)(3, 4) //=> -2 绑定第一个实参 2*(3 - 4)
partialRight(f, 2)(3, 4) //=> 6 绑定最后一个实参 3*(4 - 2)
partial(f, undefined, 2)(3, 4) //=> -6 绑定中间的实参 3*(2 - 4)
```
利用这种不完全函数的编程技巧，可以编写一些有意思的代码，利用已有的函数来定义新的函数，参照下面这个例子：
```javascript
var increment = partialLeft(sum, 1);
var cuberoot = partialRight(Math.pow, 1/3);
String.prototype.first = partial(String.prototype.charAt, 0);
String.prototype.last = partial(String.prototype.substr, -1, 1);
```
当将不完全调用和其他高阶函数整合在一起的时候，事情就变得格外有趣了。比如，这里的例子定义了not()函数，它用到了刚才提到的不完全调用：
```javascript
var not = partialLeft(compose, function(x) { return !x; });
var even = function(x) { return x%2 === 0;};
var odd = not(even);
var isNumber = not(isNaN);
```
我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码，这种编程风格是非常纯粹的函数式编程：
```javascript
var data = [1, 1, 3, 5, 5]; //我们要处理的数据
var sum = function(x, y) {return x*y; }; //两个初等函数
var product = function(x, y) { return x*y;};
var neg = partial(product, -1); //定义其他函数
var square = partial(Math.pow, undefined, 2);
var sqrt = partial(Math.pow, undefined, .5);
var reciprocal = partial(Math.pow, undefined, -1);
//现在计算平均值和标准差，所有的函数调用都不带运算符
//这段代码看起来很像lisp代码
var mean = product(reduce(data, sum), reciprocal(data.length));
var stddev = sqrt(product(reduce(map(data, compose(square, partial(sum, neg(mean)))),sum),reciprocal(sum(data.length, -1))));
```

**8.8.4 记忆**

在8.4.1节中定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式编程当中，这种缓存技巧叫做“记忆”（memorization）。下面的代码展示了一个高阶函数，memorize()接收一个函数作为实参，并返回带有记忆能力的函数。（需要注意的是，记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度以换取更优的时间复杂度，在客户端javascript中代码的执行时间复杂度往往成为瓶颈，因此在大多数场景下，这种牺牲空间换取时间的做法以提升程序执行效率的做法是非常可取的。）
```javascript
//返回f()的带有记忆功能的版本
//只有当f()的实参的字符串表示都不相同时它才会工作
function memorize(f) {
    var cache = {}; //将值保存在闭包内
    return funciton(){
        //将实参转换为字符串的形式，并将其用做缓存的键
        var key = arguments.length + Array.prototype.join.call(arguments, ",");
        if (key in cache) return cache[key];
        else return cache[key] = f.apply(this, arguments);
    };
}
```
memorize()函数创建一个新的对象，这个对象被当做缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换为字符串，并将字符串用做缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。

否则，就调用既定的函数对实参进行计算，将计算结果缓存起来并返回，下面的代码展示了如何使用memorize():
```javascript
//返回两个整数的最大公约数
//使用欧几里德算法（http://en.wikipedia.org/wiki/Euclidean_algorithm）
function gcd(a, b) {    //这里省略对a和b的类型检查
    var t;  //临时变量用来存储交换数值
    if (a < b) t=b, b=a, a=t; //确保 a>=b
    while(b !- 0) t=b, b=a%b, a=t;//这是求最大公约数的欧几里德算法
    return a;
}
var gcdmemo = memorize(gcd);
gcdmemo(85, 187) // => 17
//注意，当我们写一个递归函数时，往往需要实现记忆功能
//我们更希望调用实现了记忆功能的递归函数，而不是原递归函数
var factorial = memorize(function(){
    return (n <= 1) ? 1: n * factorail(n-1);
});
factorial(5)  //=>120 对于4~1的值也有缓存
```


第9章 类和模块
---------------

第6章详细介绍了javascript对象，每个javascript对象都是一个属性集合，相互之间没有任何联系。
在javascript中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。
类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。
这些行为通常是由类定义的，而且为所有实例所共享。
例如，假设一个名为Complex的类用来表示复数，同时还定义了一些复数运算。一个Complex实例应当包含复数的实部和虚部（状态），同样Complex类还会定义复数的加法和乘法操作（行为）。

在javascript中，类的实现是基于其原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。
javascript原型和继承在6.1.3节和6.2.2节中有详细讨论，为了更好地理解本章的内容，请务必首先阅读这两个章节。
本章将会在9.1节对原型做进一步的讨论。

如果两个对象继承自同一个原型，往往意味着（但不是绝对）它们是由同一个构造函数创建并初始化的。我们已经在4.6节、6.2节和8.2.3节中详细讲解了构造函数，9.2节会有进一步讨论。

如果你对诸如Java和C++这种强类型的面向对象编程比较熟悉，你会发现javascript中的类和Java以及C++中的类有很大的不同。尽管在写法上类似，而且在javascript中也能“模拟”出很多经典的类的特性（比如传统类的封装、继承、多态），但是要理解javascript的类和基于原型的继承机制，以及和传统的Java（当然还有类似Java的语言）的类和基于类的继承的不同之处。9.3节展示了如何在javascript中实现经典的类。
javascript中类的一个重要特性是“动态可继承”（dynamically extendable），9.4节详细解释这一特性。我们可以将类看做是类型，9.5节讲解检测对象的类的几种方式，该节同样介绍一种编程哲学——“鸭式辩型”（duck-typing），它弱化了对象的类型，强化了对象的功能。

在讨论了javascript中所有基本的面向对象编程特性之后，我们将关注点从抽象的概念转向一些实例。9.6节介绍两种非常重要的实现类的方法，包括很多实现面向对象的技术，这些技术可以很大程度上增强类的功能。9.7节展示（包含很多示例代码）如何实现类的继承，包括如何在javascript中实现类的继承。9.8节讲解如何使用ECMAScript5中的新特性来实现类以及面向对象编程。

定义类是模块开发和重用代码的有效方式之一，本章最后一节会集中讨论javascript中的模块。

强/弱类型是指类型检查的严格程度，为所有变量指定数据类型称为“强类型”。

**9.1类和原型**

在javascript中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。在例6-1中定义了inherit()函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义一个原型对象，然后通过inherit()函数创建一个继承自它的对象，这样就定义了一个javascript类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象，参照例9-1。例9-1给一个表示“值得范围”的类定义了原型对象，还定义了一个[“工厂”函数](https://zh.wikipedia.org/zh/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95)用以创建并初始化类的实例。
例9-1：一个简单的javascript类
```javascript
//range.js 实现一个能表示值得范围的类
//这个工厂方法返回一个新的“范围对象”
function range(from, to) {
    //使用inherit()函数来创建对象，这个对象继承自在下面定义的原型对象
    //原型对象作为函数的一个属性存储，并定义所有“范围对象”所共享的方法（行为）
    var r = inherit(range.methods);
    //存储新的“范围对象”的起始位置和结束位置（状态）
    //这两个属性是不可继承的，每个对象都拥有唯一的属性
    r.from = from;
    r.to = to;
    //返回这个新创建的对象
    return r;
}
//原型对象定义方法，这些方法为每个范围对象所继承
range.methods = {
    //如果x在范围内，则返回true，否则返回false
    //这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes: function(x) { return this.from <= x && x <= this.to; },
    //对于范围内的每个整数都调用一次f
    //这个方法只可用做数字范围
    foreach: function(f) {
        for(var x = Math.ceil(this.from); x <= this.to; x++) f(x);
    },
    //返回表示这个范围的字符串
    toString: function() { return "(" + this.from + "..." + this.to + ")"; }
};

//这里是使用“范围对象”的一些例子
var r = range(1,3);      //创建一个范围对象
r.includes(2);           // => true: 2 在这个范围内
r.foreach(console.log);  // 输出 1 2 3
console.log(r);          // 输出 (1...3)
```
在例子9-1中有一些代码是没有用的。这段代码定义了一个工厂方法range(),用来创建新的范围对象。我们注意到，这里给range()函数定义了一个属性range.methods，用以快捷地存放定义类的原型对象。把原型对象挂在函数上没什么大不了，但也不是惯用做法。再者，注意range()函数给每个范围对象都定义了from和to属性，用以定义范围的起始位置和结束位置，这两个属性是非共享的，当然也是不可继承的。最后，注意在range.methods中定义的那些可共享，可继承的方法都用到了from和to属性，而且使用了this关键字，为了指代它们，二者使用this关键字来指代调用这个方法的对象。任何类的方法都可以通过this的这种基本用法来读取对象的属性。


**9.2类和构造函数**
例9-1展示了在javascript中定义类的其中一种方法。但这种方法并不常用，毕竟它没有定义构造函数，构造函数是用来初始化新创建的对象的。8.2.3节已经讲到，使用关键字new来调用构造函数。使用new调用构造函数会自动创建一个新对象，因此构造函数本身只需要初始化这个新对象的状态即可。调用构造函数的一个重要特征是，构造函数的prototype属性被用做新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的成员。例9-2对例9-1的“范围类”做了修改，使用构造函数代替工厂函数：
例9-2：使用构造函数来定义“范围类”
```javascript
// 这是一个构造函数，用以初始化新创建的“范围对象”
// 注意，这里并没有创建并返回一个对象，仅仅是初始化
function Range(from, to) {
    // 存储“范围对象”的起始位置和结束位置（状态）
    // 这两个属性是不可继承的，每个对象都拥有唯一的属性
    this.from = from;
    this.to = to;
}

// 所有的“范围对象”都继承自这个对象
// 注意，属性的名字必须是“prototype”
Range.prototype = {
    // 如果x在范围内，则返回true，否则返回false
    // 这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes: function(x) { return this.from <= x && x <= this.to; },
    // 对于范围内的每个整数都调用一次f
    // 这个方法只可用于数字范围.
    foreach: function(f) {
        for(var x = Math.ceil(this.from); x <= this.to; x++) f(x);
    },
    // 返回表示这个范围的字符串
    toString: function() { return "(" + this.from + "..." + this.to + ")"; }
};

// 这里是使用“范围对象”的一些例子
var r = new Range(1,3);   // 创建一个范围对象
r.includes(2);            // => true: 2 在这个范围内
r.foreach(console.log);   // 输出 1 2 3
console.log(r);           // 输出 (1...3)
```
将例9-1和例9-2中的代码做一个仔细的对比，可以发现两种定义类的技术的差别。首先，注意当工厂函数range()转化为构造函数时被重命名为Range()。这里遵循了一个常见的编程约定：从某种意义上讲，定义构造函数既是定义类，并且类名首字母要大写。而普通的函数和方法都是首字母小写。
再者，注意Range()构造函数是通过new关键字调用的（在示例代码的末尾），而range()工厂函数则不必使用new。例9-1通过调用普通函数（见8.2.1节）来创建新对象，例9-2则使用构造函数调用（见8.2.3节）来创建新对象。由于Range()构造函数是通过new关键字调用的，因此不必调用inherit()或其他什么逻辑来创建新对象。在调用构造函数之前就已经创建了新对象，通过this关键字可以获取这个新对象。Range()构造函数只不过是初始化this而已。构造函数甚至不必返回这个新创建的对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。事实上，构造函数的命名规则（首字母大写）和普通函数是如此不同还有另外一个原因，构造函数调用和普通函数调用是不尽相同的。构造函数就是用来“构造新对象”的，它必须通过关键字new调用，如果将构造函数用做普通函数的话，往往不会正常工作。开发者可以通过命名约定来（构造函数首字母大写，普通方法首字母小写）判断是否应当在函数之前冠以关键字new。

例9-1和例9-2之间还有一个非常重要的区别，就是原型对象的命名。在第一段示例代码中的原型是range.methods。这种命名方式很方便同时具有很好的语义，但又过于随意。在第二段示例代码中的原型是Range.prototype，这是一个强制的命名。对Range()构造函数的调用会自动使用Range.prototype作为新Range对象的原型。

最后，需要注意在例9-1和例9-2中两种类定义方式的相同之处，两者的范围方法定义和调用方式是完全一样的。

**9.2.1构造函数和类的标识*

上文提到，原型对象是类的唯一标识，当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。而初始化对象的状态的构造函数则不能作为类的标识，两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。

尽管构造函数不像原型那样基础，但构造函数是类的“外在表现”。很明显的，构造函数的名字通常用做类名。比如，我们说Range()构造函数创建Range对象。然而，更根本地讲，当使用instanceof运算符来检测对象是否属于某个类时会用到构造函数。假设这里有一个对象r，我们想知道r是否是Range对象，我们这样写：

    r instanceof Range //如果r继承自Range.prototype 则返回true
    
实际上instanceof运算符并不会检查r是否是由Range()构造函数初始化而来，而会检查r是否继承自Range.prototype。不过，instanceof的语法则强化了“构造函数是类的公有标识”的概念。在本章的后面还会碰到对instanceof运算符的介绍。

**9.2.2 constructor属性**

在例9-2中，将Range.prototype定义为一个新对象，这个对象包含类所需要的方法。其实没有必要新创建一个对象，用单个对象直接量的属性就可以方便地定义原型上的方法。任何javascript函数都可以用做构造函数，并且调用构造函数是需要用到一个prototype属性的。因此，每个javascript函数（ECMAScript5中的Function.bind()方法返回的函数除外）都自动拥有一个prototype属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性constructor。constructor属性的值是一个函数对象：
```javascript
var f = function() {}; //这是一个函数对象
var p = F.prototype; //这是F相关联的原型对象
var c = p.constructor; //这是与原型相关联的函数
c === F  //=>true 对于任意函数F.prototype.constructor == F
```
可以看到构造函数的原型中存在预先定义好的constructor属性。这意味着对象通常继承的constructor均指代它们的构造函数。由于构造函数是类的“公共标识”，因此这个constructor属性为对象提供子类。
```javascript
var o = new F(); //创建类F的一个对象
o.constructor === F //=>true constructor属性指代这个类
```
如图9-1所示，图9-1展示了构造函数和原型对象之间的关系，包括原型到构造函数的反向引用以及构造函数创建的实例。

图9-1：构造函数及其原型和实例

需要注意的是，图9-1用Range()构造函数作为示例，但实际上，例9-2中定义的Range类使用它自身的一个新对象重写预定义的Range.prototype对象。这个新定义的原型对象不含有constructor属性。因此Range类的实例也不含有constructor属性。我们可以通过补救措施来修正这个问题，显式给原型添加一个构造函数：
```javascript
Range.prototype = {
    constructor: Range, //显式设置构造函数反向引用
    includes: function(x) {return this.from <= x && x <= this.to;},
    foreach: function(f) {
        for( var x = Math.ceil(this.from); x <= this.to; x++) f(x);
    },
    toString: function() {return "(" + this.from + "..." + this.to + ")";}
};
```
另一种常见的解决办法是使用预定义的原型对象，预定义的原型对象包含constructor属性，然后依次给原型对象添加方法：
```javascript
//扩展预定义的Range.prototype对象，而不重写之
//这样就自动创建Range.prototype.constructor属性
Range.prototype.includes = function (x) {return this.from <= x && x <= this.to;};
Range.prototype.foreach = function (f) {
    for (var x = Math.ceil(this.from); x <= this.to; x++) f(x);
};
Range.prototype.toString = function () {
    return "(" + this.from + "..." + this.to + ")";
};
```

**9.3javascript中java式的类继承**

如果你有过java或其他类似强类型面向对象语言的开发经历的话，在你的脑海中，类成员的模样可能会是这个样子：

    实例字段
        它们是基于实例的属性或变量，用以保存独立对象的状态。
    实例方法
        它们是类的所有实例所共享的方法，由每个独立的实例调用。
    类字段
        这些属性或变量是属于类的，而不是属于类的某个实例的。
    类方法
        这些方法是属于类的，而不是属于类的某个实例的。
        
        
javascript和java的一个不同之处在于，javascript中的函数都是以值的形式出现的，方法和字段之间并没有太大的区别。如果属性值是函数，那么这个属性就定义了一个方法；否则，它只是一个普通的属性或“字段”。尽管存在诸多差异，我们还是可以用javascript模拟出java中的这四种类成员类型。javascript中的类牵扯三种不同的对象（参照图9-1），三种对象的属性的行为和下面三种类成员非常相似：

    构造函数对象
        之前提到，构造函数（对象）为javascript的类定义了名字。任何添加到这个构造函数对象中的属性都是类字段和类方法（如果属性值是函数         的话就是类方法）。
    原型对象
        原型对象的属性被类的所有实例所继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例的方法来调用。
    实例对象
        类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例对象所共享的。定义在实例上的非函数属性，实际上是实例         的字段。


在javascript中定义类的步骤可以缩减为一个分三步的算法。第一步，先定义一个构造函数，并设置初始化新对象的实例属性。第二步，给构造函数的prototype对象定义实例的方法。第三步，给构造函数定义类字段和类属性。我们可以将这三个步骤封装进一个简单的defineClass()函数中（这里用到了例6-2中的extend()函数和例8-3中的改进版）：
```javascript
//一个用以定义简单类的函数
function defineClass(constructor, //用以设置实例的属性的函数
                    method, //实例的方法，复制至原型中
                    statics)    //类属性，复制至构造函数中
{
    if(methods) extend(constructor.prototype, methods);
    if(statics) extend(constructor, statics);
    return constructor;
}
//这是Range类的另一个实现
var SimpleRange =
    defineClass(function(f,t) {this.f = f; this.t = t;},
                {
                    includes: function(x) {return this.f <= x && x <= this.t;},
                    toString: function() {return this.f + "..." + this.t;},
                },
                { upto: function(t) { return new SimpleRange(o,t);} });
```
例9-3中国定义类的代码更长一些。这里定义了一个表示复数的类，这段代码展示了如何使用javascript来模拟实现java式的类成员。例9-3中的代码没有用到上面的defineClass()函数，而是“手动”来实现：
例9-3：Complex.js 表示复数的类
```javascript
/*
 * Complex.js:
 * This file defines a Complex class to represent complex numbers.
 * Recall that a complex number is the sum of a real number and an
 * imaginary number and that the imaginary number i is the square root of -1.
 * 这个文件定义了Complex类，用来描述复数，回忆一下，复数是实数和虚数的和，并且虚数i是-1的平方根
 */

/*
 * This constructor function defines the instance fields r and i on every
 * instance it creates.  These fields hold the real and imaginary parts of
 * the complex number: they are the state of the object.
 * 这个构造函数为它所创建的每个实例定义了实例字段r和i
 * 这两个字段分别保存复数的实部和虚部，它们是对象的状态
 */
function Complex(real, imaginary) {
    if (isNaN(real) || isNaN(imaginary)) // Ensure that both args are numbers，确保两个实参都是数字
        throw new TypeError();           // Throw an error if they are not，如果不都是数字则抛出错误
    this.r = real;                       // The real part of the complex number，复数的实部
    this.i = imaginary;                  // The imaginary part of the number，复数的虚部
}

/*
 * The instance methods of a class are defined as function-valued properties
 * of the prototype object.  The methods defined here are inherited by all
 * instances and provide the shared behavior of the class. Note that JavaScript
 * instance methods must use the this keyword to access the instance fields.
 * 类的实例方法定义为原型对象的函数值属性，这里定义的方法可以被所有实例继承，并为它们提供共享的行为
 * 需要注意的是，javascript的实例方法必须使用关键字this来存取实例的字段
 */

// Add a complex number to this one and return the sum in a new object.
// 当前复数对象加上另一个复数，并返回一个新的计算和值后的复数对象
Complex.prototype.add = function(that) {
    return new Complex(this.r + that.r, this.i + that.i);
};

// Multiply this complex number by another and return the product.
// 当前复数乘以另外一个复数，并返回一个新的计算乘积之后的复数对象
Complex.prototype.mul = function(that) {
    return new Complex(this.r * that.r - this.i * that.i,
                       this.r * that.i + this.i * that.r);
};

// Return the real magnitude of a complex number. This is defined
// as its distance from the origin (0,0) of the complex plane.
//计算复数的模，复数的模定义为原点(0,0)到复平面的距离
Complex.prototype.mag = function() {
    return Math.sqrt(this.r*this.r + this.i*this.i);
};

// Return a complex number that is the negative of this one.
// 复数的求负运算
Complex.prototype.neg = function() { return new Complex(-this.r, -this.i); };

// Convert a Complex object to a string in a useful way.
// 将复数对象转换为一个字符串
Complex.prototype.toString = function() {
    return "{" + this.r + "," + this.i + "}";
};

// Test whether this Complex object has the same value as another.
// 检测当前复数对象是否和另一个复数值相等
Complex.prototype.equals = function(that) {
    return that != null &&                      // must be defined and non-null，必须有定义且不能是null
        that.constructor === Complex &&         // and an instance of Complex，并且必须是Complex的实例
        this.r === that.r && this.i === that.i; // and have the same values，并且必须包含相同的值
};

/*
 * Class fields (such as constants) and class methods are defined as 
 * properties of the constructor. Note that class methods do not 
 * generally use the this keyword: they operate only on their arguments.
 * 类字段（比如常量）和类方法直接定义为构造函数的属性
 * 需要注意的是，类的方法通常不使用关键字this，
 * 它们只对其参数进行操作
 */

// Here are some class fields that hold useful predefined complex numbers.
// 这里预定义了一些对复数运算有帮助的类字段
// Their names are uppercase to indicate that they are constants.
// 它们的命名全都是大写的，用以表明它们是常量
// (In ECMAScript 5, we could actually make these properties read-only.)
// （在ECMAScript5中，还能设置这些类字段的属性为只读）
Complex.ZERO = new Complex(0,0);
Complex.ONE = new Complex(1,0);
Complex.I = new Complex(0,1);

// This class method parses a string in the format returned by the toString
// 这个类方法将由实例对象的toString方法返回的字符串格式解析为一个Complex对象
// instance method and returns a Complex object or throws a TypeError.
// 或者抛出一个类型错误异常
Complex.parse = function(s) {
    try {          // Assume that the parsing will succeed，假设解析成功
        var m = Complex._format.exec(s);  // Regular expression magic，利用正则表达式进行匹配
        return new Complex(parseFloat(m[1]), parseFloat(m[2]));
    } catch (x) {  // And throw an exception if it fails，如果解析失败则抛出异常
        throw new TypeError("Can't parse '" + s + "' as a complex number.");
    }
};

// A "private" class field used in Complex.parse() above.
// The underscore in its name indicates that it is intended for internal
// use and should not be considered part of the public API of this class.
// 定义类的“私有”字段，这个字段在Complex.parse()中用到了，下划线前缀表明它是类内部使用的，而不属于类的公有API的部分
Complex._format = /^\{([^,]+),([^}]+)\}$/;
```

从例9-3中所定义的Complex类可以看出，我们用到了构造函数、实例字段、实例方法、类字段和类方法，看一下这段示例代码：
```javascript
var c = new Complex(2, 3); //使用构造函数创建新的对象
var d = new Complex(c.i, c.r); //用到了c的实例属性
c.add(d).toString(); //=>"{5,5}" 使用了实例的方法
//这个稍微复杂的表达式用到了类方法和类字段
Complex.parse(c.toString()). //将c转换为字符串
    add(c.neg()).           //加上它的负数
    equals(Complex.ZERO)    //结果应当永远是“零”
```

尽管javascript可以模拟出java式的类成员，但java中有很多重要的特性是无法在javascript类中模拟的。首先，对于java类的实例方法来说，实例字段可以用做局部变量，而不需要使用关键字this来引用它们。javascript是没办法模拟这个特性的，但可以使用with语句来近似地实现这个功能（但这种做法并不推荐）：
```javascript
Complex.prototype.toString = function() {
    with(this) {
        return "{" + r + "," + i + "}";
    }
};
```
在java中可以使用final声明字段为常量，并且可以将字段和方法声明为private，用以表示它们是私有成员且在类的外面是不可见的。在javascript中没有这些关键字。例9-3中使用了一些命名写法上的约定来给出一些暗示，比如哪些成员是不能修改的（以大写字母命名的命名），哪些成员在类外部是不可见的（以下划线为前缀的命名）。关于这两个主题的讨论在本章后续还会碰到：私有属性可以使用闭包里的局部变量来模拟（参照9.6.6节），常量属性可以在ECMAScript5中直接实现（参照9.8.2节）。

**9.4类的扩充**

javascript中基于原型的继承机制是动态的：对象从其原型继承属性，如果创建对象之后原型的属性发生改变，也会影响到继承这个原型的所有实例对象。这意味着我们可以通过给原型对象添加新方法来扩充javascript类。这里我们给例9-3中的Complex类添加方法来计算复数的共轭复数。（两个实部相等，虚部互为相反数的复数互为共轭复数）
```javascript
//返回当前复数的共轭复数
Complex.prototype.conj = function() { return new Complex(this.r, -this.i); };
```
javascript内置类的原型对象也是一样如此“开放”，也就是说可以给数字、字符串、数组、函数等数据类型添加方法。在例8-5中我们曾给ECMAScript3中的函数类添加了bind()方法，这个方法原来是没有的：
```javascript
if (!Function.prototype.bind) {
    Function.prototype.bind = function(o /*, args*/) {
        //bind()方法的代码...
    }
}
```
这里有一些其他的例子：
```javascript
//多次调用这个函数f，传入一个迭代数
//比如，要输出“hello”三次：
//var n = 3；
//n.times(function(n) { console.log(n + " hello"); });
Number.prototype.times = function(f, context) {
    var n = Number(this);
    for(var i = 0; i < n; i++) f.call(context, i);
};
//如果不存在ES5的String.trim()方法的话，就定义它
//这个方法用以去除字符串开头和结尾的空格
String.prototype.trim = String.prototype.trim || function() {
    if (!this) return this; //空字符串不做处理
    return this.replace(/^\s+|\s+$/g, "");//使用正则表达式进行空格替换
};
//返回函数的名字，如果它有（非标准）name属性，则直接使用name属性
//否则，将函数转换为字符串然后从中提取名字
//如果是没有名字的函数，则返回一个空字符串
function.prototype.getName = function() {
    return this.name||this.toString().match(/function\s*([^()*]\(/)[1];
};
```
可以给Object.prototype添加方法，从而使所有的对象都可以调用这些方法。但这种做法并不推荐，因为在ECMAScript5之前，无法将这些新增的方法设置为不可枚举的，如果给Object.prototype添加属性，这些属性是可以被for/in循环遍历到的。在9.8.1节中会给出ECMAScript5中的一个例子，其中使用Object.defineProperty()方法可以安全地扩充Object.prototype。

然而并不是所有的宿主环境（比如web浏览器）都可以使用Object.defineProperty()，这跟ECMAScript的具体实现有关。比如，在很多web浏览器中，可以给HTMLElement.prototype添加方法，这样当前文档中表示HTML标记的所有对象就可以继承这些方法。但当前版本的IE则不支持这样做。这时客户端编程实用技术有着严重的限制。

**9.5类和类型**

回想一下第3章的内容，javascript定义了少量的数据类型：null、undefined、布尔值、数字、字符串、函数和对象。typeof运算符（见4.13.2节）可以得出值的类型。然而，我们往往更希望将类作为类型来对待，这样就可以根据对象所属的类来区分它们。javascript语言核心中的内置对象（通常是指客户端javascript的宿主对象）可以根据它们的class属性（见6.8.2节）来区分彼此，比如在例6-4中用到了classof()函数。但当我们使用本章所提到的技术来定义类的话，实例对象的class属性都是“Object”，这时classof()函数也无用武之地。

接下来的几节介绍了三种用以检测任意对象的类的技术：instanceof运算符，constructor属性，以及构造函数的名字。但每种技术都不甚完美，本节总结讨论了鸭式辩型，这种编程哲学更加关注对象可以完成什么工作（它包含什么方法）而不是对象属于哪个类。

**9.5.1 instanceof运算符**

4.9.4节已经讨论过了instanceof运算符，左操作符是待检测其类的对象，右操作符是定义类的构造函数。
如果o继承自c.prototype，则表达式o instanceof c 值为true。
这里的继承可以不是直接继承，如果o所继承的对象继承自另一个对象，后一个对象继承自c.prototype，这个表达式的运算结果也是true。

正如在本章前面所讲到的，构造函数是类的公共标识，但原型是唯一的标识。尽管instanceof运算符的右操作数是构造函数，但计算过程实际上是检测了对象的继承关系，而不是检测创建对象的构造函数。

如果你想检测对象的原型链上是否存在某个特定的原型对象，有没有不使用构造函数作为中介的方法呢？答案是肯定的，可以使用isPrototypeOf()方法。比如，可以通过如下代码来检测对象r是否是例9-1中定义的范围类的成员：

    range.methods.isPrototypeOf(r); //range.method 是原型对象
    
instanceof运算符和isPrototypeOf()方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。在客户端javascript中还有一个比较严重的不足，就是在多窗口和多框架子页面的web应用中兼容性不佳。每个窗口和框架子页面都具有单独的执行上下文，每个上下文都包含独有的全局变量和一组构造函数。在两个不同框架页面中创建的两个数组继承自两个相同但相互独立的原型对象，其中一个框架页面中的数组不是另一个框架页面的Array()构造函数的实例，instanceof运算结果是false。

**9.5.2 constructor属性**

另一种识别对象是否属于某个类的方法是使用constructor属性。因为构造函数是类的公共标识，所以最直接的方法就是使用constructor属性，比如：
```javascript
function typeAndValue(x) {
    if ( x == null ) return "";//null和undefined没有构造函数
    switch(x.constructor) {
        case Number: return "Number:" + x; //处理原始类型
        case String: return "String:'" + x + "'"; 
        case Date: return "Date: " + x ; //处理内置类型
        case RegExp: return "RegExp: " + x ;
        case Complex: return "Complex: " + x ; //处理自定义类型
    }
}
```
需要注意的是，在代码中关键字case后的表达式都是函数，如果改用typeof运算符或获取到对象的class属性的话，它们应当改为字符串。

使用constructor属性检测对象属于某个类的技术的不足之处和instanceof一样。在多个执行上下文的场景中它是无法正常工作的（比如在浏览器窗口的多个框架子页面中）。在这种情况下，每个框架页面各自拥有独立的构造函数集合，一个框架页面中的Array构造函数和另一个框架页面的Array构造函数不是同一个构造函数。

同样，在javascript中也并非所有的对象都包含constructor属性。在每个新创建的函数原型上默认会有constructor属性，但我们常常会忽觉原型上的constructor属性。比如本章前面的实例代码中所定义的两个类（在例9-1和例9-2中），它们的实例都没有constructor属性。

**9.5.3 构造函数的名称**

使用instanceof运算符和constructor属性来检测对象所属的类有一个主要的问题，在多个执行上下文中存在构造函数的多个副本的时候，这两种方法的检测结果会出错。多个执行上下文中的函数看起来是一模一样的，但它们是相互独立的对象，因此彼此也不相等。

一种可能的解决方案是使用构造函数的名字而不是构造函数本身作为类标识符。一个窗口里的Array构造函数和另一个窗口的Array构造函数是不相等的，但是它们的名字是一样的。在一些javascript的实现中为函数对象提供了一个非标准的属性name，用来表示函数的名称。对于那些没有name属性的javascript实现来说，可以将函数转换为字符串，然后从中提取出函数名（在9.4节中的示例代码给Function类添加了getName()方法，就是使用这种方式来得到函数名）。

例9-4定义的type()函数以字符串的形式返回对象的类型。它用typeof运算符来处理原始值和函数，对于对象来说，它要么返回class属性的值要么返回构造函数的名字。type()函数用到了例6-4中的classof()函数和9.4节中的Function.getName()方法。为了简单起见，这里包含了函数和方法的代码。
例9-4 可以判断值的类型的type()函数
```javascript
/**
 * Return the type of o as a string:
 *   -If o is null, return "null", if o is NaN, return "nan".
 *   -If typeof returns a value other than "object" return that value.
 *    (Note that some implementations identify regexps as functions.)
 *   -If the class of o is anything other than "Object", return that.
 *   -If o has a constructor and that constructor has a name, return it.
 *   -Otherwise, just return "Object".
 * 以字符串形式返回o的类型：
 *    如果o是null，返回“null”，如果o是NaN，返回“nan”
 *    如果typeof返回的值不是“object”，则返回这个值
 *    （注意，有一些javascript的实现将正则表达式识别为函数）
 *    如果o的类不是“object”，则返回这个值
 *    如果o包含构造函数并且这个构造函数具有名称，则返回这个名称
 *    否则，一律返回“object”
 **/
function type(o) {
    var t, c, n;  // type, class, name

    // Special case for the null value，处理null值得特殊情形
    if (o === null) return "null";

    // Another special case: NaN is the only value not equal to itself，另外一种特殊情形，NaN和它自身不相等
    if (o !== o) return "nan";

    // Use typeof for any value other than "object"，如果typeof的值不是”object“，则使用这个值
    // This identifies any primitive value and also functions，这可以识别出原始值的类型和函数
    if ((t = typeof o) !== "object") return t;

    // Return the class of the object unless it is "Object"，返回对象的类名，除非值为”object“
    // This will identify most native objects，这种方式可以识别出大多数的内置对象
    if ((c = classof(o)) !== "Object") return c;

    // Return the object's constructor name, if it has one，如果对象构造函数的名字存在的话，则返回它
    if (o.constructor && typeof o.constructor === "function" &&
        (n = o.constructor.getName())) return n;

    // We can't determine a more specific type, so return "Object"，其他的类型都无法判别，一律返回”object“
    return "Object";
}

// Return the class of an object，返回对象的类
function classof(o) {
    return Object.prototype.toString.call(o).slice(8,-1);
};
    
// Return the name of a function (may be "") or null for nonfunctions
// 返回函数的名字（可能是空字符串），不是函数的话返回null
Function.prototype.getName = function() {
    if ("name" in this) return this.name;
    return this.name = this.toString().match(/function\s*([^(]*)\(/)[1];
};
```
这种使用构造函数名字来识别对象的类的做法和使用constructor属性一样有一个问题：并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。如果使用不带名字的函数定义表达式定义一个构造函数，getName()方法则会返回空字符串：
```javascript
//这个构造函数没有名字
var Complex = function(x,y) {this.r = x; this.i = y;}
//这个构造函数有名字
var Range = function Range(f,t) { this.from = f; this.to = t;}
```

**9.5.4 鸭式辩型**

上式所描述的检测对象的类的各种技术多少都会有些问题，至少在客户端javascript中是如此。解决方法就是规避掉这些问题：不要关注”对象的类是什么“，而是关注”对象能做什么“。这种思考问题的方式在Python和Ruby中非常普遍，称为”鸭式辩型“（这个表述是由作家James Whitcomb Riley提出的）。

    像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子
    
对于javascript程序员来说，这句话可以理解为”如果一个对象可以像鸭子一样走路、游泳并且嘎嘎叫，就认为这个对象是鸭子，哪怕它并不是从鸭子类的原型对象继承来的“。
我们拿例9-2中的Range类来举例好了。起初定义这个类用以描述数字的范围。但要注意，Range()构造函数并没有对实参进行类型检查以确保实参是数字类型。但却将参数使用”>“运算符进行比较运算，因为这里假定它们是可比较的。同样，includes()方法使用"<="运算符进行比较，但没有对范围的结束点进行类似的假设。因为类并没有强制使用特定的类型，它的includes()方法可以作用于任何结束点，只要结束点可以用关系运算符执行比较运算。
```javascript
var lowercase = new Range("a", "z");
var thisYear = new Range(new Date(2009, 0, 1), new Date(2010, 0, 1));
```
Range类的foreach()方法中也没有显式地检测表示范围的结束点的类型，但Math.ceil()和”++“运算符表明它只能对数字结束点进行操作。
另外一个例子，回想一下在7.11节中所讨论的类数组对象。在很多场景下，我们并不知道一个对象是否真的是Array的实例，当然是可以通过判断是否包含非负的length属性来得知是否是Array的实例。我们说”包含一个值是非负整数的length“是数组的一个特征——“会走路”，任何具有“会走路”这个特征的对象都可以当做数组来对待（在很多情形中）。

然而必须要了解的是，真正数组的length属性有一些独有的行为：当添加新的元素时，数组的长度会自动更新，并且当给length属性设置一个更小的整数时，数组会自动截断。我们说这些特征是“会游泳”和“嘎嘎叫”。如果所实现的代码需要“会游泳”且能“嘎嘎叫”，则不能使用只“会走路”的类似数组的对象。

上文所讲到的鸭式辩型的例子提到了进行对象的“<”运算符的职责以及length属性的特殊行为。但当我们提到鸭式辩型时，往往是说检测对象是否实现了一个或多个方法。一个强类型的triathlon()函数所需要的参数必须是TriAthlete对象。而一种“鸭式辩型”式的做法是，只要对象包含walk()、swim()和bike()这三个方法就可以作为参数传入。同理，可以重新设计Range类，使用结束点对象的compareTo()和succ()（successor）方法来代替“<”和“++”运算符。

鸭式辩型的实现方法让人感觉太“放任自流”：仅仅是假设输入对象实现了必要的方法，根本没有执行进一步的检查。如果输入对象没有遵循“假设”，那么当代码试图调用那些不存在的方法时就会报错。另一种实现方法是对输入对象进行检查。但不是检查它们的类，而是用适合的名字来检查它们所实现的方法。这样可以将非法输入尽可能早地拦截在外，并可给出带有更多提示信息的报错。

例9-5中按照鸭式辩型的理念定义了quacks()函数（函数名叫“implements”会更加合适，但implement是保留字）。quacks()用以检查一个对象（第一个实参）是否实现了剩下的参数所表示的方法。对于除第一个参数外的每个参数，如果是字符串的话则直接检查是否存在以它命名的方法；如果是对象的话则检查第一个对象中的方法是否在这个对象中也具有同名的方法；如果参数是函数，则假定它是构造函数，函数将检查第一个对象实现的方法是否在构造函数的原型对象中也具有同名的方法。

例9-5 利用鸭式辩型实现的函数
```javascript
// Return true if o implements the methods specified by the remaining args.
// 如果o实现了除第一个参数之外的参数所表示的方法，则返回true
function quacks(o /*, ... */) {
    for(var i = 1; i < arguments.length; i++) {  // for each argument after o，遍历o之后的所有参数
        var arg = arguments[i];
        switch(typeof arg) { // If arg is a:如果参数是
        case 'string':       // string: check for a method with that name直接用名字做检查
            if (typeof o[arg] !== "function") return false;
            continue;
        case 'function':     // function: use the prototype object instead，检查函数的原型对象上的方法
            // If the argument is a function, we use its prototype object，如果实参是函数，则使用它的原型
            arg = arg.prototype;// fall through to the next case，进入下一个case
        case 'object':       // object: check for matching methods，检查匹配的方法
            for(var m in arg) { // For each property of the object，遍历对象的每个属性
                if (typeof arg[m] !== "function") continue; // skip non-methods，跳过不是方法的属性
                if (typeof o[m] !== "function") return false;
            }
        }
    }
    // If we're still here, then o implements everything，如果程序能执行到这里，说明o实现了所有的方法
    return true;
}
```
关于这个quacks()函数还有一些地方是需要尤为注意的。首先，这里只是通过特定的名称来检测对象是否含有一个或多个值为函数的属性。我们无法得知这些已经存在的属性的细节信息，比如，函数是干什么用的？它们需要多少参数？参数类型是什么？然而这是鸭式辩型的本质所在，如果使用鸭式辩型而不是强制的类型检测的方式定义API，那么创建的API应当更具有灵活性才可以，这样才能确保你提供给用户的API更加安全可靠。关于quacks()函数还有另一问题需要注意，就是它不能应用于内置类。比如，不能通过quacks(o,Array)来检测o是否实现了Array中所有同名的方法。原因是内置类的方法都是不可枚举的，quacks()中的for/in循环无法遍历到它们（注意，在ECMAScript5中有一个补救方法，就是使用Object.getOwnPropertyNames()）。

**9.6javascript中的面向对象技术**

到目前为止，我们讨论了javascript中类的基础知识：原型对象的重要性、它和构造函数之间的联系、instanceof运算符如何工作等。本节将目光转向一些实际的例子（尽管这不是基础知识），包括如何利用javascript中的类进行编程。我们从两个重要的例子开始，这两个例子中实现的类非常有意思，接下来的讨论都将基于此作展开。

**9.6.1 一个例子：集合类**

集合（set）是一种数据结构，用以表示非重复值的无序集合。集合的基础方法包括添加值、检测值是否在集合中，这种集合需要一种通用的实现，以保证操作效率。javascript的对象是属性名以及与之对应的值的基本集合。因此将对象只用做字符串的集合是大材小用。例子9-6用javascript实现了一个更加通用的Set类，它实现了从javascript值到唯一字符串的映射，然后将字符串用做属性名。对象和函数都不具备如此简明可靠的唯一字符串表示。因此集合类必须给集合中的每一个对象或函数定义一个唯一的属性标志。

例9-6：Set.js 值的任意集合
```javascript
function Set() {          // This is the constructor，这是一个构造函数
    this.values = {};     // The properties of this object hold the set，集合数据保存在对象的属性里
    this.n = 0;           // How many values are in the set，集合中值的个数
    this.add.apply(this, arguments);  // All arguments are values to add，把所有参数都添加进这个集合
}

// Add each of the arguments to the set，将每个参数都添加至集合中
Set.prototype.add = function() {
    for(var i = 0; i < arguments.length; i++) {  // For each argument，遍历每个参数
        var val = arguments[i];                  // The value to add to the set，待添加到集合中的值
        var str = Set._v2s(val);                 // Transform it to a string，把它转换为字符串
        if (!this.values.hasOwnProperty(str)) {  // If not already in the set，如果不在集合中
            this.values[str] = val;              // Map string to value，将字符串和值对应起来
            this.n++;                            // Increase set size，集合中值的计数加一
        }
    }
    return this;                                 // Support chained method calls，支持链式方法调用
};

// Remove each of the arguments from the set，从集合删除元素，这些元素由参数指定
Set.prototype.remove = function() {
    for(var i = 0; i < arguments.length; i++) {  // For each argument，遍历每个参数
        var str = Set._v2s(arguments[i]);        // Map to a string，将字符串和值对应起来
        if (this.values.hasOwnProperty(str)) {   // If it is in the set，如果它在集合中
            delete this.values[str];             // Delete it，删除它
            this.n--;                            // Decrease set size，集合中指的计数减一
        }
    }
    return this;                                 // For method chaining，支持链式方法调用
};

// Return true if the set contains value; false otherwise.
// 如果集合包含这个值，则返回true，否则，返回false
Set.prototype.contains = function(value) {
    return this.values.hasOwnProperty(Set._v2s(value));
};

// Return the size of the set，返回集合的大小
Set.prototype.size = function() { return this.n; };

// Call function f on the specified context for each element of the set.
// 遍历集合中的所有元素，在指定的上下文中调用f
Set.prototype.foreach = function(f, context) {
    for(var s in this.values)                 // For each string in the set，遍历集合中的所有字符串
        if (this.values.hasOwnProperty(s))    // Ignore inherited properties，忽略继承的属性
            f.call(context, this.values[s]);  // Call f on the value，调用f，传入value
};

// This internal function maps any JavaScript value to a unique string.
// 这是一个内部函数，用以将任意javascript值和唯一的字符串对应起来
Set._v2s = function(val) {
    switch(val) {
        case undefined:     return 'u';          // Special primitive，特殊的原始值
        case null:          return 'n';          // values get single-letter，值只有一个字母
        case true:          return 't';          // codes，代码
        case false:         return 'f';
        default: switch(typeof val) {
            case 'number':  return '#' + val;    // Numbers get # prefix，数字带有#前缀
            case 'string':  return '"' + val;    // Strings get " prefix，字符串都带有"前缀
            default: return '@' + objectId(val); // Objs and funcs get @
        }
    }

    // For any object, return a string. This function will return a different
    // string for different objects, and will always return the same string
    // if called multiple times for the same object. To do this it creates a
    // property on o. In ES5 the property would be nonenumerable and read-only.
    // 对任意对象来说，都会返回一个字符串
    // 针对不同的对象，这个函数会返回不同的字符串
    // 对于同一个对象的多次调用，总是返回相同的字符串
    // 为了做到这一点，它给o创建了一个属性，在ES5中，这个属性是不可枚举且是只读的
    function objectId(o) {
        var prop = "|**objectid**|";   // Private property name for storing ids，私有属性，用以存放id
        if (!o.hasOwnProperty(prop))   // If the object has no id，如果对象没有id
            o[prop] = Set._v2s.next++; // Assign it the next available，将下一个值赋给它
        return o[prop];                // Return the id，返回这个id
    }
};
Set._v2s.next = 100;    // Start assigning object ids at this value，设置初始id的值
```

**9.6.2 一个例子：枚举类型**

枚举类型（enumerable type）是一种类型，它是值的有限集合，如果值定义为这个类型则该值是可列出（或“可枚举”）的。在C及其派生语言中，枚举类型是通过关键字enum声明的。Enum是ECMAScript5中的保留字（还未使用），很有可能在将来javascript就会内置支持枚举类型。到那时，例9-7展示了如何在javascript中定义枚举类型的数据。需要注意的是，这里用到了例6-1中的inherit()函数。

例9-7包含一个单独函数enumeration()。但它不是构造函数，它并没有定义一个名叫“enumeration”的类。相反，它是一个工厂方法，每次调用它都会创建并返回一个新的类，比如：
```javascript
//使用4个值创建新的Coin类，Coin.Penny，Coin.Nickel等
var Coin = enumeration({Penny:1, Nickel:5, Dime:10, Quarter:25});
var c = Coin.Dime; //这是新类的实例
c instanceof Coin //=>true instanceof正常工作
c.constructor == Coin//=>true 构造函数的属性正常工作
Coin.Quarter + 3*Coin.Nickel //=>40 将值转换为数字
Coin.Dime == 10 //=>true 更多转换为数字的例子
Coin.Dime > Coin.Nickel //=>true 关系运算符正常工作
String(Coin.Dime)+ ":" + Coin.Dime //=>"Dime:10" 强制转换为字符串
```
这个例子清楚地展示了javascript类的灵活性，javascript的类要比C++和java语言中的静态类要更加灵活。

例9-7 javascript中的枚举类型
```javascript
// This function creates a new enumerated type.  The argument object specifies
// the names and values of each instance of the class. The return value
// is a constructor function that identifies the new class.  Note, however
// that the constructor throws an exception: you can't use it to create new
// instances of the type.  The returned constructor has properties that 
// map the name of a value to the value itself, and also a values array,
// a foreach() iterator function
// 这个函数创建一个新的枚举类型，实参对象表示类的每个实例的名字和值
// 返回值是一个构造函数，它标识这个新类
// 注意，这个构造函数也会抛出异常，不能使用它来创建该类型的新实例
// 返回的构造函数包含名/值对的映射表
// 包括由值组成的数组，以及一个foreach()迭代器函数
function enumeration(namesToValues) {
    // This is the dummy constructor function that will be the return value.
    // 这个虚拟的构造函数是返回值
    var enumeration = function() { throw "Can't Instantiate Enumerations"; };

    // Enumerated values inherit from this object.
    // 枚举值继承自这个对象
    var proto = enumeration.prototype = {
        constructor: enumeration,                   // Identify type，标识类型
        toString: function() { return this.name; }, // Return name，返回名字
        valueOf: function() { return this.value; }, // Return value，返回值
        toJSON: function() { return this.name; }    // For serialization，转换为JSON
    };

    enumeration.values = [];  // An array of the enumerated value objects，用以存放枚举对象的数组

    // Now create the instances of this new type.
    // 现在创建新类型的实例
    for(name in namesToValues) {         // For each value ，遍历每个值
        var e = inherit(proto);          // Create an object to represent it，创建一个代表它的对象
        e.name = name;                   // Give it a name，给它一个名字
        e.value = namesToValues[name];   // And a value，给它一个值
        enumeration[name] = e;           // Make it a property of constructor，将它设置为构造函数的属性
        enumeration.values.push(e);      // And store in the values array，将它存储到值数组中
    }
    // A class method for iterating the instances of the class
    // 一个类方法，用来对类的实例进行迭代
    enumeration.foreach = function(f,c) {
        for(var i = 0; i < this.values.length; i++) f.call(c,this.values[i]);
    };

    // Return the constructor that identifies the new type
    // 返回标识这个新类型的构造函数
    return enumeration;
}
```
如果用这个枚举类型来实现一个“hello world”小程序的话，就可以使用枚举类型来表示一副扑克牌。
例9-8使用enumeration()函数实现了这个表示一副扑克牌的类。
例9-8 使用枚举类型来表示一副扑克牌
```javascript
// Define a class to represent a playing card
// 定义一个表示“玩牌”的类
function Card(suit, rank) {
    this.suit = suit;         // Each card has a suit，每张牌都有花色
    this.rank = rank;         // and a rank，以及点数
}

// These enumerated types define the suit and rank values
// 使用枚举类型定义花色和点数
Card.Suit = enumeration({Clubs: 1, Diamonds: 2, Hearts:3, Spades:4});
Card.Rank = enumeration({Two: 2, Three: 3, Four: 4, Five: 5, Six: 6,
                         Seven: 7, Eight: 8, Nine: 9, Ten: 10,
                         Jack: 11, Queen: 12, King: 13, Ace: 14});

// Define a textual representation for a card
// 定义用以描述牌面的文本
Card.prototype.toString = function() {
    return this.rank.toString() + " of " + this.suit.toString();
};
// Compare the value of two cards as you would in poker
// 比较扑克牌中两张牌的大小
Card.prototype.compareTo = function(that) {
    if (this.rank < that.rank) return -1;
    if (this.rank > that.rank) return 1;
    return 0;
};

// A function for ordering cards as you would in poker
// 以扑克牌的玩法规则对牌进行排序的函数
Card.orderByRank = function(a,b) { return a.compareTo(b); };

// A function for ordering cards as you would in bridge 
// 以桥牌的玩法规则对扑牌进行排序的函数
Card.orderBySuit = function(a,b) {
    if (a.suit < b.suit) return -1;
    if (a.suit > b.suit) return 1;
    if (a.rank < b.rank) return -1;
    if (a.rank > b.rank) return  1;
    return 0;
};

// Define a class to represent a standard deck of cards
// 定义用以表示一副标准扑克牌的类
function Deck() {
    var cards = this.cards = [];     // A deck is just an array of cards，一副牌就是由牌组成的数组
    Card.Suit.foreach(function(s) {  // Initialize the array，初始化这个数组
                          Card.Rank.foreach(function(r) {
                                                cards.push(new Card(s,r));
                                            });
                      });
}
 
// Shuffle method: shuffles cards in place and returns the deck
// 洗牌的方法：重新洗牌并返回洗好的牌
Deck.prototype.shuffle = function() { 
    // For each element in the array, swap with a randomly chosen lower element
    // 遍历数组中的每个元素，随机找出牌面最小的元素，并与之（当前遍历的元素）交换
    var deck = this.cards, len = deck.length;
    for(var i = len-1; i > 0; i--) {
        var r = Math.floor(Math.random()*(i+1)), temp;     // Random number，随机数
        temp = deck[i], deck[i] = deck[r], deck[r] = temp; // Swap，交换
    }
    return this;
};

// Deal method: returns an array of cards，发牌的方法：返回牌的数组
Deck.prototype.deal = function(n) {  
    if (this.cards.length < n) throw "Out of cards";
    return this.cards.splice(this.cards.length-n, n);
};

// Create a new deck of cards, shuffle it, and deal a bridge hand
// 创建一副新扑克牌，洗牌并发牌
var deck = (new Deck()).shuffle();
var hand = deck.deal(13).sort(Card.orderBySuit);
```

**9.6.3 一个例子：标准转换方法**

3.8.3和6.10节讨论了对象类型转换所用到的重要方法，有一些方法是在需要做类型转换时由javascript解释器自动调用的。不需要为定义的每个类都实现这些方法，但这些方法的确非常重要，如果没有为自定义的类实现这些方法，也应当是有意为之，而不应当因为疏忽而漏掉它们。

最重要的方法首当toString()。这个方法的作用是返回一个可以表示这个对象的字符串。在希望使用字符串的地方用到对象的话（比如将对象用做属性名或使用“+”运算符来进行字符串连接运算），javascript会自动调用这个方法。如果没有实现这个方法，类会默认从Object.prototype中继承toString()方法，这个方法的运算结果是“[Object Object]”，这个字符串用处不大。
toString()方法应当返回一个可读的字符串，这样最终用户才能将这个输出值利用起来，然而有时候并不一定非要如此，不管怎样，可以返回可读字符串的toString()方法也会让程序调试变得更加轻松。例9-2和例9-3中的Range类和Complex类都定义了toString()方法，例9-7中的枚举类型也定义了toString()。下面我们会给例9-6中的set类也定义toString()方法。

toLocaleString()和toString()极为类似：toLocaleString()是以本地敏感性（locale-sensitive）的方式来将对象转换为字符串。默认情况下，对象所继承的toLocaleString()方法只是简单地调用toString()方法。有一些内置类型包含有用的toLocaleString()方法用以实际上返回本地化相关的字符串。如果需要为对象到字符串的转换定义toString()方法，那么同样需要定义toLocaleString()方法用以处理本地化的对象到字符串的转换。下面的Set类的定义中会有相关的代码。

第三个方法是valueOf()，它用来将对象转换为原始值。比如，当数学运算符（除了“+”运算符）和关系运算符作用于数字文本表示的对象时，会自动调用valueOf()方法。大多数对象都没有合适的原始值来表示它们，也没有定义这个方法。但在例9-7中的枚举类型的实现则说明valueOf()方法是非常重要的。

第四个方法是toJSON()，这个方法是由JSON.stringify()自动调用的。JSON格式用于序列化良好的数据结构，而且可以处理javascript原始值、数组和纯对象。它和类无关，当对一个对象执行序列化操作时，它会忽略对象的原型和构造函数。比如将Range对象或Complex对象作为参数传入JSON.stringify()，将会返回诸如{"from:1", "to":3}或{"r":1, "i":-1}这种字符串。
如果将这些字符串传入JSON.parse()，则会得到一个和Range对象和Complex对象具有相同属性的纯对象，但这个对象不会包含从Range和Complex继承来的方法。
这种序列化操作非常适用于诸如Range和Complex这种类，但对于其他一些类则必须自定义toJSON()方法来定制个性化的序列化格式。如果一个对象有toJSON()方法，JSON.stringify()并不会对传入的对象做序列化操作，而会调用toJSON()来执行序列化操作（序列化的值可能是原始值也可能是对象）。比如，Date对象的toJSON()方法可以返回一个表示日期的字符串。例9-7中的枚举类型也是如此：它们的toJSON()方法和toString()方法完全一样。如果要模拟一个集合，最接近JSON的表示方法就是数组，因此在下面的例子中将定义toJSON()方法用以将集合对象转换为值数组。
例9-6中的Set类并没有定义上述方法中的任何一个。javascript中没有哪个原始值可以表示集合，因此也没必要定义valueOf()方法，但该类应当包含toString()、toLocaleString()和toJSON()方法。可以用如下代码来实现。注意extend()函数（例6-2）的用法，这里使用extend()来向Set.prototype来添加方法：
```javascript
//将这些方法添加至Set类的原型对象中
extend(Set.prototype,{
    //将集合转换为字符串
    toString: function () {
        var s = "{",
        i = 0;
        this.foreach(function (v) {s +=((i++>0)? ", " : "") + v;});
        return s + "}";
    },
    //类似toString，但是对于所有的值都将调用toLocaleString()
    toLocaleString: function () {
        var s = "{", i=0;
        this.foreach(function (v){
            if (i++>0) s += ", ";
            if (v == null) s += v; //null和undefined
            else s += v.toLocaleString(); //其他情况
        });
    },
    //将集合转换为值数组
    toArray: function () {
        var a = [];
        this.foreach(function (v) {a.push(v);});
    }
});
//对于要从JSON转换为字符串的集合都被当做数组来对待
Set.prototype.toJSON = Set.prototype.toArray;
```

**9.6.4 比较方法**

javascript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看它们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和相同的属性值，而是直接比较这两个单独的对象是否相等，或者比较它们的顺序（就像“<”和“>”运算符进行的比较一样）。如果定义一个类，并且希望比较类的实例，应该定义合适的方法来执行比较操作。

java编程语言有很多用于对象比较的方法，将java中的这些方法借用到javascript中是一个不错的主意。为了能让自定义类的实例具备比较的功能，定义一个名叫equals()实例方法。这个方法只能接收一个参数，如果这个实参和调用此方法的对象相等的话则返回true。当然，这里所说的“相等”的含义是根据类的上下文来决定的。对于简单的类，可以通过简单地比较它们的constructor属性来确保两个对象是相同类型，然后比较两个对象的实例属性以保证它们的值相等。例9-3中的Complex类就实现了这样的equals()方法，我们可以轻易地为Range类也实现类似的方法：
```javascript
//Range类重写它的constructor属性，现在将它添加进去
Range.prototype.constructor = Range;
//一个Range对象和其他不是Range的对象均不相等
//当且仅当两个范围的端点相等，它们才相等
Range.prototype.equals = function(that) {
    if (that == null) return false; //处理null和undefined
    if (that.constructor !== Range) return false; //处理非Range对象
    //当且仅当两个端点相等，才返回true
    return this.from == that.from && this.to == this.to;
}
```
给Set类定义equals()方法稍微有些复杂。不能简单地比较两个集合的values属性，还要进行更深层次的比较：
```javascript
Set.prototype.equals = function (that) {
    //一些次要情况的快捷处理
    if (this === that) return true;
    //如果that对象不是一个集合，它和this不相等
    //我们用到了instanceof，使得这个方法可以用于Set的任何子类
    //我们希望采用鸭式辩型的方法，可以降低检查的严格程度
    //或者可以通过 this.constructor == that.constructor 来加强检查的严格程度
    //注意，null和undefined两个值是无法用于instanceof运算的
    if (!(that instanceof Set)) return false;
    //如果两个集合的大小不一样，则它们不相等
    if (this.size() != that.size()) return false;
    //现在检查两个集合中的元素是否完全一样
    //如果两个集合不相等，则通过抛出异常来终止foreach循环
    try {
        this.foreach(function (v) { if (!that.contains(v)) throw false; });
        return true; //所有的元素都匹配：两个集合相等
    } catch(x) {
        if (x === false) return false; //如果集合中有元素在另外一个集合中不存在
        throw x; //重新抛出异常
    }
};
```
按照我们需要的方式比较对象是否相等常常是很有用的。对于某些类来说，往往需要比较一个实例“大于”或者“小于”另外一个示例。比如，你可能会基于Range对象的下边界来定义实例的大小关系。枚举类型可以根据名字的字母表顺序来定义实例的大小，也可以根据它包含的数值（假设它包含的都是数字）来定义大小。另一方面，Set对象其实是无法排序的。

如果将对象用于javascript的关系比较运算符，比如“<”和“<=”，javascript会首先调用对象的valueOf()方法，如果这个方法返回一个原始值，则直接比较原始值。例9-7中由enumeration()方法所返回的枚举类型包含valueOf()方法，因此可以使用关系运算符对它们做有意义的比较。但大多数类并没有valueOf()方法，为了按照显式定义的规则来比较这些类型的对象，可以定义一个名叫copareTo()方法（同样，这里遵循Java中的命名约定）。

compareTo()方法应当只能接收一个参数，这个方法将这个参数和调用它的对象进行比较。如果this对象小于参数对象，compareTo()迎丹返回比0小的值。如果this对象大于参数对象，应当返回比0大的值。如果两个对象相等，应当返回0。这些关于返回值的约定非常重要，这样我们可以用下面的表达式替换掉关系比较和相等性运算符：

|待替换|替换为|
|------|------|
|a<b|a.compareTo(b)<0|
|a<=b|a.compareTo(b)<=0|
|a>b|a.compareTo(b)>0|
|a>=b|a.compareTo(b)>=0|
|a==b|a.compareTo(b)==0|
|a!=b|a.compareTo(b)!=0|

例9-8中的Card类定义了该类的compareTo()方法，可以给Range类添加一个类似的方法，用以比较它们的下边界：
```javascript
Range.prototype.compareTo = function(that) {
    return this.from = that.from;
};
```
需要注意的是，这个方法中的减法操作根据两个Range对象的关系正确地返回了小于0、等于0和大于0的值。例9-8中的Card.Rank枚举值包含valueOf()方法，其实也可以给Card类实现类似的compareTo()方法。

上文所提到的equals()方法对其参数执行了类型检查，如果参数类型不合法则返回false。compareTo()方法并没有返回一个表示“这两个值不能比较”的值，由于compareTo()没有对参数做任何类型检查，因此如果给compareTo()方法传入错误类型的参数，往往会抛出异常。

注意，如果两个范围对象的下边界相等，为Range类定义的compareTo()方法会返回0.这意味着就compareTo()而言，任何两个起始点相同的Range对象都相等。这个相等概念的定义和equals()方法定义的相等概念是相背的，equals()要求两个端点均相等才算相等。这种相等概念上的差异性会造成很多bug，最好将Range类的equals()和compareTo()方法中处理相等的逻辑保持一致，但当出入不可比较的值时仍然会报错：
```javascript
//根据下边界来对Range对象排序，如果下边界相等则比较上边界
//如果传入非Range值，则抛出异常
//当且仅当this.equals(that)时，才返回0
Range.prototype.compareTo = function(that) {
    if (!(that instanceof Range))
        throw new Error("Can't compare a Range with " + that);
    var diff = this.from - that.from; //比较下边界
    if (diff == 0) diff = this.to - that.to; //如果相等，比较上边界
    return diff;
};
```
给类定义了compareTo()方法，这样就可以对类的实例组成的数组进行排序了。Array.sort()方法可以接收一个可选的参数，这个参数是一个函数，用来比较两个值的大小，这个函数返回值的约定和compareTo()方法保持一致。假定有了上文提到的compareTo()方法，就可以很方便地对Range对象组成的数组进行排序了：

    range.sort(function(a,b) {return a.compareTo(b); });
    
排序运算非常重要，如果已经为类定义了实例方法compareTo()，还应当参照这个方法定义一个可传入两个参数的比较函数。使用compareTo()方法可以非常轻松地定义这个函数，比如：

    Range.byLowerBound = function(a,b) { return a.compareTo(b); };

使用这个方法可以让数组排序的操作变得非常简单：

    ranges.sort(Range.byLowerBound);
    
有些类可以有很多方法进行排序。比如Card类，可以定义两个方法分别按照花色排序和按照点数排序。

**9.6.5 方法借用**

javascript中的方法没有什么特别：无非是一些简单的函数，赋值给了对象的属性，可以通过对象来调用它。一个函数可以赋值给两个属性，然后作为两个方法来调用它。比如，我们在Set类中就这样做了，将toArray()方法创建了一个副本，并让它可以和toJSON()方法一样完成同样的功能。

多个类中的方法可以共用一个单独的函数。比如，Array类通常定义了一些内置方法，如果定义了一个类，它的实例是类数组的对象，则可以从Array.prototype中将函数复制至所定义的类的原型对象中。如果以经典的面向语言的视角来看javascript的话，把一个类的方法用到其他的类中的做法也称做“多重继承”（multiple inheritance）。然而，javascript并不是经典的面向对象语言，我更倾向于将这种方法重用更正式地称为“方法借用”（borrowing）。

不仅Array的方法可以借用，还可以自定义泛型方法（generic method）。
例9-9定义了泛型方法toString()和equals()，可以被Range、Complex和Card这些简单的类使用。如果Range类没有定义equals()方法，可以这样借用泛型方法equals():

    Range.prototype.equals = generic.equals;

注意，generic.equals()只会执行浅比较，因此这个方法并不适用于其实例太复杂的类，它们的实例属性通过其equals()方法指代对象。同样需要注意，这个方法包含一些特殊情况的程序逻辑，以处理新增至Set对象中的属性（见例9-6）。

例9-9方法借用的泛型实现
```javascript
var generic = {
    // Returns a string that includes the name of the constructor function
    // if available and the names and values of all noninherited, nonfunction
    // properties.
    //返回一个字符串，这个字符串包含构造函数的名字（如果构造函数包含名字）
    //以及所有非继承来的、非函数属性的名字和值
    toString: function() {
        var s = '[';
        // If the object has a constructor and the constructor has a name,
        // use that class name as part of the returned string.  Note that
        // the name property of functions is nonstandard and not supported
        // everywhere.
        // 如果这个对象包含构造函数，且构造函数包含名字
        // 这个名字会作为返回字符串的一部分
        // 需要注意的是，函数的名字属性是非标准的，并不是在所有的环境中都可用
        if (this.constructor && this.constructor.name)
            s += this.constructor.name + ": ";

        // Now enumerate all noninherited, nonfunction properties
        // 枚举所有非继承且非函数的属性
        var n = 0;
        for(var name in this) {
            if (!this.hasOwnProperty(name)) continue;   // skip inherited props，跳过继承来的属性
            var value = this[name];
            if (typeof value === "function") continue;  // skip methods，跳过方法
            if (n++) s += ", ";
            s += name + '=' + value;
        }
        return s + ']';
    },

    // Tests for equality by comparing the constructors and instance properties
    // of this and that.  Only works for classes whose instance properties are
    // primitive values that can be compared with ===.
    // As a special case, ignore the special property added by the Set class.
    // 通过比较this和that的构造函数和实例属性来判断它们是否相等
    // 这种方法只适合于那些实例属性是原始值的情况，原始值可以通过“===”来比较
    // 这里还处理一种特殊情况，就是忽略由Set类添加的特殊属性
    equals: function(that) {
        if (that == null) return false;
        if (this.constructor !== that.constructor) return false;
        for(var name in this) {
            if (name === "|**objectid**|") continue;     // skip special prop，跳过特殊属性
            if (!this.hasOwnProperty(name)) continue;    // skip inherited ，跳过继承来的属性
            if (this[name] !== that[name]) return false; // compare values，比较是否相等
        }
        return true;  // If all properties matched, objects are equal，如果所有属性都匹配，两个对象相等
    }
};
```

**9.6.6 私有状态**

在经典的面向对象编程中，经常需要将对象的某个状态封装或隐藏在对象内，只有通过对象的方法才能访问这些状态，对外只暴露一些重要的状态变量可以直接读写。为了实现这个目的，类似java的编程语言允许声明类的“私有”实例字段，这些私有实例字段只能被类的实例方法访问，且在类的外部是不可见的。
我们可以通过将变量（或参数）闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。为了做到这一点，需要在构造函数内部定义一个函数（因此这个函数可以访问构造函数内部的参数和变量），并将这个函数赋值给新创建对象的属性。例9-10展示了对Range类的另一种封装，新版的类的实例包含from()和to()方法用以返回范围的端点，而不是用from和to属性来获取端点。这里的from()和to()方法是定义在每个Range对象上的，而不是从原型中继承来的。其他的Range方法还是和之前一样定义在原型中，但获取端点的方式从之前直接从属性读取变成了通过from()和to()方法来读取。
例9-10 对Range类的读取端点方法的简单封装
```javascript
function Range(from, to) {
    // Don't store the endpoints as properties of this object. Instead
    // define accessor functions that return the endpoint values.
    // These values are stored in the closure.
    // 不要将端点保存为对象的属性，相反
    // 定义存取器函数来返回端点的值
    // 这些值都保存在闭包中
    this.from = function() { return from; };
    this.to = function() { return to; };
}

// The methods on the prototype can't see the endpoints directly: they have
// to invoke the accessor methods just like everyone else.
// 原型上的方法无法直接操作端点
// 它们必须调用存取器方法
Range.prototype = {
    constructor: Range,
    includes: function(x) { return this.from() <= x && x <= this.to(); },
    foreach: function(f) {
        for(var x=Math.ceil(this.from()), max=this.to(); x <= max; x++) f(x);
    },
    toString: function() { return "(" + this.from() + "..." + this.to() + ")"; }
};
```
这个新的Range类定义了用以读取范围端点的方法，但没有定义设置端点的方法或属性。这让类的实例看起来是不可修改的，如果使用正确的话，一旦创建Range对象，端点数据就不可修改了。除非使用ECMAScript5（参照9.3节）中的某些特性，但from和to属性依然是可写的，并且Range对象实际上并不是真正不可修改的：
```javascript
var r = new Range(1,5); //一个不可修改的范围
r.from = function() {return 0;}; //通过方法替换来修改它
```
但需要注意的是，这种封装技术造成了更多系统的开销。使用闭包来封装类的状态的类一定会比不使用封装的状态变量的等价类运行速度更慢，并占用更多内存。

**9.6.7 构造函数的重载和工厂方法**

有时候，我们希望对象的初始化有多种方式。比如，我们想通过半径和角度（极坐标）来初始化一个Complex对象，而不是通过实部和虚部来初始化，或者通过元素组成的数组来初始化一个Set对象，而不是通过传入构造函数的参数来初始化它。

有一个方法可以实现，通过重载（overload）这个构造函数让它根据传入参数的不同来执行不同的初始化方法。下面这段代码就是重载Set()构造函数的例子：
```javascript
function Set() {
    this.values = {}; //用这个对象的属性来保存这个集合
    this.n = 0; //集合中值的个数
    //如果传入一个类数组的对象，将这个元素添加至集合中
    //否则，将所有的参数都添加至集合中
    if (arguments.length == 1 && isArrayLike(arguments[0]))
        this.add.appley(this, arguments[0]);
    else if (arguments.length > 0)
        this.add.apply(this, arguments);
}
```
这段代码所定义的Set()构造函数可以显式将一组元素作为参数列表传入，也可以传入元素组成的数组。但是这个构造函数有多义性，如果集合的某个成员是一个数组就无法通过这个构造函数来创建这个集合了（为了做到这一点，需要首先创建一个空集合，然后显式调用add()方法）。

在使用极坐标来初始化复数的例子中，实际上并没有看到有函数重载。代表复数两个维度的数字都是浮点数，除非给构造函数传入第三个参数，否则构造函数无法识别到底传入的是极坐标参数还是直角坐标参数。相反，可以写一个工厂方法——一个类的方法用以返回类的一个实例。下面的例子即是使用工厂方法来返回一个使用极坐标初始化的Complex对象：
```javascript
Complex.polar = function(r, theta) {
    return new Complex(r*Math.cos(theta), r*Math.sin(theta));
};
```
下面这个工厂方法用来通过数组初始化Set对象：
```javascript
Set.fromArray = function(a) {
    s = new Set(); //创建一个空集合
    s.add.apply(s, a); //将数组a的成员作为参数传入add()方法
    return s; //返回这个新集合
};
```
可以给工厂方法定义任意的名字，不同名字的工厂方法用以执行不同的初始化。但由于构造函数是类的公有标识，因此每个类只能有一个构造函数。但这并不是一个“必须遵守”的规则。在javascript中是可以定义多个构造函数继承自一个原型对象的，如果这样做的话，由这些构造函数的任意一个所创建的对象都属于同一类型。并不推荐这种技术，但下面的示例代码使用这种技术定义了该类型的一个辅助构造函数：
```javascript
//Set类的一个辅助构造函数
function SetFromArray(a) {
    //通过以函数的形式调用set()来初始化这个新对象
    //将a的元素作为参数传入
    Set.apply(this, a);
}
//设置原型，以便SetFromArray能创建Set的实例
SetFromArray.prototype = Set.prototype;
var s = new SetFromArray([1,2,3]);
s instanceof Set //=>true
```

**9.7子类**

在面向对象编程中，类B可以继承自另一个类A。我们将A称为父类（superclass），将B称为子类（subclass）。B的实例从A继承了所有的实例方法。类B可以定义自己的实例方法，有些方法可以重载类A中的同名方法，如果B的方法重载了A中的方法，B中的重载方法可能会调用A中重载方法，这种做法称为“方法链”（method chaining）。同样，子类的构造函数B()有时需要调用父类的构造函数A()，这种做法称为“构造函数链”（constructor chaining）。
子类还可以有子类，当涉及类的层次结构时，往往需要定义抽象类（abstract class）。
抽象类中定义的方法没有实现。抽象类中的抽象方法是在抽象类的具体子类中实现的。

在javascript中创建子类的关键之处在于，采用合适的方法对原型对象进行初始化。如果类B继承自类A，B.prototype必须是A.prototye的后嗣。B的实例继承自B.prototype，后者同样也继承自A.prototype。
本节将会对刚才提到的子类相关的术语做一一讲解，还会介绍类继承的替代方案：“组合”（composition）。

我们从例9-6中的Set类开始讲解，本节将会讨论如何定义子类，如何实现构造函数链并重载方法，如何使用组合来代替继承，以及最后如何通过抽象类从实现中提炼出接口。本节一个扩展的例子结束，这个例子定义了Set类的层次结构。注意，本节开始的几个例子着重讲述了实现子类的基础技术。其中某些技术有着重要的缺陷，后续几节会讲到。

**9.7.1 定义子类**

javascript的对象可以从类的原型对象中继承属性（通常继承的是方法）。如果O是类B的实例，B是A的子类，那么O也一定从A继承了属性。为此，首先要确保B的原型对象继承自A的原型对象。通过inherit()函数（例6-1），可以这样来实现：
```javascript
B.prototype = inherit(A.prototype); //子类派生自父类
B.prototype.constructor = B; //重载继承来的constructor属性
```
这两行代码是在javascript中创建子类的关键。如果不这样做，原型对象仅仅是一个普通对象，它只继承自Object.prototype，这意味着你的类和所有的类一样是Object的子类。如果将这两行代码添加至defineClass()函数中（参照9.3节），可以将它变成例9-11中的defineSubclass()函数和Function.prototype.extend()方法：
例9-11 定义子类
```javascript
// A simple function for creating simple subclasses
// 用一个简单的函数创建简单的子类
function defineSubclass(superclass,  // Constructor of the superclass，父类的构造函数
                        constructor, // The constructor for the new subclass，新的子类的构造函数
                        methods,     // Instance methods: copied to prototype，实例方法：复制至原型中
                        statics)     // Class properties: copied to constructor，类属性：复制至构造函数中
{
    // Set up the prototype object of the subclass
    // 建立子类的原型对象
    constructor.prototype = inherit(superclass.prototype);
    constructor.prototype.constructor = constructor;
    // Copy the methods and statics as we would for a regular class
    //像对常规类一样复制方法和类属性
    if (methods) extend(constructor.prototype, methods);
    if (statics) extend(constructor, statics);
    // Return the class，返回这个类
    return constructor;
}

// We can also do this as a method of the superclass constructor
// 也可以通过父类构造函数的方法来做到这一点
Function.prototype.extend = function(constructor, methods, statics) {
    return defineSubclass(this, constructor, methods, statics);
};
```

例9-12展示了不使用defineSubclass()函数如何“手动”实现子类。这里定义了Set的子类SingletonSet。SingletonSet是一个特殊的集合，它是可读的，而且含有单独的常量成员。
例9-12：SingletonSet一个简单的子类
```javascript
// The constructor function ，构造函数
function SingletonSet(member) {
    this.member = member;   // Remember the single member of the set，记住集合中这个唯一的成员
}

// Create a prototype object that inherits from the prototype of Set.
// 创建一个原型对象，这个原型对象继承自Set的原型
SingletonSet.prototype = inherit(Set.prototype);

// Now add properties to the prototype，给原型添加属性
// These properties override the properties of the same name from Set.prototype.
// 如果有同名的属性就覆盖Set.prototype中的同名属性
extend(SingletonSet.prototype, {
           // Set the constructor property appropriately
           // 设置合适的constructor属性
           constructor: SingletonSet,
           // This set is read-only: add() and remove() throw errors
           // 这个集合是可读的：调用add()和remove()都会报错
           add: function() { throw "read-only set"; },    
           remove: function() { throw "read-only set"; }, 
           // A SingletonSet always has size 1
           // SingletonSet的实例中永远只有一个元素
           size: function() { return 1; },                
           // Just invoke the function once, passing the single member.
           // 这个方法只调用一次，传入这个集合的唯一成员
           foreach: function(f, context) { f.call(context, this.member); },
           // The contains() method is simple: true only for one value
           // contains()方法非常简单：只须检查传入的值是否匹配这个集合唯一的成员即可
           contains: function(x) { return x === this.member; }
       });
```
这里的SingleSet类是一个比较简单的实现，它包含5个简单的方法定义。它实现了5个核心的set方法，但从它的父类中继承了toString()、toArray()和equals()方法。定义子类就是为了继承这些方法。比如，Set类的equals()方法（在9.4节中定义）用来对Set实例进行比较，只要Set的实例包含size()和foreach()方法，就可以通过equals()比较。因为SingletonSet是Set的子类，所以它自动继承了equals()的实现，不用再实现一次。当然，如果想要最简单的实现方式，那么给SingletonSet类定义它自己的equals()版本就会更高效一些：
```javascript
SingletonSet.prototype.euqals = function(that) {
    return that instanceof Set && that.size() == 1 && that.contains(this.member);
}
```
需要注意的是，SingletonSet不是将Set中的方法列表静态地借用过来，而是动态从Set类继承方法。如果给Set.prototype添加新的方法，Set和SingletonSet的所有实例就会立即拥有这个方法（假定SingletonSet没有定义与同名的方法）。

**9.7.2 构造函数和方法链**

最后一节的SingletonSet类定义了全新的集合实现，而且将它继承自其父类的核心方法全部替换。然而定义子类时，我们往往希望对父类的行为进行修改或扩充，而不是完全替换掉它们。为了做到这一点，构造函数和子类的方法需要调用或链接到父类构造函数和父类方法。

例9-13对此做了展示。它定义了Set的子类NonNullSet，它不允许null和undefined作为它的成员。为了使用这种方式对成员做限制，NonNullSet需要在其add()方法中对null和undefined值做检测。但它需要完全重新实现一个add()方法，因此它调用了父类中的这个方法。注意，NonNullSet()构造函数同样不需要重新实现，它只须将它的参数传入父类构造函数（作为函数来调用它，而不是通过构造函数来调用），通过父类的构造函数来初始化新创建的对象。
例9-13 在子类中调用父类的构造函数和方法
```javascript
/*
 * NonNullSet is a subclass of Set that does not allow null and undefined
 * as members of the set.
 * NonNullSet 是set的子类，它的成员不能是null和undefined
 */
function NonNullSet() {
    // Just chain to our superclass，仅链接到父类
    // Invoke the superclass constructor as an ordinary function to initialize
    // the object that has been created by this constructor invocation.
    //作为普通函数调用父类的构造函数来初始化通过该构造函数调用创建的对象
    Set.apply(this, arguments);
}

// Make NonNullSet a subclass of Set:
//将NonNullSet设置为Set的子类
NonNullSet.prototype = inherit(Set.prototype);
NonNullSet.prototype.constructor = NonNullSet;

// To exclude null and undefined, we only have to override the add() method
// 为了将null和undefined排除在外，只须重写add()方法
NonNullSet.prototype.add = function() {
    // Check for null or undefined arguments
    // 检查参数是不是null或undefined
    for(var i = 0; i < arguments.length; i++)
        if (arguments[i] == null)
            throw new Error("Can't add null or undefined to a NonNullSet");

    // Chain to the superclass to perform the actual insertion
    // 调用父类的add()方法以执行实际插入操作
    return Set.prototype.add.apply(this, arguments);
};
```
让我们将这个非null集合的概念推而广之，称为“过滤后的集合”，这个集合中的成员必须首先传入一个过滤函数再执行添加操作。为此，定义一个类工厂函数（类似例9-7中的enumeration()函数），传入一个过滤函数，返回一个新的Set子类。实际上，可以对此做进一步的通用化的处理，定义一个可以接收两个参数的类工厂：子类和用于add()方法的过滤函数。这个工厂方法称为filteredsetSubclass()，并通过这样的代码来使用它：
```javascript
//定义一个只能保存字符串的“集合”类
var StringSet = filteredSetSubclass(set, function(x) {return typeof x === "string";});
//这个集合类的成员不能是null、undefined或函数
var MySet = filteredSetSubclass(NonNullSet, function(x) {return typeof x !== "function";});
```
例9-14是这个类工厂函数的实现代码。注意 ，这个例子中的方法链和构造函数链和NonNullset中的实现是一样的。

例9-14 类工厂和方法链
```javascript
/*
 * This function returns a subclass of specified Set class and overrides 
 * the add() method of that class to apply the specified filter.
 * 这个函数返回具体Set类的子类
 * 并重写该类的add()方法用以对添加的元素做特殊的过滤
 */
function filteredSetSubclass(superclass, filter) {
    var constructor = function() {          // The subclass constructor，子类构造函数
        superclass.apply(this, arguments);  // Chains to the superclass，调用父类构造函数
    };
    var proto = constructor.prototype = inherit(superclass.prototype);
    proto.constructor = constructor;
    proto.add = function() {
        // Apply the filter to all arguments before adding any
        // 在添加任何成员之前首先使用过滤器将所有参数进行过滤
        for(var i = 0; i < arguments.length; i++) {
            var v = arguments[i];
            if (!filter(v)) throw("value " + v + " rejected by filter");
        }
        // Chain to our superclass add implementation
        // 调用父类的add()方法
        superclass.prototype.add.apply(this, arguments);
    };
    return constructor;
}
```
例9-14中一个比较有趣的事情是，用一个函数将创建子类的代码包装起来，这样就可以在构造函数和方法链中使用父类的参数，而不是通过写死某个父类的名字来使用它的参数。也就是说如果想修改父类，只须修改一处代码即可，而不必对每个用到父类类名的地方都做修改。已经有充足的理由证明这种技术的可行性，即使不是定义类工厂的场景中，这种技术也是值得提倡使用的。比如，可以这样使用包装函数和例9-11的Function.prototype.extend()方法来重写NonNullSet：
```javascript
var NonNullSet = (function(){ //定义并立即调用这个函数
    var superclass = Set;       //仅指定父类
    return superclass.extend(
        function() {superclass.apply(this, arguments);},  //构造函数
        {
            add: function() {
                //检查参数是否是null或undefined
                for (var i = 0; i < arguments.length; i++)
                    if (arguments[i] == null)
                        throw new Error("can't add null or undefined");
                //调用父类的add()方法以执行实际插入操作
                return superclass.prototype.add.apply(this, arguments);
            }
        });
}());
```
最后，值得强调的是，类似这种创建类工厂的能力是javascript语言动态特性的一个体现，类工厂是一种非常强大和有用的特性，这在java和c++语言中是没有的。

**9.7.3 组合vs子类**

在前一节中，定义的集合可以根据特定的标准对集合成员做限制，而且使用了子类的技术来实现这种功能，所创建的自定义子类使用了特定的过滤函数来对集合中的成员做限制。父类和过滤函数的每个组合都需要创建一个新的类。

然而还有另一种更好的方法来完成这种需求，即面向对象编程中一条广为人知的设计原则：“组合优于继承”。这样，可以利用组合的原理定义一个新的集合实现，它“包装”了另外一个集合对象，在将受限制的成员过滤掉之后会用到这个（包装的）集合对象。例9-15展示了其工作原理：
例9-15：使用组合代替继承的集合的实现
```javascript
/*
 * A FilteredSet wraps a specified set object and applies a specified filter
 * to values passed to its add() method.  All of the other core set methods 
 * simply forward to the wrapped set instance.
 * 实现一个FilteredSet，它包装某个指定的“集合”对象，并对传入add()方法的值应用了某种指定的过滤器
 * “范围”类中其他所有的核心方法延续到包装后的实例中
 */
var FilteredSet = Set.extend(
    function FilteredSet(set, filter) {  // The constructor
        this.set = set;
        this.filter = filter;
    }, 
    {  // The instance methods，实例方法
        add: function() {
            // If we have a filter, apply it，如果已有过滤器，直接使用它
            if (this.filter) {
                for(var i = 0; i < arguments.length; i++) {
                    var v = arguments[i];
                    if (!this.filter(v))
                        throw new Error("FilteredSet: value " + v +
                                        " rejected by filter");
                }
            }

            // Now forward the add() method to this.set.add()，调用set中的add()方法
            this.set.add.apply(this.set, arguments);
            return this;
        },
        // The rest of the methods just forward to this.set and do nothing else.，剩下的方法都保持不变
        remove: function() {
            this.set.remove.apply(this.set, arguments);
            return this;
        },
        contains: function(v) { return this.set.contains(v); },
        size: function() { return this.set.size(); },
        foreach: function(f,c) { this.set.foreach(f,c); }
    });
```
在这个例子中使用组合的一个好处是，只须创建一个单独的FilteredSet子类即可。可以利用这个类的实例来创建任意带有成员限制的集合实例。比如，不用上文中定义的NonNullSet类，可以这样做：

    var s = new FilteredSet(new Set(), function(x) { return x !== null; });
    
甚至还可以对已经过滤后的集合进行过滤：

    var t = new FilteredSet(s, { function(x) {return !(x instanceof Set); }});


**9.7.4 类的层次结构和抽象类**

在上一节中给出了“组合优于继承”的原则，但为了将这条原则阐述清楚，创建了Set的子类。这样做的原因是最终得到的类是Set的实例，它会从Set继承有用的辅助方法，比如toString()和equals()。尽管这是一个很实际的原因，但不用创建类似Set类这种具体类的子类也可以很好的用组合来实现“范围”。例9-12中的SingletonSet类可以有另外一种类似的实现，这个类还是继承自Set，因此它可以继承很多辅助方法，但它的实现和其父类的实现完全不一样。SingletonSet并不是Set类的专用版本，而是完全不同的另一种Set。在类层次结构中的SingletonSet和Set应当是兄弟的关系，而非父子关系。

不管是在经典的面向对象编程语言中还是在javascript中，通行的解决方法是“从实现中抽离出接口”。假定定义了一个AbstractSet类，其中定义了一些辅助方法比如toString(),但并没有实现诸如foreach()的核心方法。这样，实现的Set、SingletonSet和FilteredSet都是这个抽象类的子类，FilteredSet和SingletonSet都不必再实现为某个不相关的类的子类了。

例9-16在这个思路上更近一步，定义了一个层次结构的抽象的集合类。AbstractSet只定义了一个抽象方法：contains()。任何类只要“声称”自己是一个表示范围的类，就必须至少定义这个contains()方法。然后，定义AbstractSet的子类AbstractEnumerableSet。这个类增加了抽象的size()和foreach()方法，而且定义了一些有用的非抽象方法（toString()、toArray()、equals()等），AbstractEnumerableSet并没有定义add()和remove()方法，它只代表只读集合。SingletonSet可以实现为非抽象子类。最后，定义了AbstractEnumerableSet的子类AbstractWritableSet。这个final抽象集合定义了抽象方法add()和remove()，并实现了诸如union()和intersection()等非具体方法，这两个方法调用了add()和remove()。AbstractWritableSet是Set和FilteredSet类相应的父类。但这个例子中并没有实现它，而是实现了一个新的名叫ArraySet的非抽象类。
例9-16中的代码很长，但还是应当完整地阅读一遍。注意这里用到了Function.prototype.extend()作为创建子类的快捷方式。
例9-16：抽象类和非抽象Set类的层次结构
```javascript
// A convenient function that can be used for any abstract method
// 这个函数可以用做任何抽象方法，非常方便
function abstractmethod() { throw new Error("abstract method"); }

/*
 * The AbstractSet class defines a single abstract method, contains().
 * AbstractSet类定义了一个抽象方法：contains()
 */
function AbstractSet() { throw new Error("Can't instantiate abstract classes");}
AbstractSet.prototype.contains = abstractmethod;

/*
 * NotSet is a concrete subclass of AbstractSet.
 * The members of this set are all values that are not members of some
 * other set. Because it is defined in terms of another set it is not
 * writable, and because it has infinite members, it is not enumerable.
 * All we can do with it is test for membership.
 * Note that we're using the Function.prototype.extend() method we defined
 * earlier to define this subclass.
 * NotSet是AbstractSet的一个非抽象子类
 * 所有不在其他集合中的成员都在这个集合中
 * 因为它是在其他集合是不可写的条件下定义的
 * 同时由于它的的成员是无限个，因此它是不可枚举的
 * 我们只能用它来检测元素成员的归属情况
 * 注意，我们使用了Function.prototype.extend()方法来定义这个子类
 */
var NotSet = AbstractSet.extend(
    function NotSet(set) { this.set = set; },
    {
        contains: function(x) { return !this.set.contains(x); },
        toString: function(x) { return "~" + this.set.toString(); },
        equals: function(that) {
            return that instanceof NotSet && this.set.equals(that.set);
        }
    }
);


/*
 * AbstractEnumerableSet is an abstract subclass of AbstractSet.
 * It defines the abstract methods size() and foreach(), and then implements
 * concrete isEmpty(), toArray(), to[Locale]String(), and equals() methods
 * on top of those. Subclasses that implement contains(), size(), and foreach() 
 * get these five concrete methods for free.
 * AbstractEnumerableSet是AbstractSet的一个抽象子类
 * 它定义了抽象方法size()和foreach()
 * 然后实现了非抽象方法isEmpty()、toArray()、to[Locale]String()和equals()方法
 * 子类实现了contains()、size()和foreach()，这三个方法可以很轻易地调用这5个非抽象方法
 */
var AbstractEnumerableSet = AbstractSet.extend(
    function() { throw new Error("Can't instantiate abstract classes"); }, 
    {
        size: abstractmethod,
        foreach: abstractmethod,
        isEmpty: function() { return this.size() == 0; },
        toString: function() {
            var s = "{", i = 0;
            this.foreach(function(v) {
                             if (i++ > 0) s += ", ";
                             s += v;
                         });
            return s + "}";
        },
        toLocaleString : function() {
            var s = "{", i = 0;
            this.foreach(function(v) {
                             if (i++ > 0) s += ", ";
                             if (v == null) s += v; // null & undefined
                             else s += v.toLocaleString(); // all others，其他的情况
                         });
            return s + "}";
        },
        toArray: function() {
            var a = [];
            this.foreach(function(v) { a.push(v); });
            return a;
        },
        equals: function(that) {
            if (!(that instanceof AbstractEnumerableSet)) return false;
            // If they don't have the same size, they're not equal
            // 如果他们的大小不同，则它们不相等
            if (this.size() != that.size()) return false;
            // Now check whether every element in this is also in that.
            // 检查每一个元素是否也在that中
            try {
                this.foreach(function(v) {if (!that.contains(v)) throw false;});
                return true;  // All elements matched: sets are equal，所有的元素都匹配：集合相等
            } catch (x) {
                if (x === false) return false; // Sets are not equal，集合不相等
                throw x; // Some other exception occurred: rethrow it，发生了其他的异常：重新抛出异常
            }
        }
    });

/*
 * SingletonSet is a concrete subclass of AbstractEnumerableSet.
 * A singleton set is a read-only set with a single member.
 * SingletonSet是AbstractEnumerableSet的非抽象子类
 * singleton集合是只读的，它只包含一个成员
 */
var SingletonSet = AbstractEnumerableSet.extend(
    function SingletonSet(member) { this.member = member; },
    {
        contains: function(x) {  return x === this.member; },
        size: function() { return 1; },
        foreach: function(f,ctx) { f.call(ctx, this.member); }
    }
);


/*
 * AbstractWritableSet is an abstract subclass of AbstractEnumerableSet.
 * It defines the abstract methods add() and remove(), and then implements
 * concrete union(), intersection(), and difference() methods on top of them.
 * AbstractWritableSet是AbstractEnumerableSet的抽象子类
 * 它定义了抽象方法add()和remove()
 * 然后实现了非抽象方法union()、intersection()和difference()
 */
var AbstractWritableSet = AbstractEnumerableSet.extend(
    function() { throw new Error("Can't instantiate abstract classes"); }, 
    {
        add: abstractmethod,
        remove: abstractmethod,
        union: function(that) {
            var self = this;
            that.foreach(function(v) { self.add(v); });
            return this;
        },
        intersection: function(that) {
            var self = this;
            this.foreach(function(v) { if (!that.contains(v)) self.remove(v);});
            return this;
        },
        difference: function(that) {
            var self = this;
            that.foreach(function(v) { self.remove(v); });
            return this;
        }
    });

/*
 * An ArraySet is a concrete subclass of AbstractWritableSet.
 * It represents the set elements as an array of values, and uses a linear
 * search of the array for its contains() method. Because the contains()
 * method is O(n) rather than O(1), it should only be used for relatively
 * small sets. Note that this implementation relies on the ES5 Array methods
 * indexOf() and forEach().
 * ArraySet是AbstractWritableSet的非抽象子类
 * 它以数组的形式表示集合中的元素
 * 对于它的contains()方法使用了数组的线性查找
 * 因为contains()方法的算法复杂度是O(n)而不是O(1)
 * 它非常适用于相对小型的集合，注意，这里的实现用到了ES5的数组方法indexOf()和forEach()
 */
var ArraySet = AbstractWritableSet.extend(
    function ArraySet() {
        this.values = [];
        this.add.apply(this, arguments);
    },
    {
        contains: function(v) { return this.values.indexOf(v) != -1; },
        size: function() { return this.values.length; },
        foreach: function(f,c) { this.values.forEach(f, c); },
        add: function() { 
            for(var i = 0; i < arguments.length; i++) {
                var arg = arguments[i];
                if (!this.contains(arg)) this.values.push(arg);
            }
            return this;
        },
        remove: function() {
            for(var i = 0; i < arguments.length; i++) {
                var p = this.values.indexOf(arguments[i]);
                if (p == -1) continue;
                this.values.splice(p, 1);
            }
            return this;
        }
    }
);
```


**9.8ECMAScript5中的类**

ECMAScript5给属性特性增加了方法支持（getter、setter、可枚举性、可写性和可配置性），而且增加了对象可扩展性的限制。这些方法在6.6节、6.7节和6.8.3节都有详细的讨论，然而这些方法非常适合用于类的定义。下面几节讲述了如何使用ECMAScript5的特性来使类更加健壮。

**9.8.1让属性不可枚举**

例9-6中的Set类使用了一个小技巧，将对象存储为“集合”的成员：它给添加至这个“集合”的任何对象定义了“对象id”属性。之后如果在for/in循环中对这个对象做遍历，这个新添加的属性也会遍历到。ECMAScript5可以通过设置属性为“不可枚举”（nonenumerable）来让属性不会遍历到。例9-17展示了如何通过Object.defineProperty()来做这一点，同时也展示了如何定义一个getter函数以及检测对象是否可扩展的（extensible）。

例9-17：定义不可枚举的属性
```javascript
// Wrap our code in a function so we can define variables in the function scope
// 将代码包装在一个匿名函数中，这样定义的变量就在这个函数作用域内
(function() { 
     // Define objectId as a nonenumerable property inherited by all objects.
     // 定义一个不可枚举的属性objectId，它可以被所有对象继承
     // When this property is read, the getter function is invoked.
     // 当读取这个属性时调用getter函数
     // It has no setter, so it is read-only.
     // 它没有定义setter，因此它是只读的
     // It is nonconfigurable, so it can't be deleted.
     // 它是不可配置的，因此它是不能删除的
     Object.defineProperty(Object.prototype, "objectId", {
                               get: idGetter,       // Method to get value，取值器
                               enumerable: false,   // Nonenumerable，不可枚举
                               configurable: false  // Can't delete it，不可删除的
                           });

     // This is the getter function called when objectId is read
     // 当读取objectId的时候直接调用这个getter函数
     function idGetter() {             // A getter function to return the id，getter函数返回该id
         if (!(idprop in this)) {      // If object doesn't already have an id，如果对象中不存在id
             if (!Object.isExtensible(this)) // And if we can add a property，并且可以增加属性
                 throw Error("Can't define id for nonextensible objects");
             Object.defineProperty(this, idprop, {         // Give it one now.，给它一个值
                                       value: nextid++,    // This is the value，就是这个值
                                       writable: false,    // Read-only，只读的
                                       enumerable: false,  // Nonenumerable，不可枚举的
                                       configurable: false // Nondeletable，不可删除的
                                   });
         }
         return this[idprop];          // Now return the existing or new value，返回已有的或新的值
     };

     // These variables are used by idGetter() and are private to this function
     // idGetter()用到了这些变量，这些都属于私有变量的
     var idprop = "|**objectId**|";    // Assume this property isn't in use，假设这个属性没有用到
     var nextid = 1;                   // Start assigning ids at this #，给它设置初始值

}()); // Invoke the wrapper function to run the code right away，立即执行这个包装函数
```

**9.8.2定义不可变的类**

除了可以设置属性为不可枚举的，ECMAScript5还可以设置属性为只读的，当我们希望类的实例都是不可变的，这个特性非常有帮助。例9-18使用Object.defineProperties()和Object.create()定义不可变的Range类。它同样使用Object.defineProperties()来为类创建原型对象，并将（原型对象的）实例方法设置为不可枚举的，就像内置类的方法一样。不仅如此，它还将这些实例方法设置为“只读”和“不可删除”，这样就可以防止类做任何修改（monkey-patching）。最后，例9-18展示了一个有趣的技巧，其中实现的构造函数也可以用做工厂函数，这样不论调用函数之前是否带有new关键字，都可以正确地创建实例。
例9-18 创建一个不可变得类，它的属性和方法都是只读的
```javascript
// This function works with or without 'new': a constructor and factory function
// 这个方法可以使用new调用，也可以省略new，它可以用做构造函数也可以用做工厂函数
function Range(from,to) {
    // These are descriptors for the read-only from and to properties.
    // 这些是对from和to只读属性的描述符
    var props = {
        from: {value:from, enumerable:true, writable:false, configurable:false},
        to: {value:to, enumerable:true, writable:false, configurable:false}
    };
    
    if (this instanceof Range)                // If invoked as a constructor，如果作为构造函数来调用
        Object.defineProperties(this, props); // Define the properties，定义属性
    else                                      // Otherwise, as a factory ，否则，作为工厂方法来调用
        return Object.create(Range.prototype, // Create and return a new，创建并返回这个新的Range对象，
                             props);          // Range object with props，属性由props指定
}

// If we add properties to the Range.prototype object in the same way,
// 如果用同样的方法给Rang.prototype对象添加属性
// then we can set attributes on those properties.  Since we don't specify
// 那么我们需要给这些属性设置它们的特性
// enumerable, writable, or configurable, they all default to false.
// 因为我们无法识别它们的可枚举性、可写性或可配置性，这些属性特性默认都是false
Object.defineProperties(Range.prototype, {
    includes: {
        value: function(x) { return this.from <= x && x <= this.to; }
    },
    foreach: {
        value: function(f) {
            for(var x = Math.ceil(this.from); x <= this.to; x++) f(x);
        }
    },
    toString: {
        value: function() { return "(" + this.from + "..." + this.to + ")"; }
    }
});
```
例9-18用到了Object.defineProperties()和Object.create()来定义不可变的和不可枚举的属性。这两个方法非常强大，但属性描述符对象让代码的可读性变得更差。另一种改进的做法是将修改这个已定义属性的特性的操作定义为一个工具函数，例9-19展示了两个这样的工具函数：
例9-19 属性描述符工具函数
```javascript
// Make the named (or all) properties of o nonwritable and nonconfigurable.
// 将o的指定名字（或所有）的属性设置为不可写的和不可配置的
function freezeProps(o) {
    var props = (arguments.length == 1)              // If 1 arg，如果只有一个参数
        ? Object.getOwnPropertyNames(o)              //  use all props，使用所有的属性
        : Array.prototype.splice.call(arguments, 1); //  else named props，否则传入了指定名字的属性
    props.forEach(function(n) { // Make each one read-only and permanent，将它们都设置为只读的和不可变的
        // Ignore nonconfigurable properties，忽略不可配置的属性
        if (!Object.getOwnPropertyDescriptor(o,n).configurable) return;
        Object.defineProperty(o, n, { writable: false, configurable: false });
    });
    return o;  // So we can keep using it，所以我们可以继续使用它   
}

// Make the named (or all) properties of o nonenumerable, if configurable.
// 将o的指定名字（或所有）属性设置为不可枚举的和可配置的
function hideProps(o) {
    var props = (arguments.length == 1)              // If 1 arg，如果只有一个参数
        ? Object.getOwnPropertyNames(o)              //  use all props，使用所有的属性
        : Array.prototype.splice.call(arguments, 1); //  else named props，否则传入了指定名字的属性
    props.forEach(function(n) { // Hide each one from the for/in loop，将它们设置为不可枚举的
        // Ignore nonconfigurable properties，忽略不可配置的属性
        if (!Object.getOwnPropertyDescriptor(o,n).configurable) return;
        Object.defineProperty(o, n, { enumerable: false });
    });
    return o;
}
```
Object.defineProperty()和Object.defineProperties()可以用来创建新属性，也可以修改已有属性的特性。当用它们创建新属性时，默认的属性特性的值都是false。但当用它们修改已经存在的属性时，默认的属性特性依然保持不变。比如，在上面的hideProps()函数中，只指定了enumerable特性，因为我们只想修改enumerable特性。

使用这些工具函数，就可以充分利用ECMAScriptd5的特性来实现一个不可变的类，而且不用动态地修改这个类。例9-20中不可变的Range类就用到了刚才定义的工具函数。
例9-20 一个简单的不可变类
```javascript
function Range(from, to) {    // Constructor for an immutable Range class，不可变的类Range的构造函数
    this.from = from;
    this.to = to;
    freezeProps(this);        // Make the properties immutable，将属性设置为不可变的
}

Range.prototype = hideProps({ // Define prototype with nonenumerable properties，使用不可枚举的属性来定义原型
    constructor: Range,
    includes: function(x) { return this.from <= x && x <= this.to; },
    foreach: function(f) {for(var x=Math.ceil(this.from);x<=this.to;x++) f(x);},
    toString: function() { return "(" + this.from + "..." + this.to + ")"; }
});
```

**9.8.3封装对象状态**

如9.6.6节和例9-10所示，构造函数中的变量和参数可以用做它创建的对象的私有状态。该方法在ECMAScript3的一个缺点是，访问这些私有状态的存取器方法是可以替换的。在ECMAScript5中可以通过定义属性getter和setter方法将状态变量更健壮地封装起来，这两个方法是无法删除的，如例9-21所示。
例9-21 将Range类的端点严格封装起来
```javascript
// This version of the Range class is mutable but encapsulates its endpoint
// 这个版本的Range类是可变的，但将端点变量进行了良好的封装
// variables to maintain the invariant that from <= to.
// 当端点的大小顺序还是固定的：from <= to
function Range(from, to) {
    // Verify that the invariant holds when we're created，如果from大于to
    if (from > to) throw new Error("Range: from must be <= to");

    // Define the accessor methods that maintain the invariant，定义存取器方法以维持不变
    function getFrom() {  return from; }
    function getTo() {  return to; }
    function setFrom(f) {  // Don't allow from to be set > to，设置from的值时，不允许from大于to
        if (f <= to) from = f;
        else throw new Error("Range: from must be <= to");
    }
    function setTo(t) {    // Don't allow to to be set < from，设置to的值时，不允许to小于from
        if (t >= from) to = t;
        else throw new Error("Range: to must be >= from");
    }

    // Create enumerable, nonconfigurable properties that use the accessors
    // 将使用取值器的属性设置为可枚举的、不可配置的
    Object.defineProperties(this, {
        from: {get: getFrom, set: setFrom, enumerable:true, configurable:false},
        to: { get: getTo, set: setTo, enumerable:true, configurable:false }
    });
}

// The prototype object is unchanged from previous examples.
// 和前面的例子相比，原型对象没有做任何修改
// The instance methods read from and to as if they were ordinary properties.
// 实例方法可以像读取普遍的属性一样读取from和to
Range.prototype = hideProps({
    constructor: Range,
    includes: function(x) { return this.from <= x && x <= this.to; },
    foreach: function(f) {for(var x=Math.ceil(this.from);x<=this.to;x++) f(x);},
    toString: function() { return "(" + this.from + "..." + this.to + ")"; }
});
```

**9.8.4防止类的扩展**

通常认为，通过给原型对象添加方法可以动态地对类进行扩展，这是javascript本身的特性。ECMAScript5可以根据需要对此特性加以限制。Object.preventExtensions()可以将对象设置为不可扩展的（见6.8.3节），也就是说不能给对象添加任何新属性。Object.seal()则更加强大，它除了能阻止用户给对象添加新属性，还能将当前已有的属性设置为不可配置的，这样就不能删除这些属性了（但不可配置的属性可以是可写的，也可以转换为只读属性）。可以通过这样一句简单的代码来阻止对Object.prototype的扩展：

    Object.seal(Object.prototype);
    
javascript的另外一个动态特性是“对象的方法可以随时替换”（或称为“monkey-patch”）：
```javascript
var original_sort_method = Array.prototype.sort;
Array.prototype.sort = function() {
    var start = new Date();
    original_sort_method.apply(this, arguments);
    var end = new Date();
    console.log("Array sort took " + (end - start) + " milliseconds.");
};
```
可以通过将实例方法设置为只读来防止这类修改，一种方法就是使用上面代码所定义的freezeProps()工具函数。另外一种方法是使用Object.freeze()，它的功能和Object.seal()完全一样，它同样会把所有属性都设置为只读的和不可配置的。

理解类的只读属性的特性至关重要。如果对象o继承了只读属性p，那么给o.p的赋值操作将会失败，就不会给o创建新属性。如果你想重写一个继承来的只读属性，就必须使用Object.definePropertiy()、Object.defineProperties()或Object.create()来创建这个新属性。也就是说，如果将类的实例方法设置为只读的，那么重写它的子类的这些方法的难度会更大。

这种锁定原型对象的做法往往没有必要，但的确有一些场景是需要阻止对象的扩展的。回想一下例9-7中的enumeration()，这是一个类工厂函数。这个函数将枚举类型的每个实例都保存在构造函数对象的属性里，以及构造函数的values数组中。这些属性和数组是表示枚举类型实例的正式实例列表，是可以执行“冻结”（freezing）操作的，这样就不能给它添加新的实例，已有实例也无法删除或修改。可以给enumeration()函数添加几行简单的代码：
```javascript
Object.freeze(enumeration.values);
Object.freeze(enumeration);
```
需要注意的是，通过在枚举类型中调用Object.freeze()，例9-17中定义的objectId属性之后也无法使用了。这个问题的解决方法是，在枚举类型被“冻结”之前读取一次它的objectId属性（调用潜在的存取器方法并设置内部属性）。

**9.8.5子类和ECMAScript5**

例9-22使用ECMAScript5的特性实现子类。这里使用例9-16中的AbstractWritableSet类来做进一步的说明，来定义这个类的子类StringSet。下面这个例子的最大特点是使用Object.create()创建原型对象，这个原型对象继承自父类的原型，同时给新创建的对象定义属性。这种实现方法的困难之处在于，正如上文所提到的，它需要使用难看的属性描述符。

这个例子中另外一个有趣之处在于，使用Object.create()chu

**9.8.6属性描述符**

**9.9模块**

**9.9.1用做命名空间的对象**
**9.9.1作为私有命名空间的函数**


正则表达式的模式匹配
--------------------

正则表达式（regular expression）是一个描述字符模式的对象。JavaScript的RegExp类表示正则表达式，String和RegExp都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能。JavaScript的正则表达式语法是Perl5的正则表达式语法的大型子集，所以对于有Perl编程经验的程序员来说，学习JavaScript中的正则表达式是小菜一碟。

有一些Perl正则表达式语法特性并不被ECMAScript支持，这些特性包括：s（单行模式）和x（扩展语法）标记；\a、\e、\l、\u、\L、\U、\E、\Q、\A、\Z、\z和\G转义字符："(?<=" 正向后行断言和"(?<!" 负向后行断言；"(?#"注释和扩展"(?"的语法。

本章首先介绍用以描述“文本模式”的正则表达式语法。随后讲解了使用正则表达式的String和RegExp方法。

**10.1正则表达式的定义**

javascript中的正则表达式用RegExp对象表示，可以使用RegExp()构造函数来创建RegExp对象，不过RegExp对象更多的是通过一种特殊的直接量语法来创建。就像通过引号包裹字符的方式来定义字符串直接量一样，正则表达式直接量定义为包含在一对斜杠（/）（正斜杠）之间的字符，例如：
```javascript
var pattern = /s$/;
```
运行这段代码创建一个新的RegExp对象，并将它赋值给变量pattern。这个特殊的RegExp对象用来匹配所有以字母“s”结尾的字符串。
用构造函数RegExp()也可以定义与之等价的正则表达式，代码如下：
```javascript
var pattern = new RegExp("s$");
```

RegExp直接量和对象的创建：
就像字符串和数字一样，程序中每个取值相同的原始类型直接量均表示相同的值。这是显而易见的。程序运行时每次遇到对象直接量（初始化表达式）诸如{}和[]的时候都会创建新对象。比如，如果在循环体中写var a = []，则每次遍历都会创建一个新的空数组。
正则表达式直接量则与此不同，ECMAScript3规范规定，一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回一个对象。ECMAScript5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象。IE一直都是按照ECMAScript5规范实现的，多数最新版本的浏览器也开始遵循ECMAScript5，尽管目前该标准并未全面广泛推行。

作者在这里揭示了一种非常容易忽略的情况，比如，这段代码在Firefox3.6和Firefox4+中的运行结果不一致：
```javascript
function getRE() {
    var re = /[a-z]/;
    re.foo = "bar";
    return re;
}
var reg = getRE(),
re2 = getRE();
console.log(reg == re2)//在Firefox3.6中返回true，在Firefox4+中返回false
reg.foo = "baz";
console.log(re2.foo);//在Firefox3.6中返回"baz"，在Firefox4+中返回"bar"
```
原因可以在ECMAScript5规范第24页和第247页找到，也就是说在ECMAScript3规范中，用正则表达式创建的RegExp对象会共享同一个实例，而在ECMAScript5中则是两个独立的实例。而最新的Firefox4、chrome和Safari5都遵循ECMAScript5标准，以至于IE6~IE8都没有很好地遵循ECMAScript3标准，不过在这个问题上反而处理对了。很明显ECMAScript5的规范更符合开发者的期望。

正则表达式的模式规则是由一个字符序列组成的。包括所有字母和数字在内，大多数的字符都是按照直接量仅描述待匹配的字符的。如此说来，正则表达式/java/可以匹配任何包含”java“子串的字符串。除此之外，正则表达式中还有其他具有特殊语义的字符，这些字符并不按照字面含义进行匹配。比如，正则表达式/s$/包含两个字符，第一个字符“s”按照字面含义匹配，第二个字符$是一个具有特殊语义的元字符，用以匹配字符串的结束。因此这个正则表达式可以匹配任何以"s"结束的字符串。

接下来的几节会进一步讲解javascript正则表达式中使用的各种字符和元字符。

**10.1.1直接量字符**

正如上文提到的，正则表达式中的所有字母和数字都是按照字面含义进行匹配的。javascript正则表达式语法也支持非字母的字符匹配，这些字符需要通过反斜线（\）作为前缀进行转义。比如，转义字符\n用以匹配换行符。表10-1中列出了这些转义字符。

表10-1：正则表达式中的直接量字符

|字符|匹配|
|----|----|
|字母和数字字符|自身|
|\o|NUL字符（\u0000）|
|\t|水平制表符（\u0009）|
|\n|换行符（\u000A）|
|\v|垂直制表符（\u000B）|
|\f|换页符（\u000C）|
|\r|回车符（\u000D）|
|\xnn|由十六进制数nn指定的拉丁字符，例如，\x0A等价于\n|
|\uxxxx|由十六进制数xxxx指定的Unicode字符，例如，\u0009等价于\t|
|\cX|控制字符^X，例如，\cJ等价于换行符\n|

在正则表达式中，许多标点符号具有特殊含义，它们是：

    ^ $ . * + ? = ! : | \ / () [] {}
    
在接下来的几节里，我们将学习这些符号的含义。某些符号只有在正则表达式的某些上下文中才具有某种特殊含义，在其他上下文中则被当成直接量处理。然而，如果想在正则表达式中使用这些字符的直接量进行匹配，则必须使用前缀\，这是一条通行规则。其他标点符号（比如@和引号）没有特殊含义，在正则表达式中按照字面含义进行匹配。

如果不记得哪些标点符号需要反斜线转义，可以在每个标点符号前都加上反斜线。另外需要注意，许多字母和数字在有反斜线做前缀时也有特殊含义，所以对于想按照直接量进行匹配的字母和数字，尽量不要用反斜线对其转义。当然，要想在正则表达式中按照直接量匹配反斜线本身，则必须使用反斜线将其转义。比如，正则表达式"/\\/"用以匹配任何包含反斜线的字符串。

**10.1.2字符类**

将直接量字符单独放进方括号内就组成了字符类（character class）。
一个字符类可以匹配它所含的任意字符。因此，正则表达式/[abc]/就和“a”、“b”、“c”中的任意一个都匹配。另外，可以通过“^”符号来定义否定字符类，它匹配所有不包含在方括号内的字符。定义否定字符类时，将一个“^”符号作为左方括号内的第一个字符。正则表达式/[^abc]/匹配的是“a”、“b”、“c”之外的所有字符。字符类可以使用连字符来表示字符范围。要匹配拉丁字母表中的小写字母，可以使用/[a-z]/，要匹配拉丁字母表中的任何字母和数字，则使用/[a-zA-Z0-9]/。

由于某些字符类非常常用，因此在javascript的正则表达式语法中，使用了这些特殊字符的转义字符来表示它们。例如，\s匹配的是空格符、制表符和其他Unicode空白符，\S匹配的是非Unicode空白符的字符。表10-2列出了这些字符，并且总结了字符类的语法（注意，有些字符类转义字符只能匹配ASCII字符，还没有扩展到可以处理Unicode字符，但可以通过十六进制表示方法来显式定义Unicode字符集，例如：/[\u0400-\u04FF]/用以匹配所有的Cyrillic字符）。cyrillic字符是一种斯拉夫语字母。

表10-2：正则表达式的字符类

|字符|匹配|
|----|----|
|[...]|方括号内的任意字符|
|[^...]|不在方括号内的任意字符|
|.|除换行符和其他Unicode行终止符之外的任意字符|
|\w|任何ASCII字符组成的单词，等价于[a-zA-Z0-9]|
|\W|任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]|
|\s|任何Unicode空白符|
|\S|任何非Unicode空白符的字符，注意\w和\S不同|
|\d|任何ASCII数字，等价于[0-9]|
|\D|除了ASCII数字之外的任何字符，等价于[^0-9]|
|[\b]|退格直接量（特例）|

注意，在方括号之内也可以写这些特殊转义字符。比如，由于\s匹配所有的空白字符，\d匹配的是所有数字，因此/[\s\d]/就匹配任意空白符或者数字。注意，这里有一个特例。下面我们将会看到转义符\b具有的特殊含义，当用在字符类中时，它表示的是退格符，所以要在正则表达式中按照直接量表示一个退格符，只需要使用具有一个元素的字符类/[\b]/。

**10.1.3重复**

用刚刚学过的正则表达式的语法，可以把两位数描述成/\d\d/，四位数描述成/\d\d\d\d/。到目前为止，还没有一种方法可以用来描述任意多位的数字，或者描述由三个字母和一个数字构成的字符串。这些正则表达式语法中较为复杂模式都提到了正则表达式中某元素的“重复出现次数”。

我们在正则模式之后跟随用以指定字符重复的标记。由于某些重复种类非常常用，因此就有一些专门用于表示这种情况的特殊字符。例如，“+”用以匹配前一个模式的一个或多个副本。表10-3总结了这些表示重复的正则语法。

表10-3：正则表达式的重复字符语法

|字符|含义|
|----|----|
|{n,m}|匹配前一项至少n次，但不能超过m次|
|{n,}|匹配前一项n次或者更多次|
|{n}|匹配前一项n次|
|?|匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0,1}|
|+|匹配前一项1次或多次，等价于{1,}|
|*|匹配前一项0次或者多次，等价于{0,}|

这里有一些例子：
```javascript
/\d{2,4}/  //匹配2-4个数字
/\W{3}\d?/ //精确匹配三个单词和一个可选的数字
/\s+java\s+/ //匹配前后带有一个或多个空格的字符串“java”
/[^(]/ //匹配一个或多个非左括号的字符
```
在使用“*”和“?”时要注意，由于这些字符可能匹配0个字符，因此它们允许什么都不匹配。例如，正则表达式/a*/实际上与“bbbb”匹配，因为这个字符串含有0个a。

非贪婪的重复
表10-3中列出的匹配重复字符是尽可能多地匹配，而且允许后续的正则表达式继续匹配。因此，我们称之为“贪婪的”匹配。我们同样可以使用正则表达式进行非贪婪匹配。我们同样可以使用正则表达式进行非贪婪匹配。只须在待匹配的字符后跟随一个问号即可：“??”、“+?”、“*?”或“{1,5}”。比如，正则表达式/a+/可以匹配一个或多个连续的字母a。当使用“aaa”作为匹配字符串时，正则表达式会匹配它的三个字符。但是/a+?/也可以匹配一个或多个连续字母a，但它是尽可能少地匹配。我们同样将“aaa”作为匹配字符串，但后一个模式只能匹配第一个a。

使用非贪婪的匹配模式所得到的结果可能和期望并不一致。考虑以下正则表达式/a+b/，它可以匹配一个或多个a，以及一个b。当使用“aaab”作为匹配字符串时，它会匹配整个字符串。现在再试一下非贪婪匹配的版本/a+?b/，它匹配尽可能少的a和一个b。当用它来匹配“aaab”时，你期望它能匹配一个a和最后一个b。但实际上，这个模式却匹配了整个字符串。和该模式的贪婪匹配一模一样。这是因为正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。由于该匹配是从字符串的第一个字符开始的，因此在这里不考虑它的子串中更短的匹配。

**10.1.4选择、分组和引用**

正则表达式的语法还包括指定选择项、子表达式分组和引用前一子表达式的特殊字符。字符“|”用于分隔供选择的字符。例如，/ab|cd|ef/可以匹配字符串“ab”，也可以匹配字符串“cd”，还可以匹配字符串“ef”。/\d{3}|[a-z]{4}/匹配的是三位数字或者四个小写字母。

注意，选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。因此，当正则表达式/a|ab/匹配字符串“ab”时，它只能匹配第一个字符。

正则表达式中的圆括号有多种作用。一个作用是把单独的项组合成子表达式，以便可以像处理一个独立的单元那样“|”、“*”、“?”等来对单元内的项进行处理。例如，/java(script)?/可以匹配字符串“java”，其后可以有“script”也可以没有。/(ab|cd)+|ef/可以匹配字符串“ef”，也可以匹配字符串“ab”或“cd”的一次或多次重复。

在正则表达式中，圆括号的另一个作用是在完整的模式中定义子模式。当一个正则表达式成功地和目标字符串相匹配的时，可以从目标串中抽出圆括号中的子模式相匹配的部分（我们将在本章随后的部分中看到如何取得这些匹配的子串）。例如，假定我们正在检索的模式是一个或多个小写字母后面跟随了一位或多位数字，则可以使用模式/[a-z]+\d+/。但假定我们真正关心的是每个匹配尾部的数字，那么如果将模式的数字部分放在括号中（/[a-z]+(\d+)/），就可以从检索到的匹配中抽取数字了，之后我们会有详尽的解释。

带圆括号的表达式的另一个用途是允许在同一正则表达式的后部引用前面的子表达式。这是通过在字符“\”后加一位或多位数字来实现的。这个数字指定了带圆括号的子表达式在正则表达式中的位置。例如，\1引用的是第一个带圆括号的子表达式，\3引用的是第三个带圆括号的子表达式。注意，因为子表达式可以嵌套另一个子表达式，所以它的位置是参与计数的左括号的位置。例如，在下面的正则表达式中，嵌套的子表达式（[Ss]cript）可以用\2来指代：

    /([Jj]ava([Ss]cript)?)\sis\s(fun\w*)/

对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。这样，引用可以用于实施一条约束，即一个字符串各个单独部分包含的是完全相同的字符。例如，下面的正则表达式匹配的就是位于单引号或双引号之内的0个或多个字符。但是，它并不要求左侧和右侧的引号匹配（即，加入的两个引号都是单引号或都是双引号）：

    /['"][^'"]*['"]/
    
如果要匹配左侧和右侧的引号，可以使用如下的引用：

    /(['"])[^'"]*\1/
    
\1匹配的是第一个带圆括号的子表达式所匹配的模式。在这个例子中，存在这样一条约束，那就是左侧的引号必须和右侧的引号相匹配。正则表达式不允许用双引号括起的内容中有单引号，反之亦然。不能在字符类中使用这种引用，所以下面的写法是非法的：

    /(['"])[^\1]*\1/
    
在本章随后的几节中，我们会看到一种对带圆括号的子表达式的引用，这是正则表达式的检索和替换操作的强大特性之一。

同样，在正则表达式中不用创建带数字编码的引用，也可以对子表达式进行分组。它不是以“(”和“)”进行分组，而是以“(?:”和“)”来进行分组，比如，考虑下面这个模式：

    /([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/
    
这里，子表达式(?:[Ss]cript)仅仅用于分组，因此复制符号“?”可以应用到各个分组。这种改进的圆括号并不生成引用，所以在这个正则表达式中，\2引用了与(fun\W*)匹配的文本。

表10-4对正则表达式的选择、分组和引用运算符做了总结。

表10-4：正则表达式的选择、分组和引用字符。

|字符|含义|
|----|----|
| | |选择，匹配的是该符号左边的子表达式或右边的子表达式|
|(...)|组合，将几个项组合为一个单元，这个单元可通过“*”、“+”、“?”和“|”等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后的引用使用|
|(?:...)|只组合，把项组合到一个单元，但不记忆与该组相匹配的字符|
|\n|和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式（也有可能是嵌套的），组索引是从左到右的左括号数，“?:”形式的分组不编码|

**10.1.5指定匹配位置**

正如前面所介绍的，正则表达式中的多个元素才能匹配字符串的一个字符。例如，\s匹配的只是一个空白符。还有一些正则表达式的元素匹配的是字符之间的位置，而不是实际的字符。例如，\b匹配一个单词的边界，即位于\w（ASCII单词）字符和\W（非ASCII单词）之间的边界，或位于一个ASCII单词与字符串的开始或结尾之间的边界。像\b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元素为正则表达式的锚，因为它们将模式定位在搜索字符串的特定位置上。最常用的锚元素是^，它用来匹配字符串的开始，锚元素$用以匹配字符串的结束。

例如，要匹配单词“JavaScript”，可以使用正则表达式/^JavaScript$/。如果想匹配“Java”这个单词本身（不像在“JavaScript”中作为单词的前缀），可以使用正则表达式/\s\Javas/，可以匹配前后都有空格的单词“Java”。但是这样做有两个问题，第一，如果“Java”出现在字符串的开始或结尾，就匹配不成功，除非开始和结尾处各有一个空格。第二个问题是，当找到了与之匹配的字符串时，它返回的匹配字符串的前端和后端都有空格，这并不是我们想要的。因此我们使用单词的边界\b来代替真正的空格符\s进行匹配（或定位）。这样正则表达式就写成了/\bJava\b/。元素 \B将把匹配的锚点定位在不是单词的边界之处。因此，正则表达式/\B[Ss]cript/与“JavaScript”和“postscript”匹配，但不与“script”和“Scripting”匹配。

任意正则表达式都可以作为锚点条件。如果在符号“(?=”和“)”之间加入一个表达式，它就是一个先行断言，用以说明圆括号内的表达式必须正确匹配，但并不是真正意义上的匹配。比如，要匹配一种常用的程序设计语言的名字，但只在其后有冒号时才匹配，可以使用/[Jj]ava([Ss]cript)?(?=\:)/。这个正则表达式可以匹配“JavaScript: The Definitive Guide”中的“JavaScript”，但是不能匹配“Java in a Nutshell”中的“Java”，因为它后面没有冒号。

带有“(?!”的断言是负向先行断言，用以指定接下来的字符都不必匹配。例如，/Java(?!Script)([A-Z]\w*)/可以匹配“Java”后跟随一个大写字母和任意多个ASCII单词，但Java后面不能跟随“Script”。它可以匹配“JavaBeans”，但不能匹配“Javanese”；它可以匹配“JavaScript”，但不能匹配“JavaScripter”。

表10-5总结了正则表达式中的锚。

表10-5：正则表达式中的锚字符

|字符|含义|
|----|----|
| ^ |匹配字符串的开头，在多行检索中，匹配一行的开头|
| $ |匹配字符串的结尾，在多行检索中，匹配一行的结尾|
|\b|匹配一个单词的边界，简言之，就是位于字符\w和\W之间的位置，或位于字符\w和字符串的开头或者结尾之间的位置（但需要注意，[\b]匹配的是退格符）|
|\B|匹配非单词边界的位置|
|(?=p)|零宽正向先行断言，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符|
|(?!p)|零宽负向先行断言，要求接下来的字符不与p匹配|

**10.2用于模式匹配的string方法**
**10.3 regexp对象**


javascript的子集和扩展
----------------------
**11.1javascript的子集**
**11.2常量和局部变量**
**11.3解构赋值**
**11.4迭代**
**11.5函数简写**
**11.6多catch从句**
**11.7e4x:ecmascript for xml

服务器端javascript
--------------------
**12.1用rhino脚本化java**
**12.2用node实现异步i/o**
