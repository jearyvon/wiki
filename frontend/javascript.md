概述
-------
本文修摘自《javascript权威指南》第6版
javascript是一门弱类型、非传统面向对象的编程语言。
javascript和java是完全不同的两种编程语言，之于雷锋与雷峰塔。
ECMAScript是javascript的语言标准版本，现在最新版本为ES6。

以下先对javascript做一个快速概览
```javascript
javascript语言核心快速概览
//这是注释
var x; //声明变量
x=0    //通过等号赋值给变量
//javascript支持多种数据类型
x=1;               //数字
x=0.01;            //整数和实数共用一种数据类型
x="hello world";   //双引号内的文本构成的字符串
x='javascript';    //单引号内的文本构成的字符串
x=true;            //布尔值
x=false;           //布尔值
x=null;            //null是一个特殊的值，意思是”空“
x=undefined        //undefined和null非常类似
//javascript中的最重要的类型就是对象
//对象是名/值对的集合，或字符串到值映射的集合
var book = {            //对象是由花括号括起来的
    topic: "javascript",  //属性topic的值是javascript
    fat: true             //属性fat的值是true
}                       //右花括号标记了对象的结束
//通过“.”和“[]”来访问对象属性
book.topic                 //=> "javascript"
book["fat"]               //=> true 另外一种获取属性的方式
book.author = "Flanagan";  //通过赋值创建一个新属性
book.contents = {};        //{}是一个空对象，它没有属性
//javascript数组（以数字为索引的列表）
var primes = [2, 3, 5, 7]; //拥有4个值的数组，由“[”和“]”划定边界
primes[0]                  //=> 2 数组中的第一个元素（索引为0）
primes.length              //=> 4 数组中元素个数
primes[primes.length -1]   //=> 7 数组的最后一个元素
primes[4] = 9;             //通过赋值来添加新元素
primes[4] = 11;            //或通过赋值来改变已有的元素
var empty = [];            //[]是空数组，它具有0个元素
empty.length               //=>0 空数组的长度为0
//数组和对象都可以包含另一个数组或对象
var points = [             //具有两个元素的数组
    {x: 0, y: 0},          //每个元素都是一个对象
    {x: 1, y: 1}
];
var data = {               //一个包含两个属性的对象
    trial1: [[1,2],[3,4]], //每一个属性都是数组
    trial2: [[2,3],[4,5]]  //数组的元素也是数组
};
//运算符作用于操作数，生成一个新的值
//最常见的是算术运算符
3 + 2                      //=> 5 加法                     
3 - 2                      //=> 1 减法
3 * 2                      //=> 6 乘法
3 / 2                      //=> 1.5 除法
points[1].x - points[0].x  //=> 1 更复杂的操作数也能照常工作
"3" + "2"                  //=> "32" 符号+可以完成加法运算也可以作字符串连接
//javascript定义了一些算术运算符的简写形式
var count = 0;             //定义一个变量
count++;                   //自增1
count--;                   //自减1
count += 2;                //自增2 和“count = count + 2;”写法一样
count *= 3;                //自乘3 和“count = count * 3;”写法一样
count                      //=> 6 变量名本身也是一个表达式
//相等关系运算符用来判断两值是否相等
//不等、大于、小于运算符的运算结果是true或false
var x = 2, y = 3;          //这里的=等号是赋值的意思，不是比较相等
x == y                     //=> false 相等
x != y                     //=> true 不等
x < y                      //=> true 小于
x <= y                     //=> true 小于等于
x > y                      //=> false 大于
x >= y                     //=> false 大于等于
"two" == "three"           //=> false 两个字符串不相等
"two" > "three"            //=> true “tw”在字母表中的索引大于“th”
false == (x > y)           //=> true false和false相等
//逻辑运算符是对布尔值的合并或求反
(x == 2) && (y ==3 )       //=> true 两个比较都是true，&&表示“与”
(x > 3) || (y < 3)         //=> false 两个比较都不是true，||表示“或”
!(x == y)                  //=> true !求反
//函数是带有名称和参数的javascript代码段，可以一次定义多次调用
function plus1(x) {        //定义了名为plus1的一个函数，带有参数x
    return x + 1;          //返回一个比传入的参数大的值
}                          //函数的代码块是由花括号包裹起来的部分
plus1(y)                   //=>4 y为3，调用函数的结果为 3 + 1
var square = function(x) { //函数是一种值，可以赋值给变量
    return x * x;          //计算函数的值
};                         //分号标识了赋值语句的结束
square(plus1(y))           //=> 16 在一个表达式中调用两个函数
//当将函数和对象合写在一起时，函数就变成了“方法”（method）
//当函数赋值给对象的属性，我们称为“方法”，所有的javascript对象都含有方法
var a = [];                           //创建一个空数组
a.push(1, 2, 3);                      //push()方法向数组中添加元素
a.reverse();                          //另一个方法：将数组元素的次序反转
//我们也可以定义自己的方法，“this”关键字是对定义方法的对象的引用，这里的例子是上文中提到的包含两个点位置信息的数组
points.dist = function() {            //定义一个方法用来计算两点之间的距离
    var p1 = this[0];                 //通过this获得对当前数组的引用
    var p2 = this[1];                 //并获得调用的数组前两个元素
    var a = p2.x - p1.x;              //x坐标轴上的距离
    var b = p2.y - p1.y;              //y坐标轴上的距离
    return Math.sqrt(a * a + b * b);  //勾股定理，用Math.sqrt()来计算平方根
}
points.dist();                        //=> 1.414 求得两个点之间的距离
//控制语句
function abs(x) {                     //求绝对值的函数
    if (x > =0) {                     //if语句
        return x;                     //如果比较结果为true则执行这里的代码
    }                                 //子句的结束
    else {                            //当if条件不满足时执行else子句
        return - x;                   //返回负x
    }                                 //如果分支中只有一条语句，花括号是可以省略的
}                                     //注意if/else中嵌套的return语句
function factorial(n) {               //计算阶乘的函数
    var product = 1;                  //给product赋值为1
    while (n > 1) {                   //当()内的表达式为true时循环执行{}内的代码
        product *= n;                 //product = product *n的简写形式
        n--;                          //n = n -1的简写形式
    }                                 //循环结束
    return product;                   //返回product
}
factorial(4)                          //=> 24 1*4*3*2
function factorial2(n) {              //实现循环的另一种写法
    var i, product = 1;               //给product赋值为1
    for (i = 2; i<=n; i++)            //将i从2自增至n
        product *= i;                 //循环体，当循环体中只有一句代码，可以省略{}
    return product;                   //返回计算好的阶乘
}
factorial2(5)                         //=> 120 1*2*3*4*5
//类，在javascript中定义一个类来表示2D平面几何中的点，这个类实例化的对象拥有一个名为r()的方法，用来计算该点到原点的距离
//定义一个构造函数以初始化一个新的point对象
function Point(x,y) {                 //按照惯例，构造函数均以大写字母开始
    this.x = x;                       //关键字this指代初始化的实例
    this.y = y;                       //将函数参数存储为对象的属性
}                                     //不需要return
//使用new关键字和构造函数来创建一个实例
var p =new Point(1, 1);               //平面几何中的点(1,1)
//通过给构造函数的prototype对象赋值
//来给Point对象定义方法
Point.prototype.r = function() {
    return Math.sqrt(                 //返回 x*x + y*y的平方根
    this.x * this.x +                 //this指代调用这个方法的对象
    this.y * this.y);
}
//Point的实例对象p（以及所有的Point实例对象）继承了方法r()
p.r()                                 //=> 1.414...
```

```
客户端javascript快速概览
javascript代码可以通过<script>标签来嵌入到HTML文件中：
<html>
<head>
引入一个javascript库
<script src="library.js"></script>
</head>
<body>
<p>this is a paragraph of HTML</p>
<script>
在这里编写嵌入到HTML文件中的javascript代码
</script>
<p>here is more HTML.</p>
</body>
</html>
```

```javascript
web浏览器端的脚本技术，涵盖客户端javascript中的一些重要全局函数
```



词法结构
----------
编程语言的词法结构是一套基础性规则，用来描述如何使用这门语言来编写程序。
**2.1字符集**
javascript程序是用Unicode字符集编写的。Unicode是ASCII和Latin-1的超集，并支持地球上几乎所有在用的语言。
**2.1.1区分大小写**
javascript是区分大小写的语言。与html中标签和属性同名的javascript必须小写，例如在html中可以写成onClick，但在javascript中必须写成小写onclick。
**2.1.2空格、换行符和格式控制符**
**2.1.3Unicode 转义序列**
**2.1.4标准化**
**2.2注释**
**2.3直接量**
**2.4标识符和保留字**
**2.5可选的分号**
和其他编程语言一样，javascript使用分号（;）将[语句](#语句)分隔开。这对增强代码的可读性和整洁性是非常重要的：缺少分隔符，一条语句的结束就成了下一条语句的开始，反之亦然。在javascript中，如果语句各自独占一行，通常可以省略语句之间的分号（程序结尾或右花括号“}”之前的分号也可以省略）。许多javascript程序员（包括本书中的示例代码）使用分号来明确标记语句的结束，即使在并不完全需要分号的时候也是如此。另一种风格就是，在任何可以省略分号的地方都将其省略，只有在不得不用的时候才使用分号。不管采用哪种编程风格，关于javascript中可选分号的问题有几个细节需要注意。
考虑如下代码，因为两条语句用两行书写，第一个分号是可以省略掉的：
```javascript
a = 3;
b = 4;
```
如果按照如下格式书写，第一个分号则不能省略：
```javascript
a = 3; b = 4;
```
需要注意的是，javascript并不是在所有行处都填补分号：只有在缺少了分号就无法正确解析代码的时候，javascript才会填补分号。换句话讲（类似下面代码中的两处异常），如果当前语句和随后的非空格字符不能当成一个整体来解析的话，javascript就在当前语句行结束处填补分号。看一下如下代码：
```javascript
var a
a
=
3
console.log(a)
```
javascript将其解析为：
```javascript
var a; a = 3; console.log(a);
```
javascript给第一行换行处添加了分号，因为如果没有分号，javascript就无法解析代码 var a a。第二个a可以单独当做一条语句“a;”，但javascript并没有给第二行结尾填补分号，因为它可以和第三行内容一起解析成“a=3;”。
这些语句的分隔规则会导致一些意想不到的情形，这段代码写成了两行，看起来是两条独立的语句：
```javascript
var y = x + f
(a+b).toString()
```
但第二行的圆括号却和第一行的f组成了一个函数调用，javascript会把这段代码看作做：
```javascript
var y = x + f(a+b).toString();
```
而这段代码的本意并不是这样。为了能让上述代码解析为两条不同的语句，必须手动填写行尾的显式分号。

通常来讲，如果一条语句以“(”、“[”、“/”、“+”或“-”开始，那么它极有可能和前一条语句合在一起解析。以“/”、“+”和“-”开始的语句并不常见，而以“(”和“[”开始的语句则非常常见，至少在一些javascript编码风格中是很普遍的。有些程序员喜欢保守地在语句前加一个分号，这样哪怕之前的语句被修改了，分号被误删了，但钱语句还是会正确地被解析：
```javascript
var x = 0 //这里省略了分号
;[x,x+1,x+2].forEach(console.log); //前面的分号保证了正确地语句解析
```
如果当前语句和下一行语句无法合并解析，javascript则在第一行后填补分号，这是通用规则，但有两个例外。第一个例外是在涉及return、break和continue语句的场景中。如果这三个关键字后紧跟着换行，javascript则会在换行处填补分号。例如，这段代码：
```javascript
return
true;
```
javascript会被解析成：
```javascript
return; true;
```
而代码的本意是这样：
```javascript
return true;
```
也就是说，在return、break和continue和随后的表达式之间不能有换行。如果添加了换行，程序则只有在极特殊的情况的下才会报错，而且程序的调试非常不方便。
第二个例外是在涉及“++”和“--”运算符（见4.8节）的时候。这些运算符可以作为表达式的前缀，也可以当做表达式的后缀。如果将其用做后缀表达式，它和表达式应当在同一行。否则，行尾将填补分号，同时“++”或“--”将会作为下一行代码的前缀操作符并与之一起解析，例如，这段代码：
```javascript
x
++
y
```
这段代码将被解析为“x;++y”，而不是“x++;y”。

类型、值和变量
--------------
**3.1数字**



**3.2文本**

**3.3布尔值**

**3.4null和undefined**

**3.5全局对象**

前几节我们讨论了javascript的原始类型和原始值。对象类型——对象、数组和函数——在本书中均会有独立章节来讲述。但有一类非常重要的对象，我们不得不现在就把它们讲清楚——全局对象。
全局对象（global object）在javascript中有着重要的用途：全局对象的属性是全局定义的符号，javascript程序可以直接使用。当javascript解释器启动时（或者任何web浏览器加载新页面的时候），它将创建一个新的全局对象，并给它一组定义的初始属性：

* 全局属性，比如undefined、Infinity和NaN
* 全局函数，比如isNaN()、parseInt()（见3.8.2节）和eval()（见4.12节）
* 构造函数，比如Date()、RegExp()、String()、Object()和Array()（见3.8.2节）
* 全局对象，比如Math和JSON（见6.9节）

全局对象的初始属性并不是保留字，但它们应该当做保留字来对待。2.4.1节列出了所有这些属性。本章对一部分全局属性也有描述。其他属性在其他章节也会讲述。可以在第三部分中通过名称查找到，或者通过别名“Global”来找到这些全局对象。对于客户端javascript来讲，window对象定义了一些额外的全局属性，可以在第四部分中查看它们。

在代码的最顶级——不在任何函数内的javascript代码——可以使用javascript关键字this来引用全局对象：

    var global = this;//定义一个引用全局对象的全局变量

在客户端javascript中，在其表示的浏览器窗口中的所有javascript代码中，window对象充当了全局对象。这个全局window对象有一个属性window引用其自身，它可以代替this来引用全局对象。window对象定义了核心全局属性，但它也针对web浏览器和客户端javascript定义了一少部分其他全局属性。
当初次创建的时候，全局对象定义了javascript中所有的预定义全局值。这个特殊对象同样包含了为程序定义的全局值。如果代码声明了一个全局变量，这个全局变量就是全局对象的一个属性，3.10.2节有关于此的详尽解释。

**3.6包装对象**

javascript对象是一种复合值：它是属性或已命名值的集合。通过“.”符号来引用属性值。当属性值是一个函数的时候，称其为方法。通过o.m()来调用对象o中的方法。

我们看到字符串也同样具有属性和方法：
```javascript
var s = "hello world!";//一个字符串
var word = s.substring(s.indexOf(" ")+1, s.length);//使用字符串的属性
```
字符串既然不是对象，为什么它会有属性呢？只要引用了字符串s的属性。javascript就会将字符串值通过调用new String(s)的方式转换成对象，这个对象继承了字符串的方法（见6.2.2节），并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁（其实在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样）。
同字符串一样，数字和布尔值也具有各自的方法：通过NUmber()和Boolean()构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。null和undefined没有包装对象：访问它们的属性会造成一个类型错误。

看如下代码，思考它们的执行结果：
```javascript
var s = "test";//创建一个字符串
s.len = 4;//给它设置一个属性
var t = s.len;//查询这个属性
```
当运行这段代码时，t的值是undefined。第二行代码创建一个临时字符串对象，并给其len属性赋值4，随即销毁这个对象。第三行通过原始的（没有修改过）字符串值创建一个新字符串对象，尝试读取其len属性，这个属性自然是不存在的，表达式求值结果为undefined。这段代码说明了在读取字符串、数字和布尔值的属性值（或方法）的时候，表现的像对象一样。但如果你试图给其属性赋值，则会忽略这个操作：修改只是发生在临时对象身上，而这个临时对象并未继续保留下来。

存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。通常，包装对象只是被看做是一种实现细节，而不用特别关注。由于字符串、数字和布尔值的属性都是只读的，并且不能给它们定义新属性，因此你需要明白它们是有别于对象。

需要注意的是，可通过String()、Number()或Boolean()构造函数来显式创建包装对象：
```javascript
var s = "test",n = 1,b = true;//一个字符串、数字和布尔值
var S = new String(s);//一个字符串对象
var N = new Number(n);//一个数值对象
var B = new Boolean(b);//一个布尔对象
```
javascript会在必要时将将包装对象转换为原始值，因此上段代码中的对象S、N和B常常但不总是表现的和s、n和b一样。“==”等于运算符将原始值和其包装对象视为相等，但“===”全等运算符将它们视为不等。通过typeof运算符可以看到原始值和其包装对象的不同。

**3.7不可变的原始值和可变的对象引用**

javascript中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本的区别。原始值是不可更改的，任何方法都无法更改（或“突变”）一个原始值。对数字和布尔值来说显然如此——改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来就像是由字符组成的数组，我们期望可以通过指定索引来修改字符串中的字符。实际上，javascript是禁止这样做的。字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值。例如：
```javascript
var s = "hello";//定义一个由小写字母组成的文本
s.toUpperCase();//返回“HELLO”，但并没有改变s的值
s               //=> hello，原始字符串的值并未改变
```
原始值的比较是值的比较：只有在它们的值相等时它们才相等。这对数字、布尔值、null和undefined来说听起来有点难懂，并没有其他办法来比较它们。同样，对于字符串来说则并不明显：如果比较两个单独的字符串，当且仅当它们的长度相等且每个索引的字符都相等时，javascript才认为它们相等。

对象和原始值不同，首先，它们是可变的——它们的值是可修改的：
```javascript
var o = {x:1};//定义一个对象
o.x = 2;//通过修改对象属性值来更改对象
o.y = 3;//再次更改这个对象，给它增加一个新属性
var a = [1,2,3]//数组也是可修改的
a[0] = 0;//更改数组的一个元素
a[3] = 4;//给数组增加一个新元素
```
对象的比较并非值的比较，即使两个对象包含同样的属性及相同的值，它们也是不相等的。各个索引元素完全相等的两个数组也不相等。
```javascript
var o = {x:1},p = {x:1}//具有相同属性的两个对象
o===p//=>false 两个单独的对象永不相等
var a = [],b = [];//两个单独的空数组
a===b//=>false 两个单独的数组永不相等
```
我们通常将对象称为引用类型（reference type），以此来和javascript的基本类型区分开来。依照术语的叫法，对象值都是引用（reference）。对象的比较均是引用的比较，当且仅当它们引用同一个基对象时，它们才相等。
```javascript
var a = [];//定义一个引用空数组的变量s
var b = a;//变量b引用同一个数组
b[0] = 1;//通过变量b来修改引用的数组
a[0]//=>1 变量a也会修改
a===b//=>true a和b引用同一个数组，因此它们相等
```
就像你们看到的如上代码，将对象（或数组）赋值给一个变量，仅仅是赋值的引用值，对象本身并没有复制一次，如果你想得到一个对象或数组的副本，则必须显式复制对象的每个属性或数组的每个元素。下面这个例子则是通过循环来完成数组复制（见5.5.3节）。
```javascript
var a = ['a','b','c'];//待复制的数组
var b = [];//复制到的目标空数组
for(var i=0; i<a.length; i++){//遍历a[]中的每个元素
    b[i] = a[i];//将元素值复制到b中
}
```
同样的，如果我们想比较两个单独的对象或者数组，则必须比较它们的属性或元素。下面这段代码定义了一个比较两个数组的函数；
```javascript
function equalArrays(a,b){
    if(a.length != b.length) return false;//两个长度不同的数组不相等
    for(var i=0; i<a.length; i++){//循环遍历所有元素
        if (a[i] !== b[i]) return false;//如果有任意元素不等，则数组不相等
        return true;//否则它们相等
    }
}
```
**3.8类型转换**

**3.9变量声明**

**3.10变量作用域**

一个变量的作用域（scope）是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在javascript代码中的任何地方都是有定义的。
然而在函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，它们只在函数体内有定义。
在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。

```javascript
var scope = "global";   //声明一个全局变量
function checkscope() {
    var scope = "local";//声明一个同名的局部变量
    return scope;       //返回局部变量的值，而不是全局变量的值
}
checkscope();           //=>"local"
```
尽管在全局作用域编写代码时可以不写var语句，但声明局部变量时则必须使用var语句。思考一下如果不这样做会怎样：

```javascript
scope = "global";           //声明一个全局变量，甚至不用var来声明
function checkscope2() {    
    scope = "local";        //糟糕！我们刚刚修改了全局变量
    myscope = "local";      //这里显式地声明了一个新的全局变量
    return [scope,myscope]; //返回两个值
}
checkscope2();//=>["local","local"]，产生了副作用
scope//=>"local"，全局变量修改了
myscope//=>"local"，全局命名空间搞乱了
```
函数定义是可以嵌套的。由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况，例如：

```javascript
var scope = "global scope";//全局变量
    function checkscope() {
        var scope = "local scope";//局部变量
        function nested() {
            var scope = "nested scope";//nested(嵌套)，嵌套作用域内的局部变量
            return scope;//返回当前作用域内的值
        }
        return nested();
    }
checkscope(); //"nested scope"，嵌套作用域
```

**3.10.1函数作用域和声明前提**

在一些类似c语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而javascript中没有块级作用域。
javascript取而代之地使用了函数作用域（function scope），变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

在如下所示的代码中，在不同位置定义了变量i、j和k，它们都在同一个作用域内——这三个变量在函数体内均是有定义的。

```javascript
function test(o){
    var i = 0;                      //i在整个函数体内均是有定义的
    if(typeof o == "object") {
        var j = 0;                  //j在函数体内是有定义的，不仅仅是在这个代码段内
        for (var k=0; k < 10; k++){ //k在函数体内是有定义的，不仅仅是在循环里
            console.log(k);         //输出数字0～9
        }
        console.log(k);             //k已经定义了，输出10
    }           
    console.log(j);                 //j已经定义了，但可能没有初始化
}
```
javascript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。javascript的这个特性被非正式地称为声明前提（hoisting），即javascript函数里声明的所有变量（但不涉及赋值）都被提前至函数体的顶部，看一下如下代码：

```javascript
var scope = "global";
function f() {
    console.log(scope);//输出"undefined"，而不是"global"
    var scope = "local";//变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的
    console.log(scope);//输出"local"
}
```
你可能会误以为函数中的第一行会输出“global”，因为代码还没有执行到var语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到var语句的时候，局部变量才会被真正赋值。因此，上述过程等价于：将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：

```javascript
function f() {
    var scope;//在函数顶部声明了局部变量
    console.log(scope);//变量存在，但其值是"undefined"
    scope = "local";//这里将其初始化并赋值
    console.log(scope);//这里它具有了我们所期望的值
}
```
在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的编程习惯。由于javascript没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近在使用变量之处。这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。

“声明提前”这步操作是在javascript引擎的“预编译”时进行的，是在代码开始运行之前，更多细节请阅读相关ppt：www.slideshare.net/lijing00333/javascript-engine。

**3.10.2作为属性的变量**

当声明一个javascript全局变量时，实际上是定义了全局对象的一个属性（3.5节）。当使用var声明一个变量时，创建的这个属性是不可配置的（见6.7节），也就是说这个变量无法通过delete运算符删除。可能你已经注意到了，如果你没有使用严格模式并给一个未声明的变量赋值的话，javascript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们。

```javascript
var truevar = 1;//声明一个不可删除的全局变量
fakevar = 2;//创建全局对象的一个可删除的属性
this.fakevar2 = 3;//同上
delete truevar //=>false 变量并没有被删除
delete fakevar //=>true 变量被删除
delete this.fakevar2 //=>true 变量被删除
```

javascript全局变量是全局对象的属性，这是在ECMAScript规范中强制规定的。对于局部变量则没有如此规定，但我们可以想象得到，局部变量当做跟函数调用相关的某个对象的属性。ECMAScript3规范称该对象为“调用对象”（call object），ECMAScript5规范称“声明上下文对象”（declarative environment record）。javascript可以允许使用this关键字来引用全局对象，却没有方法可以引用局部变量中存放的对象。这种存放局部变量的对象的特有性质，是一种对我们不可见的内部实现。然而，这些局部变量对象存在的观念是非常重要的。我们会在下一节展开讲述。

**3.10.3作用域链**
javascript是基于词法作用域的语言：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。全局变量在程序中始终都是有定义的。局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。

如果将一个局部变量看做是自定义实现的对象的属性的话，那么可以换个角度来解读变量作用域。每一段javascript代码（全局代码或函数）都有一个与之关联的作用域链（scope chain）。
这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当javascript需要查找变量x的值的时候（这个过程称做“变量解析”（variable resolution）），它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为x的属性，javascript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError）异常。

在javascript的最顶层代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解对象链的创建规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。

作用域链的概念对于理解with语句（见5.7.1节）是非常有帮助的，同样对理解闭包（见8.6节）的概念也至关重要。


表达式和运算符
--------------
**4.1原始表达式**
**4.2对象和数组的初始化表达式**
**4.3函数定义表达式**
**4.4属性访问表达式**
**4.5调用表达式**
**4.6对象创建表达式**
对象创建表达式（object creation expression）创建一个对象并调用一个函数（这个函数称为构造函数）初始化新对象的属性。对象创建表达式和函数调用表达式非常类似，只是对象创建表达式之前多了一个关键字new：
```javascript
new Object()
new Point(2,3)
```
如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么这对空圆括号是可以省略掉的：
```javascript
new Object
new Date
```
当计算一个对象创建表达式的值时，和对象初始化表达式通过{}创建对象的做法一样，javascript首先创建一个新的空对象，然后，javascript通过传入指定的参数并将这个新对象当做this的值来调用一个指定的函数。这个函数可以使用this来初始化这个新创建对象的属性。那些被当做构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果一个构造函数确实返回了一个对象值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了。

**4.7运算符概述**
**4.8算术表达式**
**4.9关系表达式**
**4.10逻辑表达式**
**4.11赋值表达式**
**4.12表达式计算**
**4.13其他运算符**

语句
----
**5.1表达式语句**
**5.2复合语句和空语句**
**5.3声明语句**
**5.4条件语句**
**5.5循环**
**5.6跳转**
**5.7其他语句类型**
**5.8javascript语句小结**


对象
----

对象是javascript的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值，对象也可看做是属性的无序集合，每个属性都是一个名／值对。属性名是字符串，因此我们可以把对象看成是从字符串到值的映射。这种基本数据结构还有很多种叫法，有些我们已然非常熟悉，比如“散列”（hash）、“散列表”（hashtable）、“字典”（dictionary）、“关联数组”（associative array）。然而对象不仅仅是字符串到值的映射，除了可以保持自有的属性，javascript对象还可以从一个称为原型的对象继承属性。对象的方法通常是继承的属性。这种“原型式继承”（prototypal inheritance）是javascript的核心特征。

javascript对象是动态的——可以新增属性也可以删除属性——但它们常用来模拟静态对象以及静态类型语言中的“结构体”（struct）。有时它们也用做字符串的集合（忽略名值对中的值）。

除了字符串、数字、true、false、null和undefined之外，javascript中的值都是对象。尽管字符串、数字和布尔值不是对象，但它们的行为和不可变对象（参照3.6节）非常类似。

3.7节已经讲到，对象是可变的，我们通过引用而非值来操作对象。如果变量x是指向一个对象的引用，那么执行代码var y = x;变量y也是指向同一个对象的引用，而非这个对象的副本。通过变量y修改这个对象亦会对变量x造成影响。

对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。我们会在开始的几节讲述这些基础操作。后续的几节讲述高级主题，其中相当一部分内容来自于ECMAScript5.

属性包括名字和值。属性名可以是包含字符串在内的任意字符串，但对象中不能存在两个同名的属性。值可以是任意javascript值，或者（ECMAScript5中）可以是一个getter或setter函数（或两者都有）。6.6节会有关于getter和setter函数的讲解。除了名字和值之外，每个属性还有一些与之相关的值，称为“属性特性”：

* 可写（writable attribute），表明是否可以设置该属性的值
* 可枚举（enumerable attribute），表明是否可以通过for／in循环返回该属性
* 可配置（configurable attribute），表明是否可以删除或修改该属性。

在ECMAScript5之前，通过代码给对象创建的所有属性都是可写的、可枚举的和可配置的。在ECMAScript5中则可以对这些特性加以配置。6.7节讲述如何操作。除了包含属性之外，每个对象还拥有三个相关的对象特性（object attribute）：

* 对象的原型（prototype）指向另外一个对象，本对象的属性继承自它的原型对象。
* 对象的类（class）是一个标识对象类型的字符串
* 对象的扩展标记（extensible flag）指明了（在ECMAScript5中）是否可以向该对象添加新属性。

6.1.3节和6.2.2节会有关于原型和属性继承的讲述，6.8节会进一步详细讲述这三个特性。
最后，我们用下面这些术语来对三类javascript对象和两类属性作区别：

* 内置对象（native object）是由ECMAScript规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。
* 宿主对象（host object）是由javascript解释器所嵌入的宿主环境（比如web浏览器）定义的。客户端javascript中表示网页结构的HTMLElement对象均是宿主对象。既然宿主环境定义的方法可以当成普通的javascript函数对象，那么宿主对象也可以当成内置对象。
* 自定义对象（user-defined object）是由运行中的javascript代码创建的对象。
* 自有属性（own property）是直接在对象中定义的属性
* 继承属性（inherited property）是在对象的原型对象中定义的属性。

**6.1创建对象**
可以通过对象直接量、关键字new和(ECMAScript5中的)Object.create()函数来创建对象。
**6.1.1对象直接量**
创建对象最简单的方式就是在javascript代码中使用对象直接量。对象直接量是由若干名/值对组成的映射表，名/值对中间用冒号分隔，名/值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是javascript标识符也可以是字符串直接量（包括空字符串）。属性的值可以是任意类型的javascript表达式，表达式的值（可以是原始值也可以是对象值）就是这个属性的值。
```javascript
var empty = {};                             //没有任何属性的对象
var point = { x:0, y:0 };                   //两个属性
var point2 = { x:point.x, y:point.y+1};     //更复杂的值
var book = {               
    "main title": "javascript",             //属性名字里有空格，必须用字符串表示
    'sub-title': "the definitive guide",    //属性名字里有连字符，必须用字符串表示
    "for": "all audiences",                 //for是保留字，因此必须用引号
    author: {                               //这个属性的值是一个对象
        firstname: "david",                 //注意，这里的属性名没有引号
        surname: "flanagan"
    }
};
```
在ECMAScript5（以及ECMAScript3的一些实现）中，保留字可以用做不带引号的属性名。然而对于ECMAScript3来说，使用保留字作为属性名必须使用引号引起来。在ECMAScript5中，对象直接量中的最后一个属性后的逗号将忽略，且在ECMAScript3的大部分实现中也可以忽略这个逗号，但在IE中则报错。

对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象直接量的时候，也都会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用了对象直接量，它将创建很多新对象，并且每次创建的对象的属性值也有可能不同。

**6.1.2通过new创建对象**
new运算符创建并初始化一个新对象。关键字new后跟随一个函数调用。这里的函数称做构造函数（constructor），构造函数用以初始化一个新创建的对象。javascript语言核心中的原始类型都包含内置构造函数。例如：
```javascript
var o = new Object();//创建一个空对象，和{}一样
var a = new Array();//创建一个空数组，和[]一样
var d = new Date();//创建一个表示当前时间的Date对象
var r = new RegExp("js");//创建一个可以进行模式匹配的RegExp对象
```
除了这些内置构造函数，用自定义构造函数来初始化新对象也是非常常见的。第9章将详细讲述其中的细节。

**6.1.3原型**

在讲述第三种对象创建技术之前，我们应当首先解释一下原型。每一个javascript对象（null除外）都和另一个对象相关联。
“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。
所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过javascript代码Object.prototype获得对原型对象的引用。
通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。
因此，同使用{}创建对象一样，通过new Object()创建的对象也继承自Object.prototype。
同样，通过new Array()创建的对象的原型就是Array.prototype，通过new Date()创建的对象的原型就是Date.prototype。

没有原型的对象为数不多，Object.prototype就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。
所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自Object.prototype的原型。
例如，Date.prototype的属性继承自Object.prototype，因此由new Date()创建的Date对象的属性同时继承自Date.prototype和Object.prototype。
这一系列链接的原型对象就是所谓的“原型链”（prototype chain）。

6.2.2节讲述属性继承的工作机制。6.8.1节将会讲到如何获取对象的原型。第9章将会更详细地讨论原型和构造函数，包括如何通过编写构造函数定义对象的“类”，以及给构造函数的prototype属性赋值可以让其“实例”直接使用这个原型上的属性和方法。

**6.1.4Object.create()**
ECMAScript5定义了一个名为Object.create()的方法，它创建一个新对象，其中第一个参数是这个对象的原型。Object.create()提供第二个可选参数，用以对对象的属性进行进一步描述。[属性的特性]()这节会详细讲述第二个参数。
Object.create()是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可；
```javascript
var o1 = Object.create({x:1 ,y:2});      //o1继承了属性x和y
```
可以通过传入参数null来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如toString(),也就是说，它将不能和“+”运算符一起正常工作:
```javascript
var o2 = Object.create(null);            //o2不继承任何属性和方法
```
如果想创建一个普通的空对象（比如通过{}或new Object()创建的对象），需要传入Object.prototype:
```javascript
var o3 = Object.create(Object.prototype);//o3和{}和new Object()一样
```
可以通过任意原型创建新对象（换句话说，可以使任意对象可继承），这是一个强大的特性。在ECMAScript3中可以用类似下例的代码来模拟原型继承：
例子：通过原型继承创建一个新对象
//inherit() 返回了一个继承自原型对象p的属性的新对象
//这里使用ECMAScript5中的Object.create()函数（如果存在的话）
//如果不存在Object.create()，则退化使用其他方法
例6-1
```javascript
function inherit(p) {
    if (p == null) throw TypeError();              //p是一个对象，但不能是null
    if (Object.create)                             //如果Object.create()存在
        return Object.create(p);                   //直接使用它
    var t = typeof p;                              //否则进行进一步检测
    if (t !== "object" && t !== "function") throw TypeError();
    function f() {};                               //定义一个空构造函数
    f.prototype = p;                               //将其原型属性设置为p
    return new f();                                //使用f()创建p的继承对象
}
```
在看完[类和模块](#类和模块)这章关于构造函数的内容后，上面例子中的inherit()函数会更容易理解。现在只要知道它返回的新对象继承了参数对象的属性就可以了。注意，inherit()并不能完全代替Object.create()。它不能通过传入null原型来创建对象。而且不能接收可选的第二个参数。不过我们仍会在[对象]()这章和[类和模块]()这章的示例代码中多次用到inherit()。
inherit()函数的其中一个用途就是防止库函数无意间（非恶意地）修改那些不受你控制的对象。不是将对象直接作为参数传入函数，而是将它的继承对象传入函数。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象。
```javascript
var o = { x: "don't change this value"};
library_function(inherit(o));   //防止对o的意外修改
```
了解其工作原理，需要首先了解javascript中属性的查询和设置机制。接下来会讲到。

**6.2属性的查询和设置**
4.4节已经提到，可以通过点（.）或方括号（[]）运算符来获取属性的值。运算符左侧应当是一个表达式，它返回一个对象。对于（.）来说，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说（[]），方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字：
```javascript
var author = book.author;      //得到book的“author”属性
var name = author.surname;     //得到获得author的“surname”属性
var title = book["main title"];//得到book的“main title”属性
```
和查询属性值的写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧：
```javascript
book.edition = 6;                  //给book创建一个名为"edition"的属性
book["main title"] = "ECMAScript"; //给"main title"属性赋值
```
在ECMAScript3中，点运算符后的标识符不能是保留字，比如，o.for或o.class是非法的，因为for是javascript的关键字，class是保留字。如果一个对象的属性名是保留字，则必须使用方括号的形式访问它们，比如o["for"]和o["class"]。ECMAScript5对此放宽了限制（包括ECMAScript3的某些实现），可以在点运算符后直接使用保留字。
当使用方括号时，我们说方括号内的表达式必须返回字符串。其实更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值。在[数组]()这章里有一些例子中的方括号内使用了数字，这情况是非常常见的。

**6.2.1作为关联数组的对象**
上文提到，下面两个javascript表达式的值相同
```javascript
object.property
object["property"]
```
第一种语法使用点运算符和一个标识符，这和C和Java中访问一个结构体或对象的静态字段非常类似。第二种语法使用方括号和一个字符串，看起来像是数组，只是这个数组元素是通过字符串索引而不是数字索引。这种数组就是我们所说的关联数组（associative array），也称做散列、映射或字典（dictionary）。javascript对象都是关联数组，本节将讨论它的重要性。

在C、C++和Java和一些强类型（strong typed）的语言中，对象只能拥有固定数目的属性，并且这些须提前定义好。由于javascript是弱类型语言，因此不必遵循这条规定，在任何对象中程序都可以创建任意数量的属性。但当通过点运算符访问对象的属性时，属性名用一个标识符来表示。标识符必须直接出现在javascript程序中，它们不是数据类型，因此程序无法修改它们。

反过来讲，当通过[]来访问对象的属性时，属性名通过字符串来表示。字符串是javascript的数据类型，在程序运行时可以修改和创建它们。因此，可以在javascript中使用下面这种代码：
```javascript
var addr = "";
for(i = 0; i<4; i++){
    addr += customer["address" + i]+'\n';
}
```
这段代码读取customer的adderss0、address1、address2和address3属性，并将它们连接起来。
这个例子主要说明了使用数组写法和用字符串表达式来访问对象属性的灵活性。这段代码也可以通过点运算符来重写，但是很多场景只能通过数组写法来完成。假设你正在写一个程序，这个程序利用网络资源计算当前用户股票市场投资的金额。程序允许用户输入每只股票的名称和购股份额。该程序使用名为portfolio的对象来存储这些信息。每只股票在这个对象中都有对应的属性，属性名称就是股票名称，属性值就是购股数量，例如，如果用户持有IBM的50股，那么portfolio.ibm属性的值就为50。
下面是程序的部分代码，这个函数用来给portfolio添加新的股票：
```javascript
function addstock(portfolio,stockname,shares){
    portfolio[stockname] = shares;
}
```
由于用户是在程序运行时输入股票名称，因此在之前无法得知这些股票的名称是什么。而由于在写程序的时候不知道属性名称，因此无法通过点运算符来访问对象portfolio的属性。但可以使用[]运算符，因为它使用字符串值（字符串值是动态的，可以在运行时更改）而不是标识符(标识符是静态的，必须写死在程序中)作为索引对属性进行访问。

第5章介绍了for／in循环（6.5节还会进一步介绍）。当使用for／in循环遍历关联数组时，就可以清晰地体会到for／in的强大之处。下面例子就是利用for／in计算portfolio的总计值：
```javascript
function getvalue(portfolio) {
    var total = 0.0;
    for(stock in portfolio) {           //遍历portfolio中的每只股票
        var shares = portfolio[stock];  //得到每只股票的份额
        var price = getquote(stock);    //查找股票价格
        total += shares * price;        //将结果累加至total中
    }
    return total;                       //返回total的值
}
```

**6.2.2继承**
javascript对象具有“自有属性”（own property），也有一些属性是从原型对象继承而来的。为了更好地理解这种继承，必须更深入地了解属性访问的细节。本节中的许多示例代码借用了例6-1中的inherit()函数，通过给它传入指定原型对象来创建实例。

假设要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x。如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者查找到一个原型是null的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。
```javascript
var o = {};         //o 从Object.prototype 继承对象的方法
o.x = 1;            //给o定义一个属性
var p = inherit(o); //p继承o和Object.prototype
p.y = 2;            //给p定义一个属性y
var q = inherit(p); //q继承p、o和Object.prototype
q.z = 3;            //给q定义一个属性
var s = q.toString();//toString继承自Object.prototype
q.x + q.y            //=> 3 x和y分别继承自o和p
```
现在假设给对象o的属性x赋值，如果o中已经有属性x（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性x的值。如果o中不存在属性x，那么赋值操作给o添加一个新属性x。如果之前o继承自属性x，那么这个继承的属性就被新创建的同名属性覆盖了。
属性赋值操作首先检查原型链，以此判定是否允许赋值操作。例如，如果o继承自一个只读属性x，那么赋值操作是不允许的（6.2.3节将对此进行详细讨论）。如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。在javascript中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是javascript的一个重要特性，该特性让程序员可以有选择地覆盖（override）继承的属性。
```javascript
var unitcircle = {r:1};     //一个用来继承的对象
var c = inherit(unitcircle);//c继承属性r
c.x = 1; c.y = 1;           //c定义两个属性
c.r = 2 ;                   //c覆盖继承来的属性
unitcircle.r;               //=> 1 原型对象没有修改
```
属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性，但有一个例外，如果o继承自属性x，而这个属性是一个具有setter方法的accessor属性（参照6.6节）。那么这时将调用setter方法而不是给o创建一个属性x。需要注意的是，setter方法是由对象o调用的，而不是定义这个属性的原型对象调用的。因此如果setter方法定义任意属性，这个操作只是针对o本身，并不会修改原型链。


**6.3删除属性**

**6.4检测属性**
**6.5枚举属性**
**6.6属性getter和setter**
**6.7属性的特性**
**6.8对象的三个属性**
**6.9序列化对象**
**6.10对象方法**


数组
----
**7.1创建数组**
**7.2数组元素的读和写**
**7.3稀疏数组**
**7.4数组长度**
**7.5数组元素的添加和删除**
**7.6数组遍历**
**7.7多维数组**
**7.8数组方法**
**7.9ecmascript5中的数组方法**
**7.10数组类型**
**7.11类数组对象**
**7.12作为数组的字符串**
函数
----
**8.1函数定义**



**8.2函数调用**
**8.2.3构造函数调用**
如果函数或方法调用之前带有关键字new，它就构成构造函数调用（构造函数调用在4.6节和6.1.2节有简单介绍，[类和模块](#类和模块)这章会对构造函数做更详细地讨论）。构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。

如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内，这和函数调用和方法调用是一致的。但如果构造函数没有形参，javascript构造函数调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号，比如，下面这两行代码是等价的：
```javascript
var o = new Object();
var o = new Object;
```
构造函数调用创建一个新的空对象，这个对象继承自构造函数的prototype属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数可以使用this关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式new o.m()中，调用上下文并不是o。

构造函数通常不使用return关键字，它们通常初始化新对象。当构造函数的函数体执行完毕时，它会显示返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显示地使用return语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。


**8.3函数的实参和形参**

**8.4作为值的函数**

函数可以定义，也可以调用，这是函数最重要的特性。函数定义和调用是javascript的词法特性，对于其他大多数编程语言来说亦是如此。然而在javascript中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数等。

为了便于

**8.5作为命名空间的函数**
**8.6闭包**

和其他大多数的现代编程语言一样，javascript也采用词法作用域（lexical scoping），也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定。为了实现这种词法作用域，javascript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链（在继续阅读后续的章节之前，应当复习一下3.10节和3.10.3节中讲到的变量作用域和作用域链的概念）。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中国称为“闭包”。这个术语非常古老，是指函数变量可以被隐藏于作用域链之内，因此看起来是函数将变量“包裹”了起来。

从技术的角度讲，所有的javascript函数都是闭包的：它们都是对象，它们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不影响闭包。当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事情就变得非常微妙。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包。以至于这种编程模式在javascript中非常常见。当你第一次碰到闭包时可能会觉得非常让人费解，一旦你理解掌握了闭包之后，就能非常自如地使用它了，了解这一点至关重要。

理解闭包首先要了解嵌套函数的词法作用域规则。看一下这段代码（这段代码和你刚在3.10节中看到的代码非常类似）：
```javascript
var scope = "global scope"//全局变量
function checkscope() {
    var scope = "local scope";//局部变量
    function f() {return scope;}//在作用域中返回这个值
    return f():
}
checkscope()//=>"local scope"
```
checkscope()函数声明了一个局部变量，并定义了一个函数f()，函数f()返回了这个变量的值，最后将函数f()的执行结果返回。你应当非常清楚为什么调用checkscope()会返回“local scope”。现在我们对这段代码做一点改动。你知道这段代码返回什么吗？
```javascript
var scope = "global scope";//全局变量
function checkscope() {
    var scope = "local scope";//局部变量
    function f() {return scope;}//在作用域中返回这个值
    return f;
}
checkscope()()//返回值是什么
```
在这段代码中，我们将函数内的一对圆括号移动到了checkscope()之后。checkscope()现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对圆括号）会发生什么事情呢？

回想一下词法作用域的基本规则：javascript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数f()定义在这个作用域链里，其中的变量scope一定是局部变量，不管在何时何地执行函数f()，这种绑定在执行f()时依然有效。因此最后一段代码返回“local scope”，而不是“global scope”。简言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了在其中定义它们的外部函数。

实现闭包：如果你理解了词法作用域的规则，你就能很容易地理解闭包：函数定义时的作用域链到函数执行时依然有效。然而很多程序员觉得闭包非常难理解，因为它们在深入学习闭包的实现细节时将自己搞得晕头转向。他们觉得在外部函数中定义的局部变量在函数返回后就不存在了（之所以有这种想法是因为很多人以为函数执行结束后，与之相关的作用域链似乎也不存在了，但在javascript中并非如此），那么嵌套的函数如何能调用不存在的作用域链呢？如果你想搞清楚这个问题，你需要更深入地了解类似c语言这种更底层的编程语言，并了解基于栈的CPU架构：如果一个函数的局部变量定义在CPU的栈中，那么当函数返回时它们的确就不存在了。
但回想一下在3.10.3节中是如何定义作用域链的。我们将作用域链描述为一个对象列表，不是绑定的栈。每次调用javascript函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中。但函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也没有引用指向这个绑定对象，它就会被当做垃圾回收掉。如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链指向的一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来，那么它们也会和所指向的变量绑定对象一样当做垃圾回收。但是如果这个函数定义了嵌套的函数，并将它们作为返回值返回或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套的函数。它就不会被当做垃圾回收，并且它所指向的变量绑定对象也不会被当做垃圾回收。作者在这里清楚地解释了闭包和垃圾回收之间的关系，如果使用不慎，闭包很容易造成“循环引用”，当DOM对象和javascript对象之间存在循环引用时需要格外小心，在某些浏览器下会造成内存泄漏。

在8.4.1节中定义了uniqueInteger()函数，这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟踪上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致uniqueInteger()函数不一定能产生“唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用做私有状态。我们可以利用闭包这样来重写uniqueInteger()函数：

```javascript
var uniqueInteger = (function() {//定义函数并立即调用
    var counter = 0;//函数的私有状态
    return function() {return counter++;};
}())；
```


**8.7函数属性、方法和构造函数**
**8.8函数式编程**

类和模块
--------
第6章[对象]()详细介绍了javascript对象，每个javascript对象都是一个属性集合，相互之间没有任何联系。
在javascript中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。
类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。
这些行为通常是由类定义的，而且为所有实例所共享。
例如，假设一个名为Complex的类用来表示复数，同时还定义了一些复数运算。一个Complex实例应当包含复数的实部和虚部（状态），同样Complex类还会定义复数的加法和乘法操作（行为）。

在javascript中，类的实现是基于其原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。
javascript原型和继承在6.1.3节和6.2.2节中有详细讨论，为了更好地理解本章的内容，请务必首先阅读这两个章节。
本章将会在9.1节对原型做进一步的讨论。

如果两个对象继承自同一个原型，往往意味着（但不是绝对）它们是由同一个构造函数创建并初始化的。我们已经在4.6节、6.2节和8.2.3节中详细讲解了构造函数，9.2节会有进一步讨论。

如果你对诸如Java和C++这种强类型的面向对象编程比较熟悉，你会发现javascript中的类和Java以及C++中的类有很大的不同。尽管在写法上类似，而且在javascript中也能“模拟”出很多经典的类的特性（比如传统类的封装、继承、多态），但是要理解javascript的类和基于原型的继承机制，以及和传统的Java（当然还有类似Java的语言）的类和基于类的继承的不同之处。9.3节展示了如何在javascript中实现经典的类。
javascript中类的一个重要特性是“动态可继承”（dynamically extendable），9.4节详细解释这一特性。我们可以将类看做是类型，9.5节讲解检测对象的类的几种方式，该节同样介绍一种编程哲学——“鸭式辩型”（duck-typing），它弱化了对象的类型，强化了对象的功能。

在讨论了javascript中所有基本的面向对象编程特性之后，我们将关注点从抽象的概念转向一些实例。9.6节介绍两种非常重要的实现类的方法，包括很多实现面向对象的技术，这些技术可以很大程度上增强类的功能。9.7节展示（包含很多示例代码）如何实现类的继承，包括如何在javascript中实现类的继承。9.8节讲解如何使用ECMAScript5中的新特性来实现类以及面向对象编程。

定义类是模块开发和重用代码的有效方式之一，本章最后一节会集中讨论javascript中的模块。

强/弱类型是指类型检查的严格程度，为所有变量指定数据类型称为“强类型”。

**9.1类和原型**
在javascript中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。在例6-1中定义了inherit()函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义一个原型对象，然后通过inherit()函数创建一个继承自它的对象，这样就定义了一个javascript类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象，参照例9-1。例9-1给一个表示“值得范围”的类定义了原型对象，还定义了一个[“工厂”函数](https://zh.wikipedia.org/zh/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95)用以创建并初始化类的实例。
例9-1：一个简单的javascript类
```javascript
//range.js 实现一个能表示值得范围的类
//这个工厂方法返回一个新的“范围对象”
function range(from, to) {
    //使用inherit()函数来创建对象，这个对象继承自在下面定义的原型对象
    //原型对象作为函数的一个属性存储，并定义所有“范围对象”所共享的方法（行为）
    var r = inherit(range.methods);
    //存储新的“范围对象”的起始位置和结束位置（状态）
    //这两个属性是不可继承的，每个对象都拥有唯一的属性
    r.from = from;
    r.to = to;
    //返回这个新创建的对象
    return r;
}
//原型对象定义方法，这些方法为每个范围对象所继承
range.methods = {
    //如果x在范围内，则返回true，否则返回false
    //这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes: function(x) { return this.from <= x && x <= this.to; },
    //对于范围内的每个整数都调用一次f
    //这个方法只可用做数字范围
    foreach: function(f) {
        for(var x = Math.ceil(this.from); x <= this.to; x++) f(x);
    },
    //返回表示这个范围的字符串
    toString: function() { return "(" + this.from + "..." + this.to + ")"; }
};

//这里是使用“范围对象”的一些例子
var r = range(1,3);      //创建一个范围对象
r.includes(2);           // => true: 2 在这个范围内
r.foreach(console.log);  // 输出 1 2 3
console.log(r);          // 输出 (1...3)
```
在例子9-1中有一些代码是没有用的。这段代码定义了一个工厂方法range(),用来创建新的范围对象。我们注意到，这里给range()函数定义了一个属性range.methods，用以快捷地存放定义类的原型对象。把原型对象挂在函数上没什么大不了，但也不是惯用做法。再者，注意range()函数给每个范围对象都定义了from和to属性，用以定义范围的起始位置和结束位置，这两个属性是非共享的，当然也是不可继承的。最后，注意在range.methods中定义的那些可共享，可继承的方法都用到了from和to属性，而且使用了this关键字，为了指代它们，二者使用this关键字来指代调用这个方法的对象。任何类的方法都可以通过this的这种基本用法来读取对象的属性。


**9.2类和构造函数**
例9-1展示了在javascript中定义类的其中一种方法。但这种方法并不常用，毕竟它没有定义构造函数，构造函数是用来初始化新创建的对象的。8.2.3节已经讲到，使用关键字new来调用构造函数。使用new调用构造函数会自动创建一个新对象，因此构造函数本身只需要初始化这个新对象的状态即可。调用构造函数的一个重要特征是，构造函数的prototype属性被用做新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的成员。例9-2对例9-1的“范围类”做了修改，使用构造函数代替工厂函数：
例9-2：使用构造函数来定义“范围类”
```javascript
// 这是一个构造函数，用以初始化新创建的“范围对象”
// 注意，这里并没有创建并返回一个对象，仅仅是初始化
function Range(from, to) {
    // 存储“范围对象”的起始位置和结束位置（状态）
    // 这两个属性是不可继承的，每个对象都拥有唯一的属性
    this.from = from;
    this.to = to;
}

// 所有的“范围对象”都继承自这个对象
// 注意，属性的名字必须是“prototype”
Range.prototype = {
    // 如果x在范围内，则返回true，否则返回false
    // 这个方法可以比较数字范围，也可以比较字符串和日期范围
    includes: function(x) { return this.from <= x && x <= this.to; },
    // 对于范围内的每个整数都调用一次f
    // 这个方法只可用于数字范围.
    foreach: function(f) {
        for(var x = Math.ceil(this.from); x <= this.to; x++) f(x);
    },
    // 返回表示这个范围的字符串
    toString: function() { return "(" + this.from + "..." + this.to + ")"; }
};

// 这里是使用“范围对象”的一些例子
var r = new Range(1,3);   // 创建一个范围对象
r.includes(2);            // => true: 2 在这个范围内
r.foreach(console.log);   // 输出 1 2 3
console.log(r);           // 输出 (1...3)
```
将例9-1和例9-2中的代码做一个仔细的对比，可以发现两种定义类的技术的差别。首先，注意当工厂函数range()转化为构造函数时被重命名为Range()。这里遵循了一个常见的编程约定：从某种意义上讲，定义构造函数既是定义类，并且类名首字母要大写。而普通的函数和方法都是首字母小写。
再者，注意Range()构造函数是通过new关键字调用的（在示例代码的末尾），而range()工厂函数则不必使用new。例9-1通过调用普通函数（见8.2.1节）来创建新对象，例9-2则使用构造函数调用（见8.2.3节）来创建新对象。由于Range()构造函数是通过new关键字调用的，因此不必调用inherit()或其他什么逻辑来创建新对象。在调用构造函数之前就已经创建了新对象，通过this关键字可以获取这个新对象。Range()构造函数只不过是初始化this而已。构造函数甚至不必返回这个新创建的对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。事实上，构造函数的命名规则（首字母大写）和普通函数是如此不同还有另外一个原因，构造函数调用和普通函数调用是不尽相同的。构造函数就是用来“构造新对象”的，它必须通过关键字new调用，如果将构造函数用做普通函数的话，往往不会正常工作。开发者可以通过命名约定来（构造函数首字母大写，普通方法首字母小写）判断是否应当在函数之前冠以关键字new。

例9-1和例9-2之间还有一个非常重要的区别，就是原型对象的命名。在第一段示例代码中的原型是range.methods。这种命名方式很方便同时具有很好的语义，但又过于随意。在第二段示例代码中的原型是Range.prototype，这是一个强制的命名。对Range()构造函数的调用会自动使用Range.prototype作为新Range对象的原型。

最后，需要注意在例9-1和例9-2中两种类定义方式的相同之处，两者的范围方法定义和调用方式是完全一样的。



**9.3javascript中java式的类继承**
**9.4类的扩充**
**9.5类和类型**
**9.6javascript中的面向对象技术**
**9.7子类**
**9.8ECMAScript5中的类**
**9.9模块**


正则表达式的模式匹配
--------------------
正则表达式（regular expression）是一个描述字符模式的对象。javascript的RegExp类表示正则表达式，String和RegExp都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能。javascript的正则表达式语法是Perl5的正则表达式语法的大型子集，所以对于有Perl编程经验的程序员来说，学习javascript中的正则表达式是小菜一碟。
*有一些Perl正则表达式语法特性并不被ECMAScript支持。*
本章首先介绍用以描述“文本模式”的正则表达式语法。随后讲解了使用正则表达式的String和RegExp方法。
**10.1正则表达式的定义**
javascript中的正则表达式用RegExp对象表示，可以使用RegExp()构造函数来创建RegExp对象，不过RegExp对象更多的是通过一种特殊的直接量语法来创建。就像通过引号包裹字符的方式来定义字符串直接量一样，正则表达式直接量定义为包含在一对斜杠（/）之间的字符，例如：
```javascript
var pattern = /s$/;
```
运行这段代码创建一个新的RegExp对象，并将它赋值给变量pattern。这个特殊的RegExp对象用来匹配所有以字母“s”结尾的字符串。用构造函数RegExp()也可以定义与之等价的正则表达式，代码如下：
```javascript
var pattern = new RegExp("s$");
```
*RegExp直接量和对象的创建,就像字符串和数字一样，程序中每个取值相同的原始类型直接量均表示相同的值。这是显而易见的。程序运行时每次遇到对象直接量（初始化表达式）诸如{}和[]的时候都会创建新对象。比如，如果在循环体中写var a = []，则每次遍历都会创建一个新的空数组。*

**10.2用于模式匹配的string方法**
**10.3 regexp对象**


javascript的子集和扩展
----------------------
**11.1javascript的子集**
**11.2常量和局部变量**
**11.3解构赋值**
**11.4迭代**
**11.5函数简写**
**11.6多catch从句**
**11.7e4x:ecmascript for xml

服务器端javascript
--------------------
**12.1用rhino脚本化java**
**12.2用node实现异步i/o**

web浏览器中的javascript
-----------------------
**13.1客户端javascript**
**13.2在html里嵌入javascript**
**13.3javascript程序的执行**
**13.4兼容性和互用性**
**13.5可访问性**
**13.6安全性**
**13.7客户端框架**

window对象
----------
**14.1计时器**
**14.2浏览器定位和导航**
**14.3浏览历史**
**14.4浏览器和屏幕信息**
**14.5对话框**
**14.6错误处理**
**14.7作为window对象属性的文档元素**
**14.8多窗口和窗体**

脚本化文档
----------
**15.1dom概览**
**15.2选取文档元素**
**15.3文档结构和遍历**
**15.4属性**
**15.5元素的内容**
**15.6创建、插入和删除节点**
**15.7例子：生成目录表**
**15.8文档和元素的几何形状和滚动**
**15.9html表单**
**15.10其他文档特性**

脚本化css
---------
**16.1css概览**
**16.2重要的css属性**
**16.3脚本化内联样式**
**16.4查询计算出的样式**
**16.5脚本化css类**
**16.6脚本化样式表**

事件处理
--------
客户端javascript程序采用了异步事件驱动编程模型（13.3.2节有介绍）。在这种程序设计风格下，当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，web浏览器就会产生事件（event）。例如，当web浏览器加载完文档、用户把鼠标指针移到超链接上或敲击键盘时，web浏览器都会产生事件。如果javascript应用程序关注特定类型的事件，那么它可以注册当这类事件发生时要调用的一个或多个函数。请注意，这种风格并不只应用于web编程，所有使用图形用户界面的应用程序都采用了它，它们静待某些事件发生（即，它们等待事件发生），然后它们响应。
请注意，事件本身并不是一个需要定义的技术名词。简而言之，事件就是web浏览器通知应用程序发生了什么事情。事件不是javascript对象，不会出现在程序源代码中。当然，会有一些事件相关的对象出现在源代码中，它们需要技术说明，因此，本章从一些重要的定义开始。
事件类型（event type）是一个用来说明发生什么类型事件的字符串。例如，“mousemove”表示用户移动鼠标，“keydown”表示键盘上某个按键被按下，而“load”表示文档（或某个其他资源）从网络上加载完毕。由于事件类型只是一个字符串，因此实际上会称之为事件名字（event name），我们用这个名字来标识所谈论的特定类型的事件。现代浏览器支持许多事件类型。17.1节会有一个概述。
**17.1事件类型**
**17.2注册事件处理程序**
**17.3事件处理程序的调用**
**17.4文档加载事件**
**17.5鼠标事件**
**17.6鼠标滚轮事件**
**17.7拖放事件**
**17.8文本事件**
**17.9键盘事件**

脚本化http
----------
超文本传输协议（HyperTextTransferProtocol，HTTP）规定web浏览器如何从web服务器获取文档和向Web服务器提交表单内容，以及web服务器如何响应这些请求和提交。web浏览器会处理大量http。通常，http并不在脚本的控制下，只是当用户单击链接、提交表单和输入url时才发生。
但是，用javascript操纵http是可行的。当用脚本设置window对象的location属性或调用表单对象的submit()方法时，都会初始化http请求。在这两种情况下，浏览器会加载新页面。这种用脚本控制http的方法在多框架页面中非常有用，但这并非我们在此讨论的主题。相反，本章会说明在没有导致web浏览器重新加载任何窗口或窗体的内容情况下，脚本如何实现web浏览器与服务器之间的通信。

术语Ajax（Asynchronous javascript and xml的缩写，未全部大写）描述了一种主要使用脚本操纵http的web应用架构。
ajax应用的主要特点是使用脚本操纵http和web服务器进行数据交换，不会导致页面重载。避免页面重载（这是web初期的标准做法）的能力使web应用感觉更像传统的桌面应用。web应用可以使用ajax技术把用户的交互数据记录到服务器中；也可以开始只显示简单的页面，之后按需加载额外的数据和页面组件来提升应用的启动时间。ajax是Asynchronous Javascript and XML的缩写（未全部大写）。这个术语是Jesse James Carrett创造，最早出现在他于2005年发表的文章“Ajax:A New Approach to Web Applications”。“ajax”曾经是一个流行多年的术语，现在它只不过是一个有用的术语，来描述基于用脚本操纵http请求的web应用架构。

Comet是和使用脚本操纵http的web应用架构相关的术语。在某种意义上，Comet和Ajax相反。在comet中，web服务器发起通信并异步发送消息到客户端。如果web应用需要响应服务端发送的消息，则它使用ajax技术发送或请求数据。在ajax中，客户端从服务端“拉”数据，而在comet中，服务端向客户端“推”数据。comet还包括其他名词（如“服务器推”、“ajax推”和“http流”）。comet这个名字是由Alex Russell在“comet:Low Latency Data for the Browser“中创造的。这个名字可能是对ajax开了个玩笑，comet和ajax都是美国的洗涤日用品牌。

实现ajax和comet的方式有很多种，而这些底层的实现有时称为传输协议（transport）。例如，img元素有一个src属性。当脚本设置这个属性为url时，浏览器发起的http get请求会从这个url下载图片。因此，脚本通过设置img元素的src属性，且把信息作为图片url的查询字符串部分，就把能经过编码信息传递给web服务器。web服务器实际上必须返回某个图片来作为请求结果，但它一定要不可见：例如，一个1*1像素的透明图片。这种类型的图片也称为网页信标（web bug）。当网页信标不是与当前网页服务器而是其他服务器交流信息时，会担心隐私内容。这种第三方网页信标的方式常用于统计点击次数和网站流量分析。

img元素无法实现完整的ajax传输协议，因为数据交换是单向的：客户端能发送数据到服务器，但服务器的响应一直是张图片导致客户端无法轻易从中提取信息。然而，iframe元素更加强大，为了把iframe作为ajax传输协议使用，脚本首先要把发送给web服务器的信息编码到url中，然后设置iframe的src属性为该url。服务器能创建一个包含响应内容的html文档，并把它返回给web浏览器，并且在iframe中显示它。iframe需要对用户不可见，例如可以使用css隐藏它。脚本通过遍历iframe的文档对象来读取服务器端的响应。注意，这种访问受限于13.6.2节介绍的同源策略问题。

实际上，script元素的src属性能设置url并发起http get请求。使用script元素实现脚本操纵http是非常吸引人的，因为它们可以跨域通信而不受限于同源策略。通常，使用基于script元素的ajax传输协议时，服务器的响应采用json编码（见6.9节）的数据格式，当执行脚本时，javascript解析器能自动将其“编码”。由于它使用json数据格式，因此这种ajax传输协议也叫做“jsonp”。

虽然在iframe和script传输协议之上能实现ajax技术，但通常还有更简单的方式。一段时间以来，所有浏览器都支持XMLHttpRequest对象，它定义了用脚本操纵http的api。除了常用的get请求，这个api还包含实现post请求的能力，同时它能用文本或document对象的形式返回服务器的响应。虽然它的名字叫XMLHttpRequestAPI，但并没有限定只能使用XML文档，它能获取任何类型的文本文档。18.1节涵盖XMLHttpRequestAPI和本章的大部分。本章大部分ajax示例都将使用XMLHttpRequest对象来实现协议方案，我们也将在18.2节演示如何使用基于script的传输协议，因为script元素有规避同源限制的能力。

Ajax中的X表示XML，这个http（XMLHttpRequest）的主要客户端API在其名字中突出了XML，并且后面我们将看到XMLHttpRequest对象的其中一个属性叫responseXML。它看起来像说明XML是用脚本操纵HTTP的重要部分，但实际上它不是，这些名字只是XML流行时的遗迹。当然，ajax技术能和xml文档一起工作，但使用xml只是一种选择，实际上很少使用。XMLHttpRequest规范列出了这个令人困惑名字的不足之处：对象名XMLHttpRequest是为了兼容web，虽然这个名字的每个部分都可能造成误导。首先，这个对象支持包含XML在内的任何基于文本的格式。其次，它能用于HTTP和HTTPS请求（一些实现支持除了HTTP和HTTPS之外的协议，但规范不包括这些功能）。最后，它所支持的请求是一个广义的概念，指的是对于定义的HTTP方法的涉及HTTP请求或响应的所有活动。

Comet传输协议比Ajax更精妙，但都需要客户端和服务器之间建立（必要时重新建立）连接，同时需要服务器保持连接处于打开状态，这样它才能够发送异步信息。隐藏的iframe能像comet传输协议一样有用，例如，如果服务器以iframe中待执行的script的元素的形式发送每条消息。实现comet的一种更可靠跨平台方案是客户端建立一个和服务器的连接（使用ajax传输协议），同时服务器保持这个连接打开直到它需要推送一条消息。处理该消息之后，客户端马上为后续的消息推送建立一个新连接。

实现可靠的跨平台comet传输协议是非常有挑战性的，所以大部分使用comet架构的web应用开发者依赖于像Dojo这样的web框架库中的传输协议。在写本章时，浏览器正开始实现HTML5相关草案的Server-Sent事件，它用EventSource对象的形式定义了简单的comet api。18.3节涵盖EventSource API且演示了一个使用XMLHttpRequest实现的简单模拟示例。

在Ajax和Comet之上构建更高级的通信协议是可行的。例如，这些客户端／服务器技术可以用做RPC（Remote Procedure Call，远程过程调用）机制或发布／订阅事件系统的基础。
但是本章不会介绍像上面这样更高级的协议，我们重点在能使Ajax和Comet可用在API上。

**18.1使用xmlhttprequest**

浏览器在XMLHttpRequest类上定义了它们的Http API。这个类的每个实例都表示一个独立的请求／响应对，并且这个对象的属性和方法允许指定请求细节和提取响应数据。很多年前web浏览器就开始支持xmlhttprequest，并且其API已经到了w3c制订标准的最后阶段。同时，w3c正在制订“2级XMLHttpRequest”标准草案。本节涵盖XMLHTTPRequest核心API，也包括当前至少被两款浏览器支持的部分2级XMLHttpRequest标准草案（我们将其称为XHR2）。

当然，使用这个HTTP API必须要做的第一件事就是实例化XMLHttpRequest对象：

    var request ＝ new XMLHttpRequest();
    
你也能重用已存在的XMLHttpRequest，但注意这将会终止之前通过该对像挂起的任何请求。

IE6中的XMLHttpRequest  TODO

一个http请求由4部分组成：
*  http请求方法或“动作”（web）
* 正在请求的url
* 一个可选的请求头集合，其中可能包括身份验证信息
* 一个可选的请求主体

服务器返回的http响应包含3部分：
* 一个数字和文字组成的状态码，用来显示请求的成功和失败
* 一个响应头集合
* 响应主体

接下来的前面两节会展示如何设置http请求的每个部分和如何查询http响应的每个部分，随后的核心章节会涵盖更多的专门议题。

http的基础请求／响应架构非常简单且易于使用。但在实践中会有各种各样随之而来的复杂问题：客户端和服务器交换cookie，服务器重定向浏览器到其他服务器，缓存某些资源而剩下的不缓存，某些客户端通过代理服务器发送所有的请求等。XMLHttpRequestAPI不是协议级的HTTP API而是浏览器级的API。浏览器需要考虑cookie，重定向，缓存和代理。但代码只需要担心请求和响应。

XMLHttpRequest和本地文件，网页中可以使用相对url的能力通常意味着我们能使用本地文件系统来开发和测试html，并避免对web服务器进行不必要的部署。然后当使用XMLHttpRequest进行ajax编程时，这通常是不可行的。XMLHttpRequest用于同http和https协议一起工作。理论上，它能够同像ftp这样的其他协议一起工作，但比如像请求方法和响应状态码等部分api是http特有的。如果从本地文件中加载网页，那么该页面中的脚本将无法通过相对url使用XMLHttpRequest，因为这些url将相对于file://url而不是http://url。而同源策略通常会阻止使用绝对http://url（请参见18.1.6节）。如果是当使用XMLHttpRequest时，为了测试它们通常必须把文件上传到web服务器（或运行一个本地服务器）。

18.1.1指定请求

创建XMLHttpRequest对象之后，发起http请求的下一步是调用XMLHttpRequest对象的open()方法去指定这个请求的两个必需部分：方法和URL。

    rquest.open("GET",      //开始一个HTTP GET请求
                "data.csv");//URL的内容

open()第一个参数指定http方法或者动作。这个字符串不区分大小写，但通常大家用大写字母来匹配HTTP协议。“GET”和“POST”方法是得到广泛支持的。“GET”用于常规请求，它适用于当url完全指定请求资源，当请求对服务器没有任何副作用以及当服务器的响应是可缓存时。“POST”方法常用于html表单。它在请求主体中包含额外数据（表单数据）且这些数据常存储到服务器上的数据库中（副作用）。相同url的重复post请求从服务器得到的响应可能不同，同时不应该缓存使用这个方法的请求。除了“GET”和“POST”之外，xmlhttprequest也允许把“DELETE”、“HEAD”、“OPTIONS”和“PUT”作为open()的第一个参数。（“HTTP CONNECT”、“TRACE”和“TRACK”因为安全风险已被明确禁止。）旧浏览器并不支持所有的这些方法，但至少“HEAD”得到了广泛支持，例18-13演示如何使用它。



**18.2借助[script]发送http请求：jsonp**
**18.3基于服务器端推送事件的comet技术**

jquery类库
----------
jquery类库被广泛地使用，作为web开发者，我们必须熟悉它，即便没有在自己的代码中使用它，也很有可能在他人写的代码中遇见。幸运的是，jquery足够小巧和稳定。
jquery能让你在文档中轻松找到关心的元素，并对这些元素进行操作：添加内容、编辑hmtl属性和css属性、定义事件处理程序，以及执行动画。它还拥有ajax工具来动态地发起http请求，以及一些通用的工具函数来操作对象和数组。
正如其名，jquery类库聚焦于查询。一个典型查询使用css选择器来识别一组文档元素，并返回一个对象来表示这些元素。返回的对象提供了大量有用的方法来批量操作匹配的元素。这些方法会尽可能返回调用对象本身，这使得简洁的链式调用成为可能。jquery如此强大和好用，关键得益于以下特性：

* 丰富强大的语法（css选择器），用来查询文档元素
* 高效的查询方法，用来找到与css选择器匹配的文档元素集
* 一套有用的方法，用来操作选中的元素
* 强大的函数式编程技巧，用来批量操作元素集，而不是每次只操作单个
* 简洁的语言用法（链式调用），用来表示一系列顺序操作

**19.1jquery基础**

**19.2jquery的getter和setter**
**19.3修改文档结构**
**19.4使用jquery处理事件**
**19.5动画效果**
**19.6jquery中的ajax**
**19.7工具函数**
**19.8jquery选择器和选取方法**
**19.9jquery的插件扩展**
**19.10 jquery ui 类库**

客户端存储
----------
**20.1 localstorage和sessionstorage**
**20.2 cookie**
**20.3 利用ie userdata持久化数据**
**20.4 应用程序存储和离线web应用**

多媒体和图形编程
----------------
**21.1脚本化图片**
**21.2脚本化音频和视频**
**21.3svg:可伸缩的矢量图形**
**21.4[canvas]中的图形**

HTML5 API
------------

**22.1地理位置**

**22.2历史纪录管理**

**22.3跨域消息传递**

**22.4web worker**

**22.5类型化数组和arraybuffer**

**22.6blob**

**22.7文件系统api**

**22.8客户端数据库**

**22.9web套接字**

第18章介绍过客户端javascript代码如何通过网络进行通信。该章中的例子都使用http协议，这也意味着它们受限于http协议的特性：它是一种无状态的协议，由客户端请求和服务端响应组成。http实际上是相对比较特殊的网络协议。大多数基于因特网（或者局域网）的网络连接通常都包含长连接和基于tcp套接字的双向消息交换。让不信任的客户端脚本访问底层的tcp套接字是不安全的，但是WebSocket API定义了一种安全方案：它允许客户端代码在客户端和支持websocket协议的服务器端创建双向的套接字类型的连接。这让某些网络操作会变得更加简单。
要通过使用javascript使用websocket，只须了解这里要介绍的websocket api。其中并没有用于书写一个websocket服务器的服务器端api，但是本节会有一个简单服务器例子，该例子使用node（见12.2节）和第三方的websocket服务器库来实现。客户端和服务器端的通信是通过tcp套接字长连接实现的，其遵循websocket协议定义的规则。关于websocket协议的细节这里不做详细介绍，但是，值得注意的是，websocket是经过精心设计的协议，实现让web服务器能够很容易地同时处理同一端口上的http连接和websocket连接。
很多浏览器提供商都实现了websocket。但是，由于发现早期草案版本的websocket协议有重要的安全漏洞，因此，一直到撰写本书时，有些浏览器在安全版本的协议未标准化之前，都将它们支持的websocket功能关闭了。比如，在firefox4中，要启用websocket功能，需要访问about:config页面，然后将配置变量“network.websocket.override-security-block”设置为true。

websocket api的使用非常简单。首先，通过websocket()构造函数创建一个套接字：

    var socket = new WebSocket("ws://ws.example.com:1234/resource");
    
创建了套接字之后，通常需要在上面注册一个事件处理程序：
```javascript
    socket.onopen = function(e){/*套接字已经连接*/};
    socket.onclose = function(e){/*套接字已经关闭*/};
    socket.onerror = function(e){/*出错了*/};
    socket.onmessage = function(e){
        var message = e.data;/*服务器发送一条消息*/
    };
```
为了通过套接字发送数据给服务器，可以调用套接字的send()方法：
```javascript
    socket.send("hello,server");
```
当前版本的websocket api仅支持文本消息，并且必须以UTF-8编码形式的字符串传递给该消息。然而，当前websocket协议还包含对二进制消息的支持，未来版本的api可能会允许在客户端和websocket服务器端进行二进制数据的交换。
当完成和服务器的通信之后，可以通过调用close方法来关闭websocket。
websocket完全是双向的，并且一旦建立了websocket连接，客户端和服务器端都可以在任何时候互相传送消息，与此同时，这种通信机制采用的不是请求和响应的形式。每个基于websocket的服务都要定义自己的“子协议”，用于在客户端和服务器端传输数据。慢慢的，这些“子协议”也可能发生演变，可能最终要求客户端和服务器端需要支持多个版本的子协议。幸运的是，websocket协议包含一种协商机制，用于选择客户端和服务器端都能“理解”的子协议。可以传递一个字符串数组给WebSocket()构造函数。服务器端会将该数组作为客户端能够理解的子协议列表。然后，它会选择其中一个使用，并将它传递给客户端。一旦连接建立之后，客户端就能够通过套接字protocol属性监测当前在使用的是哪种子协议。

1.8节介绍了EventSource API，并通过一个在线聊天的客户端和服务器展示了这些api如何使用。有了websocket，写这类应用就变得更加容易了。例22-16就是一个简单的聊天客户端：它和例18-5很像，不同的是它采用了websocket来实现双向通信，而没有使用EventSource来获取消息以及XMLHttpRequest来发送消息。

例22-16：基于WebSocket的聊天客户端：

```javascript
window.onload = function() {
    // Take care of some UI details，关心一些UI细节
    var nick = prompt("Enter your nickname");     // Get user's nickname，获取用户昵称
    var input = document.getElementById("input"); // Find the input field，查找input字段
    input.focus();                                // Set keyboard focus，设置光标
    // Open a WebSocket to send and receive chat messages on，打开一个websocket用于发送和接收聊天消息
    // Assume that the HTTP server we were downloaded from also functions as
    //假设下载的HTTP服务器作为websocket服务器运作，并且使用相同de主机名和端口
    // a websocket server, and use the same host name and port, but change
    //只是协议由http变成了ws
    // from the http:// protocol to ws://
    var socket = new WebSocket("ws://" + location.host + "/");
    // This is how we receive messages from the server through the web socket
    //下面展示了如何通过websocket从服务器获取消息
    socket.onmessage = function(event) {          // When a new message arrives，当收到一条消息
        var msg = event.data;                     // Get text from event object，从事件对象中获取消息内容
        var node = document.createTextNode(msg);  // Make it into a text node，将它标记为一个文本节点
        var div = document.createElement("div");  // Create a <div>，创建一个div
        div.appendChild(node);                    // Add text node to div，将文本节点添加到该div
        document.body.insertBefore(div, input);   // And add div before input，在input前添加该div
        input.scrollIntoView();                   // Ensure input elt is visible，确保输入框可见
    }
    // This is how we send messages to the server through the web socket
    //下面展示了如何通过websocket发送消息给服务器端
    input.onchange = function() {                 // When user strikes return，当用户敲击回车键
        var msg = nick + ": " + input.value;      // Username plus user's input，用户昵称加上用户的输入
        socket.send(msg);                         // Send it through the socket，通过套接字传递该内容
        input.value = "";                         // Get ready for more input，等待更多内容的输入
    }
};
```

```javascript
//The chat UI is just a single, wide text input field 
//聊天窗口UI很简单，一个宽的文本输入框
// New chat messages will be inserted before this element 
// 新的聊天消息会插入到该元素中
<input id="input" style="width:100%"/>
```


例22-17是一个基于websocket的聊天服务器，运行在node中（见12.2节）。通过将该例和例18-17作比较，可以发现，websocket将聊天应用的服务器端简化成和客户端一样。

例22-17：使用websocket和node的聊天服务器

```javascript
/*
 * This is server-side JavaScript, intended to be run with NodeJS.这是运行在nodejs上的服务器端javascript
 * It runs a WebSocket server on top of an HTTP server, using an external
 *在HTTP服务器之上，它运行一个websocket服务器，该服务器使用自https://github.com/miksago/node-websocket-server/的第三方websocket库实现
 * websocket library from https://github.com/miksago/node-websocket-server/
 * If it gets an  HTTP request for "/" it returns the chat client HTML file.
 *如果得到“／”的一个HTTP请求，则返回聊天客户端的HTML文件
 * Any other HTTP requests return 404. Messages received via the 
 *除此之外任何HTTP请求都返回404
 * WebSocket protocol are simply broadcast to all active connections.
 *通过websocket协议接收到的消息都仅广播给所有激活状态的连接
 */
var http = require('http');            // Use Node's HTTP server API，使用node的HTTP服务器api
var ws = require('websocket-server');  // Use an external WebSocket library，使用第三方websocket库

// Read the source of the chat client at startup. Used below.
//启动阶段，读取聊天客户端的资源文件
var clientui = require('fs').readFileSync("wschatclient.html");

// Create an HTTP server，创建一个HTTP服务器
var httpserver = new http.Server();  

// When the HTTP server gets a new request, run this function
//当HTTP服务器获得一个新请求时，运行此函数
httpserver.on("request", function (request, response) {
    // If the request was for "/", send the client-side chat UI.
    //如果请求“／”，则返回客户端聊天UI
    if (request.url === "/") {  // A request for the chat UI，请求聊天UI
        response.writeHead(200, {"Content-Type": "text/html"});
        response.write(clientui);
        response.end();
    }
    else {  // Send a 404 "Not Found" code for any other request，对任何其他的请求返回404无法找到编码
        response.writeHead(404);
        response.end();
    }
});

// Now wrap a WebSocket server around the HTTP server，在HTTP服务器上包装一个websocket服务器
var wsserver = ws.createServer({server: httpserver});

// Call this function when we receive a new connection request，当调用一个新的连接请求的时候，调用此函数
wsserver.on("connection", function(socket) {
    socket.send("Welcome to the chat room."); // Greet the new client，向新客户端打招呼
    socket.on("message", function(msg) {      // Listen for msgs from the client，监听来自客户端的消息
        wsserver.broadcast(msg);              // And broadcast them to everyone，并将它们广播给每个人
    });
});

// Run the server on port 8000. Starting the WebSocket server starts the
//在8000端口运行服务器。启动websocket服务器的时候也会启动HTTP服务器。
// HTTP server as well. Connect to http://localhost:8000/ to use it.
//连接到http://localhost:8000/，并开始使用它
wsserver.listen(8000);
```


javascript核心参考
------------------
参考文档：包括javascript语言核心定义的类、方法和属性。

| | | | |
|-------|--------|-----|--------|
|Arguments|EvalError|Number|String|
|Array|Function|Object|SyntaxError|
|Boolean|Global|RangeError|TypeError|
|Date|JSON|ReferenceError|URIError|
|Error|Math|RegExp| |

客户端javascript核心参考
-----------------------
javascript语言核心怎对文本、数组、日期和正则表达式的操作定义了很少的api，但是这些api不包括输入输出功能。输入和输出功能（类似网络、存储和图形相关的复杂特性）是由javascript所属的宿主环境提供的，这里所说的宿主环境通常是web浏览器，还有其他。




