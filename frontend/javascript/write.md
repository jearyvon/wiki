**10.1.6修饰符**

正则表达式中的语法还有最后一个知识点，即正则表达式的修饰符，用以说明高级匹配模式的规则。和之前讨论的正则表达式语法不同，修饰符是放在“/”符号之外的，也就是说，它们不是出现在两条斜线之间，而是第二条斜线之后。JavaScript支持三个修饰符，修饰符“i”用以说明模式匹配是不区分大小写的。修饰符“g”说明模式匹配应该是全局的，也就是说，应该找出被检索字符串中所有的匹配。修饰符“m”用以在多行模式中执行匹配，在这种模式下，如果待检索的字符串包含多行，那么^和$锚字符除了匹配整个字符串的开始和结尾之外，还能匹配每行的开始和结尾。比如正则表达式/java$/im可以匹配“java”也可以匹配“Java\nis fun”。

这些修饰符可以任意组合，比如，要想不区分大小写匹配字符串中的第一个单词“java”（“Java”或“JAVA”等），可以使用不区分大小写的修饰符来定义正则表达式/\bjava\b/i。要想匹配字符串中所有的单词，则需要添加修饰符g：/\bjava\b/gi。

表10-6对正则表达式的修饰符做了总结，注意，在本章的后续内容中还会介绍在String和RegExp的方法中使用修饰符g的示例。

表10-6：正则表达式修饰符

|字符|含义|
|----|----|
|i|执行不区分大小写的匹配|
|g|执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就会停止|
|m|多行匹配模式，^匹配一行的开头和字符串的开头，$匹配行的结束和字符串的结束|

**10.2用于模式匹配的String方法**

到目前为止，尽管本章已经讨论过创建正则表达式的语法，但还没有尝试过如何在Javascript代码中使用这些正则表达式。本节将讨论String对象的一些用以执行正则表达式模式匹配和检索替换操作的方法，后续几节还会继续讨论如何使用Javascript正则表达式的模式匹配，不过将侧重于RegExp对象和它的方法及属性。注意，下面的讨论只是与正则表达式相关的方法和属性的概述。同样，可以在本书第三部分中查找到完整的介绍。

String支持4种使用正则表达式的方法。最简单的是search()。它的参数是一个正则表达式，返回第一个与之匹配的子串的起始位置，如果找不到匹配的子串，它将返回-1。比如，下面的调用返回值为4：
```javascript
  "javascript".search(/script/i);
```
如果search()的参数不是正则表达式，则首先会通过RegExp构造函数将它转换成正则表达式，search()方法不支持全局检索，因为它忽略正则表达式参数中的修饰符g。

replace()方法用以执行检索与替换操作。其中第一个参数是一个正则表达式，第二个参数是要进行替换的字符串。这个方法会对调用它的字符串进行检索，使用指定的模式来匹配。如果正则表达式中设置了修饰符g，那么源字符串中所有与模式匹配的子串都将替换成第二个参数指定的字符串；如果不带修饰符g，则只替换所匹配的的第一个子串。如果replace()的第一个参数是字符串而不是正则表达式，则replace()将直接搜索这个字符串，而不是像search()一样首先通过RegExp()将它转换为正则表达式。比如，可以使用下面的方法，利用replace()将文本中的所有javascript（不区分大小写）统一替换为“JavaScript”：
```javascript
//将所有不区分大小写的javascript都替换成大小写正确的javascript
text.replace(/javascript/gi,"JavaScript");
```
但replace()的功能远不止这些。回忆一下前文所提到的，正则表达式中使用圆括号括起来的子表达式是带有从左到右的索引编号的，而且正则表达式会记忆与每个子表达式匹配的文本。如果在替换字符串中出现了$加数字，那么replace()将用与指定的子表达式相匹配的文本来替换这两个字符。这是一个非常有用的特性。比如，可以用它将一个字符串中的英文引号替换为中文半角引号：
```javascript
//一段引用文本起始于引号，结束于引号
//中间的内容区域不能包含引号
var quote = /"([^"]*)"/g;
//用中文半角引号替换英文引号，同时要保持引号之间的内容（存储在$1中）没有被修改
text.replace(quote,' "$1" ');
```
replace()方法还有一些其他重要特性，这些特性将在本书第三部分关于String.replace()的主题页中进行介绍。最值得注意的是，replace()方法的第二个参数可以是函数，该函数能够动态地计算替换字符串。

match()方法是最常用的String正则表达式方法。它的唯一参数就是一个正则表达式（或通过RegExp()构造函数将其转换为正则表达式），返回的是一个由匹配结果组成的的数组。如果该正则表达式设置了修饰符g，则该方法返回的数组包含字符串中的所有匹配结果。例如：
```javascript
"1 plus 2 equals 3".match(/\d+g/) //返回["1", "2", "3"]
```
如果这个正则表达式没有设置修饰符g，match()就不会进行全局检索，它只检索第一个匹配。但即使match()执行的不是全局检索，它也返回一个数组。在这种情况下，数组的第一个元素就是匹配的字符串，余下的元素则是正则表达式中用圆括号括起来的子表达式。因此，如果match()返回一个数组a，那么a[0]存放的是完整的匹配，a[1]存放的则是与第一个用圆括号括起来的表达式相匹配的子串，以此类推。为了和方法replace()保持一致，a[n]存放的是$n的内容。
例如，使用如下的代码来解析一个URL：
```javascript
var url = /(w+):\/\/([\w.]+)\/(\S*)/;
var text = "Visit my blog at http://www.example.com/~david";
var result = text.match(url);
if (result!-null) {
  var fullurl = result[0]; //包含“http://www.example.com/~david”
  var protocol = result[1]; //包含“http”
  var host = result[2]; //包含“www.example.com”
  var path = result[3]; //包含“~david”
}
```
值得注意的是，给字符串的match()方法传入一个非全局的正则表达式，实际上和给这个正则表达式的exec()方法传入的字符串是一模一样的，它返回的数组带有两个属性：
index和input，接下来对exec()方法的讨论中会提到：
String对象的最后一个和正则表达式相关的方法是split()。这个方法用以将调用它的字符串拆分为一个子串组成的数组，使用的分隔符是split()的参数，例如：
```javascript
"123,456,789".split(",");//返回["123","456","789"]
```
split()方法还有其他一些特性，本书第三部分有关于String.split()更详尽的说明。

**10.3RegExp对象**

正如本章开始所讲到的，正则表达式是通过RegExp对象来表示的。除了RegExp()构造函数之外，RegExp对象还支持三个方法和一些属性。接下来的两节会对RegExp模式匹配方法和属性展开讲述。

RegExp()构造函数非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则表达式直接量来实现。例如，如果待检索的字符串是由用户输入的，就必须使用RegExp()构造函数，在程序运行时创建正则表达式。

**10.3.1RegExp的属性**

每个RegExp对象都包含5个属性。属性source是一个只读的字符串，包含正则表达式的文本。属性global是一个只读的布尔值，用以说明这个正则表达式是否带有修饰符g。属性ignoreCase也是一个只读的布尔值，用以说明正则表达式是否带有修饰符m。最后一个属性lastIndex，它是一个可读/写的整数。如果匹配模式带有g修饰符，这个属性存储在整个字符串中下一次检索的开始位置，这个属性会被exec()和test()方法用到，下面会讲到。

**10.3.2RegExp的方法**

RegExp对象定义了两个用于执行模式匹配操作的方法。它们的行为和上文介绍过的String方法很类似。RegExp最主要的执行模式匹配的方法是exec()，它与10.2节介绍过的String方法match()相似，只是RegExp方法的参数是一个字符串，而String方法的参数是一个RegExp对象。exec()方法对一个指定的字符串执行了一个正则表达式，简言之，就是在一个字符串中执行匹配检索。如果它没有找到任何匹配，它就返回null，但如果它找到了一个匹配，它将返回一个数组，就像match()方法为非全局检索返回的数组一样。这个数组的第一个元素包含的是与正则表达式相匹配的字符串，余下的元素是与圆括号内的子表达式相匹配的子串。属性index包含了发生匹配的字符位置，属性input引用的是正在检索的字符串。

和match()方法不同，不管正则表达式是否具有全局修饰符g，exec()都会返回一样的数组。回忆一下，当match()的参数是一个全局正则表达式时，它返回由匹配结果组成的数组。相比之下，exec()总是返回一个匹配结果，并提供关于本次匹配的完整信息。当调用exec()的正则表达式对象具有修饰符g时，它将把当前正则表达式对象的lastIndex属性设置为紧挨着匹配子串的字符位置，当同一个正则表达式第二次调用exec()时，它将从lastIndex属性所指示的字符处开始检索。如果exec()没有发现任何匹配结果，它会将lastIndex重置为0（在任何时候都可以将lastIndex属性设置为0，每当在字符串中找最后一个匹配项后，在使用这个RegExp对象开始新的字符串查找之前，都应当将lastIndex设置为0）。这种特殊的行为使我们可以在用正则表达式匹配字符串的过程中反复调用exec()，比如：
```javascript
var pattern = /Java/g;
var text = "JavaScript is more fun than Java!";
var result;
while((result = pattern.exec(text)) !- null) {
  alert("Matched'" + result[0] + "'" + " at position " + result.index + "; next search begins at " + pattern.lastIndex);
}
```
另外一个RegExp方法是test()，它比exec()更简单一些。它的参数是一个字符串，用test()对某个字符串进行检测，如果包含正则表达式的一个匹配结果，则返回true：
```javascript
var pattern = /java/i;
pattern.test("JavaScript"); //返回 true
```
调用test()和调用exec()等价，当exec()的返回结果不是null时，test()返回true。由于这种等价性，当一个全局正则表达式调用方法test()时，它的行为和exec()相同，因为它从lastIndex指定的位置处开始检索某个字符串，如果它找到了一个匹配结果，那么它就立即设置lastIndex为当前匹配子串的结束位置。这样一来，就可以使用test()来遍历字符串，就像用exec()方法一样。

与exec()和test()不同，String方法search()、replace()和match()并不会用到lastIndex属性。实际上，String方法只是简单地将lastIndex属性重置为0。如果让一个带有修饰符g的正则表达式对多个字符串执行exec()或test()，要么在每个字符串中找出所有的匹配以便将lastIndex自动重置为零，要么显式将lastIndex手动设置为0（当最后一次检索失败时需要手动设置lastIndex）。如果忘了手动设置lastIndex的值，那么下一次对新字符串进行检索时，执行检索的起始位置可能就不是字符串的开始位置，而可能是任意位置。当然，如果RegExp不带有修饰符g，则不必担心会发生这种情况。同样要记住，在ECMAScript5中，正则表达式直接量的每次计算都会创建一个新的RegExp对象，每个新RegExp对象具有各自的lastIndex属性，这势必会大大减少“残留”lastIndex对程序造成的意外影响。







